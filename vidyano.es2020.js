var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {
(function (global, factory) {
    module.exports = factory() ;
}(commonjsGlobal, (function () {    var hookCallback;
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }
    function isObject(input) {
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }
    function isUndefined(input) {
        return input === void 0;
    }
    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }
    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }
    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;
            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
            return false;
        };
    }
    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));
            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;
    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }
    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2);
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }
    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    var keys;
    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }
    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }
    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }
    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }
    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }
    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    var match1 = /\d/,
        match2 = /\d\d/,
        match3 = /\d{3}/,
        match4 = /\d{4}/,
        match6 = /[+-]?\d{6}/,
        match1to2 = /\d\d?/,
        match3to4 = /\d\d\d\d?/,
        match5to6 = /\d\d\d\d\d\d?/,
        match1to3 = /\d{1,3}/,
        match1to4 = /\d{1,4}/,
        match1to6 = /[+-]?\d{1,6}/,
        matchUnsigned = /\d+/,
        matchSigned = /[+-]?\d+/,
        matchOffset = /Z|[+-]\d\d:?\d\d/gi,
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;
    regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;
    function mod(n, x) {
        return ((n % x) + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }
    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addUnitPriority('month', 8);
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;
    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }
    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
            return mom;
        }
        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }
    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    addUnitAlias('year', 'y');
    addUnitPriority('year', 1);
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet('FullYear', true);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
    }
    function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
    }
    function firstWeekOffset(year, dow, doy) {
        var
            fwd = 7 + dow - doy,
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }
        return {
            week: resWeek,
            year: resYear,
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6,
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }
        return null;
    }
    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }
    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });
    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    addUnitPriority('hour', 13);
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
        return (input + '').toLowerCase().charAt(0) === 'p';
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        getSetHour = makeGetSet('Hours', true);
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse,
    };
    var locales = {},
        localeFamilies = {},
        globalLocale;
    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }
    function isLocaleNameSane(name) {
        return name.match('^[^/\\\\]*$') != null;
    }
    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        if (
            locales[name] === undefined &&
            'object' !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = commonjsRequire;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                locales[name] = null;
            }
        }
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }
            getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }
            getSetGlobalLocale(name);
        } else {
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys(locales);
    }
    function checkOverflow(m) {
        var overflow,
            a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;
            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];
        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }
        return result;
    }
    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }
    function preprocessRFC2822(s) {
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        if (config._strict) {
            config._isValid = false;
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    hooks.ISO_8601 = function () {};
    hooks.RFC_2822 = function () {};
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;
        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;
        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
                validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, 'd');
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i,
            format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }
        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }
        if (!isValid(config)) {
            config._d = null;
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }
        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }
        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
    }
    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };
    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];
    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }
        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false;
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }
        return true;
    }
    function isValid$1() {
        return this._isValid;
    }
    function createInvalid$1() {
        return createDuration(NaN);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 +
            minutes * 6e4 +
            hours * 1000 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;
        if (matches === null) {
            return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function () {};
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
        var c = {},
            other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
        var duration = input,
            match = null,
            sign,
            ret,
            diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign,
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }
        return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {};
        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, 'M');
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
        if (!mom.isValid()) {
            return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }
    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');
    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }
    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }
    function calendar$1(time, formats) {
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);
        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }
    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
            return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
            return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break;
            case 'minute':
                output = (this - that) / 6e4;
                break;
            case 'hour':
                output = (this - that) / 36e5;
                break;
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break;
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break;
            default:
                output = this - that;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );
    function localeData() {
        return this._locale;
    }
    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }
    function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }
    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }
    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }
    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');
    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);
    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );
    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);
    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });
    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }
            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }
    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;
                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;
                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }
    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }
    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }
        return '';
    }
    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }
        return '';
    }
    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }
        return '';
    }
    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;
            val = this.clone().startOf('day').valueOf();
            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }
        return this.year();
    }
    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }
    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    addFormatToken('Q', 0, 'Qo', 'quarter');
    addUnitAlias('quarter', 'Q');
    addUnitPriority('quarter', 7);
    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    addUnitAlias('date', 'D');
    addUnitPriority('date', 9);
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addUnitPriority('dayOfYear', 4);
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }
    addFormatToken('m', ['mm', 2], 0, 'minute');
    addUnitAlias('minute', 'm');
    addUnitPriority('minute', 14);
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', ['ss', 2], 0, 'second');
    addUnitAlias('second', 's');
    addUnitPriority('second', 15);
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });
    addUnitAlias('millisecond', 'ms');
    addUnitPriority('millisecond', 16);
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }
    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );
    function createUnix(input) {
        return createLocal(input * 1000);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }
        format = format || '';
        if (index != null) {
            return get$1(format, index, field, 'month');
        }
        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || '';
        }
        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];
        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }
    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });
    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return (days * 4800) / 146097;
    }
    function monthsToDays(months) {
        return (months * 146097) / 4800;
    }
    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }
    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');
    function clone$1() {
        return createDuration(this);
    }
    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }
    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round,
        thresholds = {
            ss: 44,
            s: 45,
            m: 45,
            h: 22,
            d: 26,
            w: null,
            M: 11,
        };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);
        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }
    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var withSuffix = false,
            th = thresholds,
            locale,
            output;
        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }
        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;
        if (!total) {
            return 'P0D';
        }
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });
    hooks.version = '2.29.4';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        DATE: 'YYYY-MM-DD',
        TIME: 'HH:mm',
        TIME_SECONDS: 'HH:mm:ss',
        TIME_MS: 'HH:mm:ss.SSS',
        WEEK: 'GGGG-[W]WW',
        MONTH: 'YYYY-MM',
    };
    return hooks;
})));
});

var moment$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__moduleExports: moment,
	default: moment
});

var
  isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  mathceil = Math.ceil,
  mathfloor = Math.floor,
  bignumberError = '[BigNumber Error] ',
  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
  BASE = 1e14,
  LOG_BASE = 14,
  MAX_SAFE_INTEGER = 0x1fffffffffffff,
  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  SQRT_BASE = 1e7,
  MAX = 1E9;
function clone$2(configObject) {
  var div, convertBase, parseNumeric,
    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
    ONE = new BigNumber(1),
    DECIMAL_PLACES = 20,
    ROUNDING_MODE = 4,
    TO_EXP_NEG = -7,
    TO_EXP_POS = 21,
    MIN_EXP = -1e7,
    MAX_EXP = 1e7,
    CRYPTO = false,
    MODULO_MODE = 1,
    POW_PRECISION = 0,
    FORMAT = {
      prefix: '',
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ',',
      decimalSeparator: '.',
      fractionGroupSize: 0,
      fractionGroupSeparator: '\xA0',
      suffix: ''
    },
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
    alphabetHasNormalDecimalDigits = true;
  function BigNumber(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str,
      x = this;
    if (!(x instanceof BigNumber)) return new BigNumber(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == 'number') && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, 'Base');
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == 'number') {
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error
           (tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
      else e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++);
    for (len = str.length; str.charCodeAt(--len) === 48;);
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber.DEBUG &&
        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error
           (tooManyDigits + (x.s * v));
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += '0');
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber.clone = clone$2;
  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;
  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == 'object') {
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error
               (bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto &&
               (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error
             (bignumberError + p + ' not true or false: ' + v);
          }
        }
        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;
          else throw Error
           (bignumberError + p + ' not an object: ' + v);
        }
        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p];
          if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
            ALPHABET = v;
          } else {
            throw Error
             (bignumberError + p + ' invalid: ' + v);
          }
        }
      } else {
        throw Error
         (bignumberError + 'Object expected: ' + obj);
      }
    }
    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };
  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;
    var i, n,
      c = v.c,
      e = v.e,
      s = v.s;
    out: if ({}.toString.call(c) == '[object Array]') {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;
        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }
          if (n !== 0) return true;
        }
      }
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error
      (bignumberError + 'Invalid BigNumber: ' + v);
  };
  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, -1);
  };
  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, 1);
  };
  BigNumber.random = (function () {
    var pow2_53 = 0x20000000000000;
    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
     ? function () { return mathfloor(Math.random() * pow2_53); }
     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
       (Math.random() * 0x800000 | 0); };
    return function (dp) {
      var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k;) {
            v = a[i] * 0x20000 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k;) {
            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error
           (bignumberError + 'crypto unavailable');
        }
      }
      if (!CRYPTO) {
        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--);
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();
  BigNumber.sum = function () {
    var i = 1,
      args = arguments,
      sum = new BigNumber(args[0]);
    for (; i < args.length;) sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = (function () {
    var decimal = '0123456789';
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        len = str.length;
      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y,
        i = str.indexOf('.'),
        dp = DECIMAL_PLACES,
        rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
         10, baseOut, decimal);
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString
       ? (alphabet = ALPHABET, decimal)
       : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop());
      if (!xc[0]) return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
             rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k];);
        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  })();
  div = (function () {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi,
        carry = 0,
        i = x.length,
        klo = k % SQRT_BASE,
        khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry) x = [carry].concat(x);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1));
    }
    return function (x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
        yL, yz,
        s = x.s == y.s ? 1 : -1,
        xc = x.c,
        yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber(
         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0
       );
      }
      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++);
      if (yc[i] > (xc[i] || 0)) e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0);
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        do {
          n = 0;
          cmp = compare(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base) n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  })();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
       ? toExponential(str, ne)
       : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += '0', len++);
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, '0');
        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += '.';
            for (; i--; str += '0');
          }
        }
      }
    }
    return n.s < 0 && c0 ? '-' + str : str;
  }
  function maxOrMin(args, n) {
    var k, y,
      i = 1,
      x = new BigNumber(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1,
      j = c.length;
    for (; !c[--j]; c.pop());
    for (j = c[0]; j >= 10; j /= 10, i++);
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = (function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      dotAfter = /^([^.]+)\.$/,
      dotBefore = /^\.([^.]+)$/,
      isInfinityOrNaN = /^-?(Infinity|NaN)$/,
      whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function (x, str, isNum, b) {
      var base,
        s = isNum ? str : str.replace(whitespaceOrPlus, '');
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }
          if (str != s) return new BigNumber(s, base);
        }
        if (BigNumber.DEBUG) {
          throw Error
            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    }
  })();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd,
      xc = x.c,
      pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0));
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++);
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 ||
         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4
         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&
          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
           rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ;) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++);
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop());
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str,
      e = n.e;
    if (e === null) return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
      ? toExponential(str, e)
      : toFixedPoint(str, e, '0');
    return n.s < 0 ? '-' + str : str;
  }
  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };
  P.decimalPlaces = P.dp = function (dp, rm) {
    var c, n, v,
      x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;
    return n;
  };
  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function (n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
      x = this;
    n = new BigNumber(n);
    if (n.c && !n.isInteger()) {
      throw Error
        (bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }
    if (m != null) m = new BigNumber(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1) k = 1 / k;
      return new BigNumber(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber(ONE);
    for (; ;) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;
        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };
  P.isFinite = function () {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
  };
  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };
  P.isNaN = function () {
    return !this.s;
  };
  P.isNegative = function () {
    return this.s < 0;
  };
  P.isPositive = function () {
    return this.s > 0;
  };
  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function (y, b) {
    var i, j, t, xLTy,
      x = this,
      a = x.s;
    y = new BigNumber(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :
         ROUNDING_MODE == 3 ? -0 : 0);
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0));
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1;
    for (; j > a;) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye);
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function (y, b) {
    var q, s,
      x = this;
    y = new BigNumber(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function (y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
      base, sqrtBase,
      x = this,
      xc = x.c,
      yc = (y = new BigNumber(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0));
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function (y, b) {
    var t,
      x = this,
      a = x.s;
    y = new BigNumber(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber(NaN);
     if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0));
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function (sd, rm) {
    var c, n, v,
      x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber(x), sd, rm);
    }
    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--);
      for (v = c[0]; v >= 10; v /= 10, n++);
    }
    if (sd && x.e + 1 > n) n = x.e + 1;
    return n;
  };
  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };
  P.squareRoot = P.sqrt = function () {
    var m, n, r, rep, t,
      x = this,
      c = x.c,
      s = x.s,
      e = x.e,
      dp = DECIMAL_PLACES + 4,
      half = new BigNumber('0.5');
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }
      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;
      for (; ;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);
          if (n == '9999' || !rep && n == '4999') {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function (dp, rm, format) {
    var str,
      x = this;
    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error
        (bignumberError + 'Argument not an object: ' + format);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i,
        arr = str.split('.'),
        g1 = +format.groupSize,
        g2 = +format.secondaryGroupSize,
        groupSeparator = format.groupSeparator || '',
        intPart = arr[0],
        fractionPart = arr[1],
        isNeg = x.s < 0,
        intDigits = isNeg ? intPart.slice(1) : intPart,
        len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }
      str = fractionPart
       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
        ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
         '$&' + (format.fractionGroupSeparator || ''))
        : fractionPart)
       : intPart;
    }
    return (format.prefix || '') + str + (format.suffix || '');
  };
  P.toFraction = function (md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
      x = this,
      xc = x.c;
    if (md != null) {
      n = new BigNumber(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error
          (bignumberError + 'Argument ' +
            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }
    if (!xc) return new BigNumber(x);
    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);
    n0.c[0] = 0;
    for (; ;)  {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function () {
    return +valueOf(this);
  };
  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function (b) {
    var str,
      n = this,
      s = n.s,
      e = n.e;
    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS
         ? toExponential(coeffToString(n.c), e)
         : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }
      if (s < 0 && n.c[0]) str = '-' + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = 'BigNumber';
  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
  if (configObject != null) BigNumber.set(configObject);
  return BigNumber;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z,
    i = 1,
    j = a.length,
    r = a[0] + '';
  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;
    for (; z--; s = '0' + s);
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48;);
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b,
    xc = x.c,
    yc = y.c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;
  if (!i || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b) return a ? b ? 0 : -j : i;
  if (i != j) return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error
     (bignumberError + (name || 'Argument') + (typeof n == 'number'
       ? n < min || n > max ? ' out of range: ' : ' not an integer: '
       : ' not a primitive number: ') + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
   (e < 0 ? 'e' : 'e+') + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + '.'; ++e; zs += z);
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone$2();

if (Array.prototype["distinct"] === undefined) {
    Object.defineProperty(Array.prototype, "distinct", {
        configurable: true,
        value: function distinct(selector = (element) => element) {
            return this.reduce((x, y) => x.find(yy => yy === selector(y)) !== undefined ? x : [...x, selector(y)], []);
        },
        writable: true
    });
}
if (Array.prototype["groupBy"] === undefined) {
    Object.defineProperty(Array.prototype, "groupBy", {
        configurable: true,
        value: function groupBy(selector) {
            const groups = this.reduce((r, e) => {
                const g = selector(e);
                (r[g] || (r[g] = [])).push(e);
                return r;
            }, {});
            return Object.keys(groups).map(key => ({ key: key, value: groups[key] }));
        },
        writable: true
    });
}
if (Array.prototype["orderBy"] === undefined) {
    Object.defineProperty(Array.prototype, "orderBy", {
        configurable: true,
        value: function orderBy(selectorOrString) {
            const selector = typeof selectorOrString === "string" ? (element) => element[selectorOrString] : selectorOrString;
            if (!this.length)
                return [];
            const first = selector(this[0]);
            if (typeof first === "number")
                return this.slice().sort((a, b) => selector(a) - selector(b));
            else if (typeof first === "string") {
                return this.slice().sort((a, b) => {
                    if (selector(a) < selector(b))
                        return -1;
                    else if (selector(a) > selector(b))
                        return 1;
                    return 0;
                });
            }
            throw "Invalid property type";
        },
        writable: true
    });
}
if (Array.prototype["orderByDescending"] === undefined) {
    Object.defineProperty(Array.prototype, "orderByDescending", {
        configurable: true,
        value: function orderByDescending(selectorOrString) {
            const selector = typeof selectorOrString === "string" ? (element) => element[selectorOrString] : selectorOrString;
            return this.slice().sort((a, b) => selector(b) - selector(a));
        },
        writable: true
    });
}
if (Array.prototype["min"] === undefined) {
    Object.defineProperty(Array.prototype, "min", {
        configurable: true,
        value: function min(selector) {
            if (!this.length)
                return Infinity;
            return this.slice(1).reduce((prev, element) => {
                const v = selector(element);
                return (prev < v ? prev : v);
            }, selector(this[0]));
        },
        writable: true
    });
}
if (Array.prototype["max"] === undefined) {
    Object.defineProperty(Array.prototype, "max", {
        configurable: true,
        value: function max(selector) {
            if (!this.length)
                return Infinity;
            return this.slice(1).reduce((prev, element) => {
                const v = selector(element);
                return (prev > v ? prev : v);
            }, selector(this[0]));
        },
        writable: true
    });
}
if (Array.prototype["sum"] === undefined) {
    Object.defineProperty(Array.prototype, "remove", {
        configurable: true,
        value: function remove(s) {
            let success = false;
            for (let index = this.length; index--;) {
                if (s == this[index]) {
                    this.splice(index, 1);
                    success = true;
                }
            }
            return success;
        },
        writable: true
    });
}
if (Array.prototype["sum"] === undefined) {
    Object.defineProperty(Array.prototype, "removeAll", {
        configurable: true,
        value: function removeAll(f, thisObject) {
            if (this.length > 0) {
                for (let index = this.length; index--;) {
                    if (f.call(thisObject, this[index], index, this))
                        this.splice(index, 1);
                }
            }
        },
        writable: true
    });
}
if (Array.prototype["sum"] === undefined) {
    Object.defineProperty(Array.prototype, "sum", {
        configurable: true,
        value: function sum(selector) {
            if (!this.length)
                return Infinity;
            return this.slice(1).reduce((prev, element) => prev + selector(element), selector(this[0]));
        },
        writable: true
    });
}
Array.range = function range(start, end, step = 1) {
    return Array.from({ length: end - start + 1 }, (_, k) => k * step + start);
};

class PathRoutes {
    constructor() {
        this.current = null;
        this.previous = null;
        this.root = null;
        this.rootPath = null;
        this.rescue = null;
        this.defined = {};
    }
}
class PathRoute {
    constructor(path) {
        this.path = path;
        this.do_enter = [];
        this.do_exit = [];
        this.params = {};
        Path.routes.defined[path] = this;
    }
    to(fn) {
        this.action = fn;
        return this;
    }
    enter(fns) {
        if (fns instanceof Array)
            this.do_enter = this.do_enter.concat(fns);
        else
            this.do_enter.push(fns);
        return this;
    }
    exit(fns) {
        if (fns instanceof Array)
            this.do_exit = this.do_exit.concat(fns);
        else
            this.do_exit.push(fns);
        return this;
    }
    partition() {
        const re = /\(([^}]+?)\)/g, parts = [], options = [];
        let text;
        while (text = re.exec(this.path))
            parts.push(text[1]);
        options.push(this.path.split("(")[0]);
        for (let i = 0; i < parts.length; i++)
            options.push(options[options.length - 1] + parts[i]);
        return options;
    }
    run() {
        let halt_execution = false, result;
        if (Path.routes.defined[this.path].hasOwnProperty("do_enter")) {
            if (Path.routes.defined[this.path].do_enter.length > 0) {
                for (let i = 0; i < Path.routes.defined[this.path].do_enter.length; i++) {
                    result = Path.routes.defined[this.path].do_enter[i].apply(this, null);
                    if (result === false) {
                        halt_execution = true;
                        break;
                    }
                }
            }
        }
        if (!halt_execution) {
            Path.routes.defined[this.path].action();
        }
    }
}
class PathHistory {
    constructor() {
        this.initial = {
            popped: false,
            URL: ""
        };
    }
    pushState(state, title, path) {
        Path.dispatch(path);
        history.pushState(state, title, this.noHistory ? undefined : path);
    }
    replaceState(state, title, path) {
        Path.dispatch(path);
        history.replaceState(state, title, this.noHistory ? undefined : path);
    }
    popState() {
        var initialPop = !Path.history.initial.popped && location.href == Path.history.initial.URL;
        Path.history.initial.popped = true;
        if (initialPop)
            return;
        Path.dispatch(Path.routes.rootPath ? document.location.href.substr(Path.routes.root.length).replace(document.location.hash, "") : document.location.hash);
    }
    listen() {
        this.initial.popped = ('state' in window.history), this.initial.URL = location.href;
        window.onpopstate = Path.history.popState;
    }
}
class Path {
    static map(path) {
        if (Path.routes.defined.hasOwnProperty(path)) {
            return Path.routes.defined[path];
        }
        else {
            return new PathRoute(path);
        }
    }
    static root(path) {
        Path.routes.root = path;
    }
    static rescue(fn) {
        Path.routes.rescue = fn;
    }
    static match(path, parameterize) {
        var matchedRoutes = [];
        let route, possible_routes, slice, compare;
        for (route in Path.routes.defined) {
            if (route !== null && route !== undefined) {
                route = Path.routes.defined[route];
                possible_routes = route.partition();
                for (let j = 0; j < possible_routes.length; j++) {
                    const params = {};
                    slice = possible_routes[j];
                    compare = path;
                    if (slice.search(/:/) > 0) {
                        var splittedSlice = slice.split(Path._splitRegex);
                        for (let i = 0; i < splittedSlice.length; i++) {
                            var splittedCompare = slice.search(/\*/) > 0 ? compare.splitWithTail(Path._splitRegex, splittedSlice.length) : compare.split(Path._splitRegex);
                            if ((i < splittedCompare.length) && (splittedSlice[i].charAt(0) === ":")) {
                                params[splittedSlice[i].replace(/:/, '').replace(/\*/, '')] = splittedCompare[i];
                                compare = compare.replace(new RegExp("(\\b|^|\\.|\\/)" + splittedCompare[i].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") + "(\\b|$|\\.|\\/)"), "$1" + splittedSlice[i] + "$2");
                            }
                        }
                    }
                    if (slice === compare) {
                        if (parameterize)
                            route.params = params;
                        matchedRoutes.push(route);
                    }
                }
            }
        }
        return matchedRoutes.length > 0 ? matchedRoutes.orderBy(function (r) { return r.params ? Object.keys(r.params).length : 0; })[0] : null;
    }
    static dispatch(passed_route) {
        Path.routes.current = passed_route;
        const matched_route = this.match(passed_route, true);
        if (matched_route !== null) {
            matched_route.run();
            return true;
        }
        else if (Path.routes.rescue !== null)
            Path.routes.rescue();
    }
}
Path.routes = new PathRoutes();
Path.history = new PathHistory();
Path._splitRegex = /\/|\./g;

class CultureInfo {
    constructor(name, numberFormat, dateFormat) {
        this.name = name;
        this.numberFormat = numberFormat;
        this.dateFormat = dateFormat;
    }
}
CultureInfo.cultures = {};
CultureInfo.cultures[""] = new CultureInfo("", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-Infinity", positiveInfinityText: "Infinity", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ".", percentGroupSeparator: ",", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "¤", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ".", currencyGroupSeparator: ",", currencyNegativePattern: "(${0})", currencyPositivePattern: "${0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ".", numberGroupSeparator: "," }, { amDesignator: "AM", pmDesignator: "PM", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd, dd MMMM yyyy HH:mm:ss", longDatePattern: "dddd, dd MMMM yyyy", shortDatePattern: "MM/dd/yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "yyyy MMMM", firstDayOfWeek: 0, dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], minimizedDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""], shortMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""] });
CultureInfo.cultures["de-DE"] = new CultureInfo("de-DE", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: ".", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: ".", currencyNegativePattern: "-{0} $", currencyPositivePattern: "{0} $", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: "." }, { amDesignator: "", pmDesignator: "", dateSeparator: ".", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd, d. MMMM yyyy HH:mm:ss", longDatePattern: "dddd, d. MMMM yyyy", shortDatePattern: "dd.MM.yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], shortDayNames: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"], minimizedDayNames: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"], monthNames: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""], shortMonthNames: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""] });
CultureInfo.cultures["en-GB"] = new CultureInfo("en-GB", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ".", percentGroupSeparator: ",", percentPositivePattern: "{0}%", percentNegativePattern: "-{0}%", currencySymbol: "£", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ".", currencyGroupSeparator: ",", currencyNegativePattern: "-${0}", currencyPositivePattern: "${0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ".", numberGroupSeparator: "," }, { amDesignator: "AM", pmDesignator: "PM", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dd MMMM yyyy HH:mm:ss", longDatePattern: "dd MMMM yyyy", shortDatePattern: "dd/MM/yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], minimizedDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""], shortMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""] });
CultureInfo.cultures["en-US"] = new CultureInfo("en-US", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ".", percentGroupSeparator: ",", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "$", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ".", currencyGroupSeparator: ",", currencyNegativePattern: "(${0})", currencyPositivePattern: "${0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ".", numberGroupSeparator: "," }, { amDesignator: "AM", pmDesignator: "PM", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd, MMMM d, yyyy h:mm:ss tt", longDatePattern: "dddd, MMMM d, yyyy", shortDatePattern: "MM/dd/yyyy", longTimePattern: "h:mm:ss tt", shortTimePattern: "h:mm tt", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 0, dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], minimizedDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""], shortMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""] });
CultureInfo.cultures["es-ES"] = new CultureInfo("es-ES", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: ".", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: ".", currencyNegativePattern: "-{0} $", currencyPositivePattern: "{0} $", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: "." }, { amDesignator: "", pmDesignator: "", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd, d' de 'MMMM' de 'yyyy H:mm:ss", longDatePattern: "dddd, d' de 'MMMM' de 'yyyy", shortDatePattern: "dd/MM/yyyy", longTimePattern: "H:mm:ss", shortTimePattern: "H:mm", yearMonthPattern: "MMMM' de 'yyyy", firstDayOfWeek: 1, dayNames: ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"], shortDayNames: ["do.", "lu.", "ma.", "mi.", "ju.", "vi.", "sá."], minimizedDayNames: ["D", "L", "M", "X", "J", "V", "S"], monthNames: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", ""], shortMonthNames: ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sep.", "oct.", "nov.", "dic.", ""] });
CultureInfo.cultures["fr-BE"] = new CultureInfo("fr-BE", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: ".", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: ".", currencyNegativePattern: "-{0} $", currencyPositivePattern: "{0} $", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: "." }, { amDesignator: "", pmDesignator: "", dateSeparator: "-", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd d MMMM yyyy HH:mm:ss", longDatePattern: "dddd d MMMM yyyy", shortDatePattern: "dd-MM-yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"], shortDayNames: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."], minimizedDayNames: ["di", "lu", "ma", "me", "je", "ve", "sa"], monthNames: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", ""], shortMonthNames: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", ""] });
CultureInfo.cultures["fr-FR"] = new CultureInfo("fr-FR", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: " ", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: " ", currencyNegativePattern: "-{0} $", currencyPositivePattern: "{0} $", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: " " }, { amDesignator: "", pmDesignator: "", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd d MMMM yyyy HH:mm:ss", longDatePattern: "dddd d MMMM yyyy", shortDatePattern: "dd/MM/yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"], shortDayNames: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."], minimizedDayNames: ["di", "lu", "ma", "me", "je", "ve", "sa"], monthNames: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", ""], shortMonthNames: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", ""] });
CultureInfo.cultures["it-IT"] = new CultureInfo("it-IT", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: ".", percentPositivePattern: "{0}%", percentNegativePattern: "-{0}%", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: ".", currencyNegativePattern: "-$ {0}", currencyPositivePattern: "$ {0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: "." }, { amDesignator: "", pmDesignator: "", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd d MMMM yyyy HH:mm:ss", longDatePattern: "dddd d MMMM yyyy", shortDatePattern: "dd/MM/yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["domenica", "lunedì", "martedì", "mercoledì", "giovedì", "venerdì", "sabato"], shortDayNames: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"], minimizedDayNames: ["do", "lu", "ma", "me", "gi", "ve", "sa"], monthNames: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre", ""], shortMonthNames: ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic", ""] });
CultureInfo.cultures["ja-JP"] = new CultureInfo("ja-JP", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ".", percentGroupSeparator: ",", percentPositivePattern: "{0}%", percentNegativePattern: "-{0}%", currencySymbol: "¥", currencyGroupSizes: [3], currencyDecimalDigits: 0, currencyDecimalSeparator: ".", currencyGroupSeparator: ",", currencyNegativePattern: "-${0}", currencyPositivePattern: "${0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ".", numberGroupSeparator: "," }, { amDesignator: "午前", pmDesignator: "午後", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "yyyy'年'M'月'd'日' H:mm:ss", longDatePattern: "yyyy'年'M'月'd'日'", shortDatePattern: "yyyy/MM/dd", longTimePattern: "H:mm:ss", shortTimePattern: "H:mm", yearMonthPattern: "yyyy'年'M'月'", firstDayOfWeek: 0, dayNames: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"], shortDayNames: ["日", "月", "火", "水", "木", "金", "土"], minimizedDayNames: ["日", "月", "火", "水", "木", "金", "土"], monthNames: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月", ""], shortMonthNames: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", ""] });
CultureInfo.cultures["nl-BE"] = new CultureInfo("nl-BE", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: " ", percentPositivePattern: "{0}%", percentNegativePattern: "-{0}%", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: ".", currencyNegativePattern: "$ -{0}", currencyPositivePattern: "$ {0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: " " }, { amDesignator: "", pmDesignator: "", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd d MMMM yyyy H:mm:ss", longDatePattern: "dddd d MMMM yyyy", shortDatePattern: "dd/MM/yyyy", longTimePattern: "H:mm:ss", shortTimePattern: "H:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"], shortDayNames: ["zo", "ma", "di", "wo", "do", "vr", "za"], minimizedDayNames: ["zo", "ma", "di", "wo", "do", "vr", "za"], monthNames: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december", ""], shortMonthNames: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec", ""] });
CultureInfo.cultures["nl-NL"] = new CultureInfo("nl-NL", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: ".", percentPositivePattern: "{0} %", percentNegativePattern: "-{0} %", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: ".", currencyNegativePattern: "$ -{0}", currencyPositivePattern: "$ {0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: "." }, { amDesignator: "", pmDesignator: "", dateSeparator: "-", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "dddd d MMMM yyyy HH:mm:ss", longDatePattern: "dddd d MMMM yyyy", shortDatePattern: "dd-MM-yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM yyyy", firstDayOfWeek: 1, dayNames: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"], shortDayNames: ["zo", "ma", "di", "wo", "do", "vr", "za"], minimizedDayNames: ["zo", "ma", "di", "wo", "do", "vr", "za"], monthNames: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december", ""], shortMonthNames: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec", ""] });
CultureInfo.cultures["pt-PT"] = new CultureInfo("pt-PT", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ",", percentGroupSeparator: " ", percentPositivePattern: "{0}%", percentNegativePattern: "-{0}%", currencySymbol: "€", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ",", currencyGroupSeparator: " ", currencyNegativePattern: "-{0} $", currencyPositivePattern: "{0} $", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ",", numberGroupSeparator: " " }, { amDesignator: "", pmDesignator: "", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "d' de 'MMMM' de 'yyyy HH:mm:ss", longDatePattern: "d' de 'MMMM' de 'yyyy", shortDatePattern: "dd/MM/yyyy", longTimePattern: "HH:mm:ss", shortTimePattern: "HH:mm", yearMonthPattern: "MMMM' de 'yyyy", firstDayOfWeek: 0, dayNames: ["domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado"], shortDayNames: ["dom", "seg", "ter", "qua", "qui", "sex", "sáb"], minimizedDayNames: ["D", "S", "T", "Q", "Q", "S", "S"], monthNames: ["janeiro", "fevereiro", "março", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro", ""], shortMonthNames: ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez", ""] });
CultureInfo.cultures["zh-CHS"] = new CultureInfo("zh-CHS", { naNSymbol: "NaN", negativeSign: "-", positiveSign: "+", negativeInfinityText: "-∞", positiveInfinityText: "∞", percentSymbol: "%", percentGroupSizes: [3], percentDecimalDigits: 2, percentDecimalSeparator: ".", percentGroupSeparator: ",", percentPositivePattern: "{0}%", percentNegativePattern: "-{0}%", currencySymbol: "¥", currencyGroupSizes: [3], currencyDecimalDigits: 2, currencyDecimalSeparator: ".", currencyGroupSeparator: ",", currencyNegativePattern: "$-{0}", currencyPositivePattern: "${0}", numberGroupSizes: [3], numberDecimalDigits: 2, numberDecimalSeparator: ".", numberGroupSeparator: "," }, { amDesignator: "上午", pmDesignator: "下午", dateSeparator: "/", timeSeparator: ":", gmtDateTimePattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'", universalDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'", sortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", dateTimePattern: "yyyy'年'M'月'd'日' H:mm:ss", longDatePattern: "yyyy'年'M'月'd'日'", shortDatePattern: "yyyy/MM/dd", longTimePattern: "H:mm:ss", shortTimePattern: "H:mm", yearMonthPattern: "yyyy'年'M'月'", firstDayOfWeek: 1, dayNames: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"], shortDayNames: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"], minimizedDayNames: ["日", "一", "二", "三", "四", "五", "六"], monthNames: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", ""], shortMonthNames: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月", ""] });
CultureInfo.currentCulture = CultureInfo.invariantCulture = CultureInfo.cultures[""];

BigNumber.prototype.format = Number.prototype.format = function Number$format(format) {
    if (format == null || (format.length == 0) || (format == 'i')) {
        format = 'G';
    }
    return _netFormat(this, format, false);
};
BigNumber.prototype.localeFormat = Number.prototype.localeFormat = function Number$localeFormat(format) {
    if (format == null || (format.length == 0) || (format == 'i')) {
        format = 'G';
    }
    return _netFormat(this, format, true);
};
BigNumber.prototype.toLocaleString = Number.prototype.toLocaleString = function () {
    return this.localeFormat();
};
function _commaFormat(number, groups, decimal, comma) {
    var decimalPart = null;
    var decimalIndex = number.indexOf(decimal);
    if (decimalIndex > 0) {
        decimalPart = number.substr(decimalIndex);
        number = number.substr(0, decimalIndex);
    }
    var negative = number.startsWith('-');
    if (negative) {
        number = number.substr(1);
    }
    var groupIndex = 0;
    var groupSize = groups[groupIndex];
    if (number.length < groupSize) {
        if (negative) {
            number = '-' + number;
        }
        return decimalPart ? number + decimalPart : number;
    }
    var index = number.length;
    var s = '';
    var done = false;
    while (!done) {
        var length = groupSize;
        var startIndex = index - length;
        if (startIndex < 0) {
            groupSize += startIndex;
            length += startIndex;
            startIndex = 0;
            done = true;
        }
        if (!length) {
            break;
        }
        var part = number.substr(startIndex, length);
        if (s.length) {
            s = part + comma + s;
        }
        else {
            s = part;
        }
        index -= length;
        if (groupIndex < groups.length - 1) {
            groupIndex++;
            groupSize = groups[groupIndex];
        }
    }
    if (negative) {
        s = '-' + s;
    }
    return decimalPart ? s + decimalPart : s;
}
function _netFormat(value, format, useLocale) {
    var nf = useLocale ? CultureInfo.currentCulture.numberFormat : CultureInfo.invariantCulture.numberFormat;
    var s = '';
    var precision = -1;
    if (format.length > 1) {
        precision = parseInt(format.substr(1), 10);
    }
    var fs = format.charAt(0);
    switch (fs) {
        case 'd':
        case 'D':
            s = parseInt(Math.abs(value).toString()).toString();
            if (precision != -1) {
                s = s.padLeft(precision, '0');
            }
            if (value < 0) {
                s = '-' + s;
            }
            break;
        case 'x':
        case 'X':
            s = parseInt(Math.abs(value).toString()).toString(16);
            if (fs == 'X') {
                s = s.toUpperCase();
            }
            if (precision != -1) {
                s = s.padLeft(precision, '0');
            }
            break;
        case 'e':
        case 'E':
            if (precision == -1) {
                s = value.toExponential();
            }
            else {
                s = value.toExponential(precision);
            }
            if (fs == 'E') {
                s = s.toUpperCase();
            }
            break;
        case 'f':
        case 'F':
        case 'n':
        case 'N':
            if (precision == -1) {
                precision = nf.numberDecimalDigits;
            }
            s = value.toFixed(precision).toString();
            if (precision && (nf.numberDecimalSeparator != '.')) {
                var idx = s.indexOf('.');
                s = s.substr(0, idx) + nf.numberDecimalSeparator + s.substr(idx + 1);
            }
            if ((fs == 'n') || (fs == 'N')) {
                s = _commaFormat(s, nf.numberGroupSizes, nf.numberDecimalSeparator, nf.numberGroupSeparator);
            }
            break;
        case 'c':
        case 'C':
            if (precision == -1) {
                precision = nf.currencyDecimalDigits;
            }
            s = Math.abs(value).toFixed(precision).toString();
            if (precision && (nf.currencyDecimalSeparator != '.')) {
                var i = s.indexOf('.');
                s = s.substr(0, i) + nf.currencyDecimalSeparator + s.substr(i + 1);
            }
            s = _commaFormat(s, nf.currencyGroupSizes, nf.currencyDecimalSeparator, nf.currencyGroupSeparator);
            if (value < 0) {
                s = String.format(nf.currencyNegativePattern, s);
            }
            else {
                s = String.format(nf.currencyPositivePattern, s);
            }
            if (nf.currencySymbol != "$")
                s = s.replace("$", nf.currencySymbol);
            break;
        case 'p':
        case 'P':
            if (precision == -1) {
                precision = nf.percentDecimalDigits;
            }
            s = (Math.abs(value) * 100.0).toFixed(precision).toString();
            if (precision && (nf.percentDecimalSeparator != '.')) {
                var index = s.indexOf('.');
                s = s.substr(0, index) + nf.percentDecimalSeparator + s.substr(index + 1);
            }
            s = _commaFormat(s, nf.percentGroupSizes, nf.percentDecimalSeparator, nf.percentGroupSeparator);
            if (value < 0) {
                s = String.format(nf.percentNegativePattern, s);
            }
            else {
                s = String.format(nf.percentPositivePattern, s);
            }
            break;
        case 'g':
        case 'G':
            if (precision == -1)
                precision = 10;
            if (Math.floor(value) == value)
                s = value.toString();
            else
                s = _netFormat(value, "F" + precision, useLocale).trimEnd('0');
            break;
    }
    return s;
}

Boolean.parse = function (value) {
    if (value == null)
        return null;
    switch (value.toLowerCase()) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            return null;
    }
};
var Boolean$1 = Boolean;

const _formatRE$1 = /'.*?[^\\]'|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z/g;
Date.prototype.format = function (format) {
    if (format == null || (format.length == 0) || (format == 'i')) {
        format = 'G';
    }
    else if (format == 'id') {
        return this.toDateString();
    }
    else if (format == 'it') {
        return this.toTimeString();
    }
    return this._netFormat(format, false);
};
Date.prototype.localeFormat = function (format, useDefault) {
    if (format == null || (format.length == 0) || (format == 'i')) {
        format = 'G';
    }
    else if (format == 'id') {
        return this.toLocaleDateString();
    }
    else if (format == 'it') {
        return this.toLocaleTimeString();
    }
    return this._netFormat(format, true);
};
Date.prototype["_netFormat"] = function (format, useLocale) {
    var dt = this;
    var dtf = useLocale ? CultureInfo.currentCulture.dateFormat : CultureInfo.invariantCulture.dateFormat;
    if (format.length == 1) {
        switch (format) {
            case 'f':
                format = dtf.longDatePattern + ' ' + dtf.shortTimePattern;
                break;
            case 'F':
                format = dtf.dateTimePattern;
                break;
            case 'd':
                format = dtf.shortDatePattern;
                break;
            case 'D':
                format = dtf.longDatePattern;
                break;
            case 't':
                format = dtf.shortTimePattern;
                break;
            case 'T':
                format = dtf.longTimePattern;
                break;
            case 'g':
                format = dtf.shortDatePattern + ' ' + dtf.shortTimePattern;
                break;
            case 'G':
                format = dtf.shortDatePattern + ' ' + dtf.longTimePattern;
                break;
            case 'R':
            case 'r':
                dtf = CultureInfo.invariantCulture.dateFormat;
                format = dtf.gmtDateTimePattern;
                break;
            case 'u':
                format = dtf.universalDateTimePattern;
                break;
            case 'U':
                format = dtf.dateTimePattern;
                dt = new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate(), dt.getUTCHours(), dt.getUTCMinutes(), dt.getUTCSeconds(), dt.getUTCMilliseconds());
                break;
            case 's':
                format = dtf.sortableDateTimePattern;
                break;
            case 'y':
            case 'Y':
                format = dtf.yearMonthPattern;
                break;
        }
    }
    if (format.charAt(0) == '%') {
        format = format.substr(1);
    }
    var re = _formatRE$1;
    var sb = '';
    re.lastIndex = 0;
    while (true) {
        var index = re.lastIndex;
        var match = re.exec(format);
        sb += format.slice(index, match ? match.index : format.length);
        if (!match) {
            break;
        }
        var fs = match[0];
        var part = fs;
        switch (fs) {
            case 'dddd':
                part = dtf.dayNames[dt.getDay()];
                break;
            case 'ddd':
                part = dtf.shortDayNames[dt.getDay()];
                break;
            case 'dd':
                part = ("00" + dt.getDate()).substr(-2);
                break;
            case 'd':
                part = dt.getDate();
                break;
            case 'MMMM':
                part = dtf.monthNames[dt.getMonth()];
                break;
            case 'MMM':
                part = dtf.shortMonthNames[dt.getMonth()];
                break;
            case 'MM':
                part = ("00" + (dt.getMonth() + 1)).substr(-2);
                break;
            case 'M':
                part = (dt.getMonth() + 1);
                break;
            case 'yyyy':
                part = dt.getFullYear();
                break;
            case 'yy':
                part = ("00" + (dt.getFullYear() % 100)).substr(-2);
                break;
            case 'y':
                part = (dt.getFullYear() % 100).toString();
                break;
            case 'h':
            case 'hh':
                part = (dt.getHours() % 12).toString();
                if (part === "0") {
                    part = '12';
                }
                else if (fs == 'hh') {
                    part = ("00" + part).substr(-2);
                }
                break;
            case 'HH':
                part = ("00" + dt.getHours()).substr(-2);
                break;
            case 'H':
                part = dt.getHours();
                break;
            case 'mm':
                part = ("00" + dt.getMinutes()).substr(-2);
                break;
            case 'm':
                part = dt.getMinutes();
                break;
            case 'ss':
                part = ("00" + dt.getSeconds()).substr(-2);
                break;
            case 's':
                part = dt.getSeconds();
                break;
            case 't':
            case 'tt':
                part = (dt.getHours() < 12) ? dtf.amDesignator : dtf.pmDesignator;
                if (fs == 't') {
                    part = part.charAt(0);
                }
                break;
            case 'fff':
                part = ("000" + dt.getMilliseconds()).substr(-3);
                break;
            case 'ff':
                part = ("000" + dt.getMilliseconds()).substr(-3).substr(0, 2);
                break;
            case 'f':
                part = ("000" + dt.getMilliseconds()).substr(-3).charAt(0);
                break;
            case 'z': {
                const offset = dt.getTimezoneOffset() / 60;
                part = ((offset >= 0) ? '-' : '+') + Math.floor(Math.abs(offset));
                break;
            }
            case 'zz':
            case 'zzz': {
                const offset = dt.getTimezoneOffset() / 60;
                part = ((offset >= 0) ? '-' : '+') + ("00" + Math.floor(Math.abs(offset))).substr(-2);
                if (fs == 'zzz') {
                    part += dtf.timeSeparator + ("00" + Math.abs(dt.getTimezoneOffset() % 60)).substr(-2);
                }
                break;
            }
            default:
                if (part.charAt(0) == '\'') {
                    part = part.substr(1, part.length - 2).replace(/\\'/g, '\'');
                }
                break;
        }
        sb += part;
    }
    return sb;
};
Date.prototype.toLocaleString = function () {
    return this.localeFormat();
};
Date.prototype.netType = function (value) {
    if (typeof (value) == "undefined")
        return this._netType || "DateTime";
    this._netType = value;
    return this;
};
Date.prototype.netOffset = function (value) {
    if (typeof (value) == "undefined")
        return this._netOffset || (this._netOffset = String.format("{0:d2}:{1:d2}", Math.round(this.getTimezoneOffset() / 60), Math.abs(this.getTimezoneOffset() % 60)));
    this._netOffset = value;
    return this;
};

class ExpressionParser {
    static get(expression) {
        if (!expression || !expression.trim())
            return this.alwaysTrue;
        expression = expression.replace(/ /g, "").toUpperCase();
        var result = this._cache[expression];
        if (result == null)
            return this._cache[expression] = ExpressionParser.parse(expression);
        return result;
    }
    static parse(expression) {
        var operands = this._operands;
        var parts = expression.split('X');
        if (parts.length > 1) {
            var result = null;
            for (var i = 0; i < parts.length; i++) {
                var part = parts[i];
                var newResult = this.get(part);
                if (result != null) {
                    var previousResult = result;
                    result = function (arg) { return previousResult(arg) && newResult(arg); };
                }
                else
                    result = newResult;
            }
            return result;
        }
        if (expression != parts[0])
            return this.get(parts[0]);
        for (var idx = 0; idx < operands.length; idx++) {
            var operand = operands[idx];
            var index = expression.indexOf(operand);
            if (index >= 0) {
                expression = expression.replace(operand, "");
                if (index > 0) {
                    if (operand.includes("<"))
                        return this.get(operand.replace("<", ">") + expression);
                    if (operand.includes(">"))
                        return this.get(operand.replace(">", "<") + expression);
                }
                var number = parseInt(expression, 10);
                if (!isNaN(number)) {
                    switch (operand) {
                        case "<":
                            return new Function("x", "return x < " + number + ";");
                        case "<=":
                            return new Function("x", "return x <= " + number + ";");
                        case ">":
                            return new Function("x", "return x > " + number + ";");
                        case ">=":
                            return new Function("x", "return x >= " + number + ";");
                        case "!=":
                            return new Function("x", "return x != " + number + ";");
                        default:
                            return new Function("x", "return x == " + number + ";");
                    }
                }
            }
        }
        return this.alwaysTrue;
    }
}
ExpressionParser.alwaysTrue = function () { return true; };
ExpressionParser._cache = {};
ExpressionParser._operands = ["<=", ">=", "<", ">", "!=", "="];

class PropertyChangedArgs {
    constructor(propertyName, newValue, oldValue) {
        this.propertyName = propertyName;
        this.newValue = newValue;
        this.oldValue = oldValue;
    }
}
class ArrayChangedArgs {
    constructor(arrayPropertyName, index, removedItems, addedItemCount) {
        this.arrayPropertyName = arrayPropertyName;
        this.index = index;
        this.removedItems = removedItems;
        this.addedItemCount = addedItemCount;
    }
}
class Subject {
    constructor(notifier) {
        this._observers = [];
        notifier.notify = (source, detail) => {
            for (const i in this._observers)
                this._observers[i](source, detail);
        };
    }
    attach(observer) {
        const id = this._observers.length;
        this._observers.push(observer);
        return this._detach.bind(this, id);
    }
    _detach(observerId) {
        delete this._observers[observerId];
    }
}
class Observable {
    constructor() {
        this.propertyChanged = new Subject(this._propertyChangedNotifier = {});
        this.arrayChanged = new Subject(this._arrayChangedNotifier = {});
    }
    notifyPropertyChanged(propertyName, newValue, oldValue) {
        this._propertyChangedNotifier.notify(this, new PropertyChangedArgs(propertyName, newValue, oldValue));
    }
    notifyArrayChanged(arrayPropertyName, index, removedItems = [], addedCount) {
        this._arrayChangedNotifier.notify(this, new ArrayChangedArgs(arrayPropertyName, index, removedItems, addedCount));
    }
}

class Queue {
    constructor(maxPendingPromises, maxQueuedPromises) {
        this.pendingPromises = 0;
        this.maxPendingPromises = typeof maxPendingPromises !== 'undefined' ? maxPendingPromises : Infinity;
        this.maxQueuedPromises = typeof maxQueuedPromises !== 'undefined' ? maxQueuedPromises : Infinity;
        this.queue = [];
    }
    add(promiseGenerator) {
        return new Promise((resolve, reject) => {
            if (this.queue.length >= this.maxQueuedPromises) {
                reject(new Error('Queue limit reached'));
                return;
            }
            this.queue.push({
                promiseGenerator: promiseGenerator,
                resolve: resolve,
                reject: reject
            });
            this._dequeue();
        });
    }
    _dequeue() {
        if (this.pendingPromises >= this.maxPendingPromises)
            return false;
        const item = this.queue.shift();
        if (!item)
            return false;
        this.pendingPromises++;
        item.promiseGenerator()
            .then(value => {
            this.pendingPromises--;
            this._dequeue();
            item.resolve(value);
        }, err => {
            this.pendingPromises--;
            this._dequeue();
            item.reject(err);
        });
        return true;
    }
    get pendingLength() {
        return this.pendingPromises;
    }
    get queueLength() {
        return this.queue.length;
    }
}

class ServiceBusImpl {
    constructor() {
        this._topics = {};
    }
    _getTopic(topic = "") {
        if (!this._topics[topic]) {
            const topicNotifier = {};
            this._topics[topic] = {
                notifier: topicNotifier,
                subject: new Subject(topicNotifier)
            };
        }
        return this._topics[topic];
    }
    send(senderOrMessage, messageOrDetail, detail) {
        let sender;
        let message;
        if (typeof senderOrMessage !== "string") {
            sender = senderOrMessage;
            message = messageOrDetail;
        }
        else {
            sender = null;
            message = senderOrMessage;
            detail = messageOrDetail;
        }
        const topicOrMessage = message.split(":", 2);
        const topic = this._getTopic(topicOrMessage.length > 1 ? topicOrMessage[0] : "");
        message = topicOrMessage.length === 1 ? topicOrMessage[0] : topicOrMessage[1];
        topic.notifier.notify(this, topic.lastMessage = {
            sender: sender,
            message: message,
            detail: detail
        });
    }
    subscribe(message, callback, receiveLast) {
        const topicOrMessage = message.split(":", 2);
        const topic = this._getTopic(topicOrMessage.length > 1 ? topicOrMessage[0] : "");
        message = topicOrMessage.length === 1 ? topicOrMessage[0] : topicOrMessage[1];
        const disposer = topic.subject.attach((_, detail) => {
            if (message === "*" || message === detail.message)
                callback(detail.sender, detail.message, detail.detail);
        });
        if (receiveLast && topic.lastMessage != null) {
            if (message === "*" || message === topic.lastMessage.message)
                callback(topic.lastMessage, topic.lastMessage.message, topic.lastMessage.detail);
        }
        return disposer;
    }
}
const ServiceBus = new ServiceBusImpl();

String.prototype.contains = function (it) {
    return this.indexOf(it) != -1;
};
String.prototype.padLeft = function (totalWidth, ch) {
    if (this.length < totalWidth) {
        return String.fromChar(ch || ' ', totalWidth - this.length) + this;
    }
    return this.substring(0, this.length);
};
String.prototype.padRight = function (totalWidth, ch) {
    if (this.length < totalWidth) {
        return this + String.fromChar(ch || ' ', totalWidth - this.length);
    }
    return this.substring(0, this.length);
};
const trimStart = String.prototype.trimStart;
String.prototype.trimStart = function (ch) {
    if (!ch || !this.length)
        return trimStart.apply(this);
    ch = ch || ' ';
    var i = 0;
    for (; this.charAt(i) == ch && i < this.length; i++)
        ;
    return this.substring(i);
};
const trimEnd = String.prototype.trimEnd;
String.prototype.trimEnd = function (ch) {
    if (!ch || !this.length)
        return trimEnd.apply(this);
    ch = ch ? ch : ' ';
    var i = this.length - 1;
    for (; i >= 0 && this.charAt(i) == ch; i--)
        ;
    return this.substring(0, i + 1);
};
String.prototype.insert = function (str, index) {
    var length = this.length;
    if (index == length) {
        return this.substring(0, index) + str;
    }
    return this.substring(0, index) + str + this.substring(index, length);
};
String.prototype.asDataUri = function () {
    if (/^iVBOR/.test(this))
        return "data:image/png;base64," + this;
    if (/^\/9j\//.test(this))
        return "data:image/jpeg;base64," + this;
    if (/^R0lGOD/.test(this))
        return "data:image/gif;base64," + this;
    if (/^Qk/.test(this))
        return "data:image/bmp;base64," + this;
    if (/^PD94/.test(this))
        return "data:image/svg+xml;base64," + this;
    return "";
};
String.prototype.toKebabCase = function () {
    if (!this || this === this.toLowerCase())
        return this;
    var _this = this;
    return Array.from(this).map(function (c, i) {
        var cLower = c.toLowerCase();
        if (c === cLower)
            return c;
        if (i === 0)
            return cLower;
        var cPrev = _this[i - 1];
        if (!/^[a-zA-Z]+$/.test(cPrev))
            return cLower;
        var cPrevLower = cPrev.toLowerCase();
        if (cPrev === cPrevLower)
            return "-" + cLower;
        if (i + 1 === _this.length)
            return cLower;
        var cNext = _this[i + 1];
        var cNextUpper = cNext.toUpperCase();
        if (cNext === cNextUpper)
            return cLower;
        return "-" + cLower;
    }).join("");
};
String.prototype.splitWithTail = function (separator, limit) {
    let pattern, startIndex, m;
    const parts = [];
    if (!limit)
        return this.split(separator);
    if (separator instanceof RegExp)
        pattern = new RegExp(separator.source, "g" + (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : ""));
    else
        pattern = new RegExp(separator.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"), "g");
    do {
        startIndex = pattern.lastIndex;
        if (m = pattern.exec(this)) {
            parts.push(this.substr(startIndex, m.index - startIndex));
        }
    } while (m && parts.length < limit - 1);
    parts.push(this.substr(pattern.lastIndex));
    return parts;
};
String.isNullOrEmpty = function (str) {
    return str == null || str.length == 0;
};
String.isNullOrWhiteSpace = function (str) {
    return str == null || !(/\S/.test(str));
};
const _formatRE = /(\{[^\}^\{]+\})/g;
const _format = function (format, values, useLocale) {
    return format.replace(_formatRE, function (m) {
        var index = parseInt(m.substr(1), 10);
        var value = values[index];
        if (value == null)
            return '';
        if (value.format) {
            var formatSpec = null;
            var formatIndex = m.indexOf(':');
            if (formatIndex > 0) {
                formatSpec = m.substring(formatIndex + 1, m.length - 1);
            }
            return useLocale ? value.localeFormat(formatSpec) : value.format(formatSpec);
        }
        else
            return useLocale ? (value.localeFormat ? value.localeFormat() : value.toLocaleString()) : value.toString();
    });
};
String.format = function (format, ...args) {
    return _format(format, args, true);
};
String.fromChar = function (ch, count) {
    var s = ch;
    for (var i = 1; i < count; i++) {
        s += ch;
    }
    return s;
};

function extend$2(target, ...sources) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        for (var key in source) {
            if (source.hasOwnProperty(key))
                target[key] = source[key];
        }
    });
    return target;
}

function noop$1() {
}

function sleep$1(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

class Language extends Observable {
    constructor(_language, _culture) {
        super();
        this._language = _language;
        this._culture = _culture;
    }
    get culture() {
        return this._culture;
    }
    get name() {
        return this._language.name;
    }
    get isDefault() {
        return this._language.isDefault;
    }
    get messages() {
        return this._language.messages;
    }
    set messages(value) {
        const oldMessages = this._language.messages;
        this.notifyPropertyChanged("messages", this._language.messages = value, oldMessages);
    }
}

class ServiceObject extends Observable {
    constructor(service) {
        super();
        this.service = service;
    }
    copyProperties(propertyNames, includeNullValues, result) {
        result = result || {};
        propertyNames.forEach(p => {
            const value = this[p];
            if (includeNullValues || (value != null && value !== false && (value !== 0 || p === "pageSize") && (!Array.isArray(value) || value.length > 0)))
                result[p] = value;
        });
        return result;
    }
}

class ActionGroup extends ServiceObject {
    constructor(service, definition) {
        super(service);
        this.service = service;
        this.definition = definition;
        this._actions = [];
        this._canExecute = false;
        this._isVisible = false;
    }
    addAction(action) {
        const index = this._actions.findIndex(a => a.action === action);
        if (index >= 0)
            return;
        this._actions.push({
            action: action,
            observer: action.propertyChanged.attach(this._actionPropertyChanged.bind(this))
        });
        this._setCanExecute(this.canExecute || action.canExecute);
        this._setIsVisible(this.isVisible || action.isVisible);
    }
    removeAction(action) {
        const index = this._actions.findIndex(a => a.action === action);
        if (index < 0)
            return;
        const gAction = this._actions.splice(index, 1)[0];
        gAction.observer();
    }
    get actions() {
        return this._actions.map(a => a.action);
    }
    get name() {
        return this.definition.name;
    }
    get displayName() {
        return this.definition.displayName;
    }
    get canExecute() {
        return this._canExecute;
    }
    _setCanExecute(val) {
        if (this._canExecute === val)
            return;
        this._canExecute = val;
        this.notifyPropertyChanged("canExecute", val, !val);
    }
    get isVisible() {
        return this._isVisible;
    }
    _setIsVisible(val) {
        if (this._isVisible === val)
            return;
        this._isVisible = val;
        this.notifyPropertyChanged("isVisible", val, !val);
    }
    get isPinned() {
        return this._actions[0] ? this._actions[0].action.isPinned : false;
    }
    get options() {
        return null;
    }
    _actionPropertyChanged(action, detail) {
        switch (detail.propertyName) {
            case "canExecute": {
                this._setCanExecute(this._actions.some(a => a.action.canExecute));
                break;
            }
            case "isVisible": {
                this._setIsVisible(this._actions.some(a => a.action.isVisible));
                break;
            }
        }
    }
}

class Action extends ServiceObject {
    constructor(service, definition, owner) {
        super(service);
        this.service = service;
        this.definition = definition;
        this.owner = owner;
        this._isVisible = true;
        this._parameters = {};
        this._options = [];
        this.dependentActions = [];
        this.displayName = definition.displayName;
        this.selectionRule = definition.selectionRule;
        this._isPinned = definition.isPinned;
        this._offset = definition.offset;
        if (owner["persistentObject"]) {
            this._targetType = "Query";
            this._query = owner;
            this._parent = this.query.parent;
            if (definition.name === "New" && this.query.persistentObject != null && !String.isNullOrEmpty(this.query.persistentObject.newOptions))
                this._setOptions(this.query.persistentObject.newOptions.split(";"));
            this.query.propertyChanged.attach((source, detail) => {
                if (detail.propertyName === "selectedItems") {
                    let options;
                    if (definition.name === "New" && this.query.persistentObject != null && !String.isNullOrEmpty(this.query.persistentObject.newOptions))
                        options = this.query.persistentObject.newOptions.split(";");
                    else
                        options = definition.options.slice();
                    const args = {
                        name: this.name,
                        isVisible: this.isVisible,
                        canExecute: this.selectionRule(detail.newValue ? detail.newValue.length : 0),
                        options: options
                    };
                    this.service.hooks.onSelectedItemsActions(this._query, detail.newValue, args);
                    this.canExecute = args.canExecute;
                    this._setOptions(args.options);
                }
            });
            this.canExecute = this.selectionRule(0);
        }
        else if (owner instanceof PersistentObject$1) {
            this._targetType = "PersistentObject";
            this._parent = owner;
            this.canExecute = true;
        }
        else
            throw "Invalid owner-type.";
        if (definition.options.length > 0)
            this._options = definition.options.slice();
    }
    get parent() {
        return this._parent;
    }
    get query() {
        return this._query;
    }
    get offset() {
        return this._offset;
    }
    set offset(value) {
        this._offset = value;
    }
    get name() {
        return this.definition.name;
    }
    get group() {
        return this._group;
    }
    get canExecute() {
        return this._canExecute && !this._block;
    }
    set canExecute(val) {
        if (this._canExecute === val)
            return;
        this._canExecute = val;
        this.notifyPropertyChanged("canExecute", val, !val);
    }
    set block(block) {
        const oldCanExecute = this.canExecute;
        this._block = block;
        if (this.canExecute !== oldCanExecute)
            this.notifyPropertyChanged("canExecute", this.canExecute, oldCanExecute);
    }
    get isVisible() {
        return this._isVisible;
    }
    set isVisible(val) {
        if (this._isVisible === val)
            return;
        this._isVisible = val;
        this.notifyPropertyChanged("isVisible", val, !val);
    }
    get isPinned() {
        return this._isPinned;
    }
    get options() {
        return this._options;
    }
    _setOptions(options) {
        if (this._options === options)
            return;
        const oldOptions = this._options;
        this.notifyPropertyChanged("options", this._options = options, oldOptions);
    }
    subscribe(handler) {
        if (!this._executeHandlers)
            this._executeHandlers = [];
        this._executeHandlers.push(handler);
        return () => this._executeHandlers.splice(this._executeHandlers.indexOf(handler), 1)[0];
    }
    async execute(options = {}) {
        if (!this.canExecute && !(options.selectedItems != null && this.selectionRule(options.selectedItems.length)))
            return null;
        try {
            let workHandlerResolve;
            let workHandlerReject;
            const workHandler = new Promise((resolve, reject) => {
                workHandlerResolve = resolve;
                workHandlerReject = reject;
            });
            if (this._executeHandlers && this._executeHandlers.length > 0) {
                for (let i = 0; i < this._executeHandlers.length; i++) {
                    if (this._executeHandlers[i](this, workHandler, options) === false) {
                        workHandlerResolve(null);
                        return workHandler;
                    }
                }
            }
            try {
                workHandlerResolve(await this._onExecute(options));
            }
            catch (e) {
                workHandlerReject(e);
            }
            return workHandler;
        }
        catch (e) {
            if (options.throwExceptions)
                throw e;
            else
                this.owner.setNotification(e);
        }
    }
    async _onExecute(options) {
        let { menuOption, parameters, selectedItems, skipOpen, noConfirmation } = options;
        if (this.definition.confirmation && (!noConfirmation) && !await this.service.hooks.onActionConfirmation(this, menuOption))
            return null;
        return this.owner.queueWork(async () => {
            parameters = this._getParameters(parameters, menuOption);
            if (selectedItems == null && this.query) {
                if (this.query.selectAll.allSelected) {
                    if (!this.query.selectAll.inverse)
                        selectedItems = [];
                    else
                        selectedItems = this.query.items.filter(i => !i.isSelected);
                }
                else
                    selectedItems = this.query.selectedItems;
                selectedItems = selectedItems.filter(i => !i.ignoreSelect);
            }
            let po = await this.service.executeAction(this._targetType + "." + this.definition.name, this.parent, this.query, selectedItems, parameters);
            if (po) {
                if (po.fullTypeName === "Vidyano.Notification") {
                    if (po.objectId != null && JSON.parse(po.objectId).dialog) {
                        this._setNotification();
                        this.service.hooks.onMessageDialog(po.notificationType, po.notification, false, this.service.hooks.service.getTranslatedMessage("OK"));
                    }
                    else {
                        if (this.query && this.definition.refreshQueryOnCompleted)
                            var notificationPO = po;
                        else
                            this._setNotification(po.notification, po.notificationType, po.notificationDuration);
                    }
                    po = null;
                }
                else if (po.fullTypeName === "Vidyano.RegisteredStream") {
                    this.service.getStream(po);
                }
                else if (po.fullTypeName === "Vidyano.AddReference") {
                    const query = po.queries[0];
                    query.parent = this.parent;
                    const selectedItems = await this.service.hooks.onSelectReference(query);
                    if (selectedItems && selectedItems.length > 0) {
                        try {
                            await this.service.executeAction("Query.AddReference", this.parent, query, selectedItems, { AddAction: this.name }, true);
                        }
                        catch (e) {
                            this._setNotification(e);
                        }
                        if (this.query)
                            this.query.search();
                    }
                }
                else if (this.parent != null && (po.fullTypeName === this.parent.fullTypeName || po.isNew === this.parent.isNew) && po.id === this.parent.id && po.objectId === this.parent.objectId) {
                    this.parent.refreshFromResult(po);
                }
                else {
                    po.ownerQuery = this.query;
                    po.ownerPersistentObject = this.parent;
                    if (!skipOpen)
                        this.service.hooks.onOpen(po, false, true);
                }
            }
            if (this.query != null && this.definition.refreshQueryOnCompleted) {
                this.query.search({ keepSelection: this.definition.keepSelectionOnRefresh }).then(() => {
                    if (notificationPO && !this.query.notification)
                        this._setNotification(notificationPO.notification, notificationPO.notificationType, notificationPO.notificationDuration);
                });
            }
            return po;
        });
    }
    _getParameters(parameters, option) {
        if (parameters == null)
            parameters = {};
        if (this._parameters != null)
            parameters = Object.assign({ ...this._parameters }, parameters);
        if (this.options != null && this.options.length > 0 && option >= 0) {
            parameters["MenuOption"] = option;
            parameters["MenuLabel"] = this.options[option];
        }
        else if (option != null)
            parameters["MenuOption"] = option;
        return parameters;
    }
    _onParentIsEditingChanged(isEditing) {
    }
    _onParentIsDirtyChanged(isDirty) {
    }
    _setNotification(notification = null, notificationType = "Error", notificationDuration) {
        (this.query || this.parent).setNotification(notification, notificationType, notificationDuration);
    }
    static get(service, name, owner) {
        let definition = service.actionDefinitions[name];
        if (definition == null) {
            definition = service.hooks.onActionDefinitionNotFound(name);
            if (definition == null)
                return null;
        }
        const hook = Actions[name];
        return service.hooks.onConstructAction(service, hook != null ? new hook(service, definition, owner) : new Action(service, definition, owner));
    }
    static addActions(service, owner, actions, actionNames) {
        if (actionNames == null || actionNames.length === 0)
            return;
        actionNames.forEach(actionName => {
            const action = Action.get(service, actionName, owner);
            if (!action)
                return;
            action.offset = actions.length;
            actions.push(action);
            Action.addActions(service, owner, actions, action.dependentActions);
        });
        const actionGroups = {};
        actions.forEach(action => {
            if (action.definition.groupDefinition) {
                if (!actionGroups[action.definition.groupDefinition.name])
                    actionGroups[action.definition.groupDefinition.name] = new ActionGroup(service, action.definition.groupDefinition);
                actionGroups[action.definition.groupDefinition.name].addAction(action);
                action._group = actionGroups[action.definition.groupDefinition.name];
            }
        });
    }
}
let Actions = {};

class ServiceObjectWithActions extends ServiceObject {
    constructor(service, _actionNames = [], _actionLabels) {
        super(service);
        this._actionNames = _actionNames;
        this._actionLabels = _actionLabels;
        this._isBusy = false;
        this.actions = [];
        this._queue = new Queue(1);
    }
    get isBusy() {
        return this._isBusy;
    }
    _setIsBusy(val) {
        if (this._isBusy === val)
            return;
        const oldIsBusy = this._isBusy;
        this.notifyPropertyChanged("isBusy", this._isBusy = val, oldIsBusy);
    }
    get notification() {
        return this._notification;
    }
    get notificationType() {
        return this._notificationType;
    }
    get notificationDuration() {
        return this._notificationDuration;
    }
    getAction(name) {
        return this.actions[name];
    }
    setNotification(notificationOrError = null, type = "Error", duration = null, skipShowNotification) {
        const notification = typeof notificationOrError === "string" || !notificationOrError ? notificationOrError : notificationOrError?.["message"];
        const oldNotificationDuration = this.notificationDuration;
        if (oldNotificationDuration !== duration)
            this.notifyPropertyChanged("notificationDuration", this._notificationDuration = duration, oldNotificationDuration);
        const oldNotificationType = this._notificationType;
        if (oldNotificationType !== type)
            this.notifyPropertyChanged("notificationType", this._notificationType = type, oldNotificationType);
        const oldNotification = this.notification;
        if (oldNotification !== notification)
            this.notifyPropertyChanged("notification", this._notification = notification, oldNotification);
        if (!skipShowNotification && this.notificationDuration) {
            this.service.hooks.onShowNotification(notification, type, duration);
            this.setNotification();
        }
    }
    queueWork(work, blockActions = true) {
        this._setIsBusy(true);
        return this._queue.add(async () => {
            if (blockActions)
                this._blockActions(true);
            try {
                const result = await work();
                this._setIsBusy(this._queue.queueLength > 0);
                if (blockActions)
                    this._blockActions(false);
                return result;
            }
            catch (e) {
                this._setIsBusy(this._queue.queueLength > 0);
                this._blockActions(false);
                throw e;
            }
        });
    }
    _initializeActions() {
        Action.addActions(this.service, this, this.actions, this._actionNames);
        this.actions.forEach(a => {
            this.actions[a.name] = a;
            if (this._actionLabels && this._actionLabels[a.name] != null)
                a.displayName = this._actionLabels[a.name];
        });
    }
    _blockActions(block) {
        this.actions.forEach(action => {
            action.block = block;
        });
    }
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var _PersistentObjectAttribute_input, _PersistentObjectAttribute_actions;
let PersistentObjectAttribute$1 = class PersistentObjectAttribute extends ServiceObject {
    constructor(service, attr, parent) {
        super(service);
        this.parent = parent;
        _PersistentObjectAttribute_input.set(this, void 0);
        _PersistentObjectAttribute_actions.set(this, void 0);
        this._shouldRefresh = false;
        this.id = attr.id;
        this._isSystem = !!attr.isSystem;
        this.name = attr.name;
        this.type = attr.type;
        this._label = attr.label;
        this._serviceValue = attr.value !== undefined ? attr.value : null;
        this._groupKey = attr.group;
        this._tabKey = attr.tab;
        this._isReadOnly = !!attr.isReadOnly;
        this._isRequired = !!attr.isRequired;
        this._isValueChanged = !!attr.isValueChanged;
        this._isSensitive = !!attr.isSensitive;
        this.offset = attr.offset || 0;
        this.toolTip = attr.toolTip;
        this._rules = attr.rules;
        this.validationError = attr.validationError || null;
        this.typeHints = attr.typeHints || {};
        this.disableSort = !!attr.disableSort;
        this.triggersRefresh = !!attr.triggersRefresh;
        this.column = attr.column;
        this.columnSpan = attr.columnSpan || 0;
        this.visibility = attr.visibility;
        this._tag = attr.tag;
        if (this.type !== "Reference")
            this._setOptions(attr.options);
        if (this.type === "BinaryFile") {
            const input = document?.createElement("input");
            input.type = "file";
            input.accept = this.getTypeHint("accept", null);
            __classPrivateFieldSet(this, _PersistentObjectAttribute_input, input, "f");
        }
        __classPrivateFieldSet(this, _PersistentObjectAttribute_actions, [], "f");
        Action.addActions(this.service, this.parent, __classPrivateFieldGet(this, _PersistentObjectAttribute_actions, "f"), attr.actions || []);
    }
    get label() {
        return this._label;
    }
    set label(label) {
        const oldLabel = this._label;
        if (oldLabel !== label)
            this.notifyPropertyChanged("label", this._label = label, oldLabel);
    }
    get groupKey() {
        return this._groupKey;
    }
    get group() {
        return this._group;
    }
    set group(group) {
        const oldGroup = this._group;
        this._group = group;
        this._groupKey = group ? group.key : null;
        this.notifyPropertyChanged("group", group, oldGroup);
    }
    get tabKey() {
        return this._tabKey;
    }
    get tab() {
        return this._tab;
    }
    set tab(tab) {
        const oldTab = this._tab;
        this._tab = tab;
        this._tabKey = tab ? tab.key : null;
        this.notifyPropertyChanged("tab", tab, oldTab);
    }
    get isSystem() {
        return this._isSystem;
    }
    get visibility() {
        return this._visibility;
    }
    set visibility(visibility) {
        if (this._visibility === visibility)
            return;
        const oldIsVisible = this._isVisible;
        const newIsVisible = visibility.indexOf("Always") >= 0 || visibility.indexOf(this.parent.isNew ? "New" : "Read") >= 0;
        if (newIsVisible !== oldIsVisible)
            this._isVisible = newIsVisible;
        const oldVisibility = this._visibility;
        this.notifyPropertyChanged("visibility", this._visibility = visibility, oldVisibility);
        if (newIsVisible !== oldIsVisible) {
            this.notifyPropertyChanged("isVisible", this._isVisible, oldIsVisible);
            if (typeof (oldVisibility) !== "undefined" && !this.parent.isBusy)
                this.parent.refreshTabsAndGroups(this);
        }
    }
    get isVisible() {
        return this._isVisible;
    }
    get validationError() {
        return this._validationError;
    }
    set validationError(error) {
        const oldValidationError = this._validationError;
        if (oldValidationError !== error)
            this.notifyPropertyChanged("validationError", this._validationError = error, oldValidationError);
    }
    get rules() {
        return this._rules;
    }
    _setRules(rules) {
        const oldRules = this._rules;
        if (oldRules !== rules)
            this.notifyPropertyChanged("rules", this._rules = rules, oldRules);
    }
    get isRequired() {
        return this._isRequired;
    }
    _setIsRequired(isRequired) {
        const oldIsRequired = this._isRequired;
        if (oldIsRequired !== isRequired)
            this.notifyPropertyChanged("isRequired", this._isRequired = isRequired, oldIsRequired);
    }
    get isReadOnly() {
        return this._isReadOnly;
    }
    _setIsReadOnly(isReadOnly) {
        const oldisReadOnly = this._isReadOnly;
        if (oldisReadOnly !== isReadOnly)
            this.notifyPropertyChanged("isReadOnly", this._isReadOnly = isReadOnly, oldisReadOnly);
    }
    get displayValue() {
        if (this._displayValueSource === this._serviceValue)
            return !String.isNullOrEmpty(this._displayValue) ? this._displayValue : "—";
        else
            this._displayValueSource = this._serviceValue;
        let format = this.getTypeHint("DisplayFormat", "{0}");
        let value = this.value;
        if (value != null && (this.type === "Boolean" || this.type === "NullableBoolean" || this.type === "YesNo"))
            value = this.service.getTranslatedMessage(value ? this.getTypeHint("TrueKey", "Yes") : this.getTypeHint("FalseKey", "No"));
        else if (this.type === "KeyValueList") {
            if (this.options && this.options.length > 0) {
                const isEmpty = String.isNullOrEmpty(value);
                let option = this.options.find(o => o.key === value || (isEmpty && String.isNullOrEmpty(o.key)));
                if (this.isRequired && option == null)
                    option = this.options.find(o => String.isNullOrEmpty(o.key));
                if (option != null)
                    value = option.value;
                else if (this.isRequired)
                    value = this.options.length > 0 ? this.options[0].value : null;
            }
        }
        else if (value != null && (this.type === "Time" || this.type === "NullableTime")) {
            value = value.trimEnd("0").trimEnd(".");
            if (value.startsWith("0:"))
                value = value.substr(2);
            if (value.endsWith(":00"))
                value = value.substr(0, value.length - 3);
        }
        else if (value != null && (this.type === "User" || this.type === "NullableUser") && this.options.length > 0)
            value = this.options[0];
        else {
            const calculated = this.service.hooks.onGetAttributeDisplayValue(this, value);
            if (typeof calculated !== "undefined")
                return (this._displayValue = calculated);
        }
        if (format === "{0}") {
            if (this.type === "Date" || this.type === "NullableDate")
                format = "{0:" + CultureInfo.currentCulture.dateFormat.shortDatePattern + "}";
            else if (this.type === "DateTime" || this.type === "NullableDateTime")
                format = "{0:" + CultureInfo.currentCulture.dateFormat.shortDatePattern + " " + CultureInfo.currentCulture.dateFormat.shortTimePattern + "}";
        }
        return !String.isNullOrEmpty(this._displayValue = value != null ? String.format(format, value) : null) ? this._displayValue : "—";
    }
    get shouldRefresh() {
        return this._shouldRefresh;
    }
    get value() {
        if (this._lastParsedValue !== this._serviceValue) {
            this._lastParsedValue = this._serviceValue;
            if (!this.parent.isBulkEdit || !!this._serviceValue)
                this._cachedValue = Service.fromServiceString(this._serviceValue, this.type);
            else
                this._cachedValue = null;
        }
        return this._cachedValue;
    }
    set value(val) {
        this.setValue(val).catch(() => { });
    }
    async setValue(val, allowRefresh = true) {
        if (!this.parent.isEditing || this.parent.isFrozen || this.isReadOnly)
            return this.value;
        this.validationError = null;
        if (val && typeof val === "string") {
            const charactercasing = this.getTypeHint("charactercasing", "", undefined, true);
            if (charactercasing) {
                if (charactercasing.toUpperCase() === "LOWER")
                    val = val.toLowerCase();
                else if (charactercasing.toUpperCase() === "UPPER")
                    val = val.toUpperCase();
            }
        }
        const newServiceValue = Service.toServiceString(val, this.type);
        if (this._cachedValue === val || (this._serviceValue == null && String.isNullOrEmpty(newServiceValue)) || this._serviceValue === newServiceValue) {
            if (allowRefresh && this._shouldRefresh)
                await this._triggerAttributeRefresh();
        }
        else {
            const oldDisplayValue = this.displayValue;
            const oldServiceValue = this._serviceValue;
            this.notifyPropertyChanged("value", this._serviceValue = newServiceValue, oldServiceValue);
            this.isValueChanged = true;
            const newDisplayValue = this.displayValue;
            if (oldDisplayValue !== newDisplayValue)
                this.notifyPropertyChanged("displayValue", newDisplayValue, oldDisplayValue);
            if (this.triggersRefresh) {
                if (allowRefresh)
                    await this._triggerAttributeRefresh();
                else
                    this._shouldRefresh = true;
            }
            this.parent.triggerDirty();
        }
        return this.value;
    }
    get isValueChanged() {
        return this._isValueChanged;
    }
    set isValueChanged(isValueChanged) {
        if (isValueChanged === this._isValueChanged)
            return;
        const oldIsValueChanged = this._isValueChanged;
        this.notifyPropertyChanged("isValueChanged", this._isValueChanged = isValueChanged, oldIsValueChanged);
    }
    get isSensitive() {
        return this._isSensitive;
    }
    get input() {
        return __classPrivateFieldGet(this, _PersistentObjectAttribute_input, "f");
    }
    get actions() {
        return __classPrivateFieldGet(this, _PersistentObjectAttribute_actions, "f");
    }
    _setActions(actions) {
        const oldActions = __classPrivateFieldGet(this, _PersistentObjectAttribute_actions, "f");
        this.notifyPropertyChanged("actions", __classPrivateFieldSet(this, _PersistentObjectAttribute_actions, actions, "f"), oldActions);
    }
    get tag() {
        return this._tag;
    }
    getTypeHint(name, defaultValue, typeHints, ignoreCasing) {
        if (typeHints != null) {
            if (this.typeHints != null)
                typeHints = Object.assign({ ...this.typeHints }, typeHints);
        }
        else
            typeHints = this.typeHints;
        if (typeHints != null) {
            const typeHint = typeHints[ignoreCasing ? name : name.toLowerCase()];
            if (typeHint != null)
                return typeHint;
        }
        return defaultValue;
    }
    _toServiceObject() {
        const result = this.copyProperties(["id", "name", "label", "type", "isReadOnly", "triggersRefresh", "isRequired", "differsInBulkEditMode", "isValueChanged", "displayAttribute", "objectId", "visibility"]);
        result.value = this._serviceValue;
        result.actions = this.actions.map(a => a.name);
        if (this.options && this.options.length > 0 && this.isValueChanged)
            result.options = this.options.map(o => o ? (typeof (o) !== "string" ? o.key + "=" + o.value : o) : null);
        else
            result.options = this._serviceOptions;
        return result;
    }
    _refreshFromResult(resultAttr, resultWins) {
        let visibilityChanged = false;
        this.label = resultAttr.label;
        this._setActions(resultAttr.actions);
        this._setOptions(resultAttr._serviceOptions);
        this._setIsReadOnly(resultAttr.isReadOnly);
        this._setRules(resultAttr.rules);
        this._setIsRequired(resultAttr.isRequired);
        if (this.visibility !== resultAttr.visibility) {
            this.visibility = resultAttr.visibility;
            visibilityChanged = true;
        }
        if (resultWins || (this._serviceValue !== resultAttr._serviceValue && (this.isReadOnly || this._refreshServiceValue !== resultAttr._serviceValue))) {
            const oldDisplayValue = this.displayValue;
            const oldValue = this.value;
            this._serviceValue = resultAttr._serviceValue;
            this._lastParsedValue = undefined;
            this.notifyPropertyChanged("value", this.value, oldValue);
            this.notifyPropertyChanged("displayValue", this.displayValue, oldDisplayValue);
            if (__classPrivateFieldGet(this, _PersistentObjectAttribute_input, "f"))
                __classPrivateFieldGet(this, _PersistentObjectAttribute_input, "f").value = null;
            this.isValueChanged = resultAttr.isValueChanged;
        }
        this._tag = resultAttr._tag;
        this._refreshServiceValue = undefined;
        this.triggersRefresh = resultAttr.triggersRefresh;
        this.validationError = resultAttr.validationError || null;
        if (resultAttr.typeHints && Object.keys(resultAttr.typeHints).some(k => resultAttr.typeHints[k] !== this.typeHints[k])) {
            for (let name in this.typeHints) {
                if (resultAttr.typeHints[name] != null)
                    continue;
                resultAttr.typeHints[name] = this.typeHints[name];
            }
            const oldTypeHints = this.typeHints;
            this.notifyPropertyChanged("typeHints", this.typeHints = resultAttr.typeHints, oldTypeHints);
        }
        return visibilityChanged;
    }
    _triggerAttributeRefresh(immediate) {
        this._shouldRefresh = false;
        return this.parent._triggerAttributeRefresh(this, immediate);
    }
    _setOptions(options) {
        const oldOptions = this.options ? this.options.slice() : undefined;
        if (!options || options.length === 0) {
            this.options = this._serviceOptions = options;
            if (oldOptions && oldOptions.length > 0)
                this.notifyPropertyChanged("options", this.options, oldOptions);
            return;
        }
        this._serviceOptions = options.slice(0);
        const keyValuePairOptionType = ["FlagsEnum", "KeyValueList"].indexOf(this.type) !== -1 || (this.type === "Reference" && this.selectInPlace);
        if (!keyValuePairOptionType)
            this.options = options;
        else {
            this.options = options.map(o => {
                const optionSplit = o.splitWithTail("=", 2);
                return {
                    key: optionSplit[0],
                    value: optionSplit[1]
                };
            });
        }
        this.notifyPropertyChanged("options", this.options, oldOptions);
    }
};
_PersistentObjectAttribute_input = new WeakMap(), _PersistentObjectAttribute_actions = new WeakMap();

let PersistentObjectTab$1 = class PersistentObjectTab extends Observable {
    constructor(service, name, label, target, parent, _isVisible = true) {
        super();
        this.service = service;
        this.name = name;
        this.label = label;
        this.target = target;
        this.parent = parent;
        this._isVisible = _isVisible;
    }
    get isVisible() {
        return this._isVisible;
    }
    set isVisible(val) {
        const oldIsVisible = this._isVisible;
        if (oldIsVisible !== val)
            this.notifyPropertyChanged("isVisible", this._isVisible = val, oldIsVisible);
    }
};
class PersistentObjectAttributeTab extends PersistentObjectTab$1 {
    constructor(service, _groups, key, id, name, _layout, po, columnCount, isVisible) {
        super(service, name, String.isNullOrEmpty(key) ? po.label : key, po, po, isVisible);
        this._groups = _groups;
        this.key = key;
        this.id = id;
        this._layout = _layout;
        this.columnCount = columnCount;
        this.tabGroupIndex = 0;
        if (typeof columnCount === "string")
            this.columnCount = parseInt(columnCount);
        this._attributes = this._updateAttributes();
    }
    get isVisible() {
        return !this.parent.isHidden && super.isVisible;
    }
    set isVisible(val) {
        super.isVisible = val;
    }
    get layout() {
        return this._layout;
    }
    _setLayout(layout) {
        const oldLayout = this._layout;
        this.notifyPropertyChanged("layout", this._layout = layout, oldLayout);
    }
    get attributes() {
        return this._attributes;
    }
    get groups() {
        return this._groups;
    }
    set groups(groups) {
        const oldGroups = this._groups;
        this.notifyPropertyChanged("groups", this._groups = groups, oldGroups);
        const oldAttributes = this._attributes;
        this.notifyPropertyChanged("attributes", this._attributes = this._updateAttributes(), oldAttributes);
    }
    async saveLayout(layout) {
        await this.service.executeAction("System.SaveTabLayout", null, null, null, { "Id": this.id, "Layout": layout ? JSON.stringify(layout) : "" });
        this._setLayout(layout);
    }
    _updateAttributes() {
        const attributes = [].concat(...this.groups.map(grp => grp.attributes));
        attributes.forEach(attr => attributes[attr.name] = attr);
        this.isVisible = attributes.some(attr => attr.isVisible);
        return attributes;
    }
}
class PersistentObjectQueryTab extends PersistentObjectTab$1 {
    constructor(service, query) {
        super(service, query.name, query.label, query, query.parent, !query.isHidden);
        this.query = query;
        this.tabGroupIndex = 1;
    }
    get isVisible() {
        return !this.query.isHidden;
    }
}

class PersistentObjectAttributeWithReference extends PersistentObjectAttribute$1 {
    constructor(service, attr, parent) {
        super(service, attr, parent);
        this.parent = parent;
        if (attr.lookup) {
            this.lookup = this.service.hooks.onConstructQuery(service, attr.lookup, parent, false, 1);
            this.lookup.ownerAttributeWithReference = this;
        }
        else
            this.lookup = null;
        this.objectId = typeof attr.objectId === "undefined" ? null : attr.objectId;
        this.displayAttribute = attr.displayAttribute;
        this.canAddNewReference = !!attr.canAddNewReference;
        this.selectInPlace = !!attr.selectInPlace;
        this._setOptions(attr.options);
    }
    async addNewReference() {
        if (this.isReadOnly)
            return;
        try {
            const po = await this.service.executeAction("Query.New", this.parent, this.lookup, null, { PersistentObjectAttributeId: this.id });
            po.ownerAttributeWithReference = this;
            po.stateBehavior = (po.stateBehavior || "") + " OpenAsDialog";
            this.service.hooks.onOpen(po, false);
        }
        catch (e) {
            this.parent.setNotification(e);
        }
    }
    changeReference(selectedItems) {
        return this.parent.queueWork(async () => {
            if (this.isReadOnly)
                throw "Attribute is read-only.";
            this.parent._prepareAttributesForRefresh(this);
            if (selectedItems.length && selectedItems.length > 0 && typeof selectedItems[0] === "string") {
                const selectedObjectIds = selectedItems;
                selectedItems = selectedObjectIds.map(id => this.service.hooks.onConstructQueryResultItem(this.service, { id: id }, null));
            }
            const result = await this.service.executeAction("PersistentObject.SelectReference", this.parent, this.lookup, selectedItems, { PersistentObjectAttributeId: this.id });
            if (result)
                this.parent.refreshFromResult(result);
            return true;
        });
    }
    getPersistentObject() {
        if (!this.objectId)
            return Promise.resolve(null);
        return this.parent.queueWork(() => this.service.getPersistentObject(this.parent, this.lookup.persistentObject.id, this.objectId));
    }
    _refreshFromResult(resultAttr, resultWins) {
        const resultAttrWithRef = resultAttr;
        if (resultWins || this.objectId !== resultAttrWithRef.objectId) {
            this.objectId = resultAttrWithRef.objectId;
            this.isValueChanged = resultAttr.isValueChanged;
        }
        const visibilityChanged = super._refreshFromResult(resultAttr, resultWins);
        this.displayAttribute = resultAttrWithRef.displayAttribute;
        this.canAddNewReference = resultAttrWithRef.canAddNewReference;
        this.selectInPlace = resultAttrWithRef.selectInPlace;
        return visibilityChanged;
    }
}

var PersistentObjectLayoutMode;
(function (PersistentObjectLayoutMode) {
    PersistentObjectLayoutMode[PersistentObjectLayoutMode["FullPage"] = 0] = "FullPage";
    PersistentObjectLayoutMode[PersistentObjectLayoutMode["MasterDetail"] = 1] = "MasterDetail";
})(PersistentObjectLayoutMode || (PersistentObjectLayoutMode = {}));
let PersistentObject$1 = class PersistentObject extends ServiceObjectWithActions {
    constructor(service, po) {
        super(service, (po._actionNames || po.actions || []).map(a => a === "Edit" && po.isNew ? "Save" : a), po.actionLabels);
        this._isEditing = false;
        this._isDirty = false;
        this._isFrozen = false;
        this.queriesToRefresh = [];
        this._id = po.id;
        this._isSystem = !!po.isSystem;
        this._type = po.type;
        this.label = po.label;
        this.forceFromAction = po.forceFromAction;
        this.fullTypeName = po.fullTypeName;
        this.queryLayoutMode = po.queryLayoutMode === "FullPage" ? PersistentObjectLayoutMode.FullPage : PersistentObjectLayoutMode.MasterDetail;
        this.objectId = po.objectId;
        this._breadcrumb = po.breadcrumb;
        this.isBreadcrumbSensitive = po.isBreadcrumbSensitive;
        this.setNotification(po.notification, po.notificationType, po.notificationDuration, true);
        this.isNew = !!po.isNew;
        this.newOptions = po.newOptions;
        this.isReadOnly = !!po.isReadOnly;
        this.isHidden = !!po.isHidden;
        this._isDeleted = !!po.isDeleted;
        this.ignoreCheckRules = !!po.ignoreCheckRules;
        this.stateBehavior = po.stateBehavior || "None";
        this.setIsEditing(false);
        this.securityToken = po.securityToken;
        this.bulkObjectIds = po.bulkObjectIds;
        this.queriesToRefresh = po.queriesToRefresh || [];
        this.parent = po.parent != null ? service.hooks.onConstructPersistentObject(service, po.parent) : null;
        this.attributes = po.attributes ? po.attributes.map(attr => this._createPersistentObjectAttribute(attr)) : [];
        this.attributes.forEach(attr => this.attributes[attr.name] = attr);
        this.queries = po.queries ? po.queries.map(query => service.hooks.onConstructQuery(service, query, this)).orderBy(q => q.offset) : [];
        this.queries.forEach(query => this.queries[query.name] = query);
        const attributeTabs = po.tabs ? this.attributes.orderBy(attr => attr.offset).groupBy(attr => attr.tabKey).map(attributesByTab => {
            const groups = attributesByTab.value.orderBy(attr => attr.offset).groupBy(attr => attr.groupKey).map(attributesByGroup => {
                const newGroup = this.service.hooks.onConstructPersistentObjectAttributeGroup(service, attributesByGroup.key, attributesByGroup.value, this);
                attributesByGroup.value.forEach(attr => attr.group = newGroup);
                return newGroup;
            });
            groups.forEach((g, n) => g.index = n);
            const serviceTab = po.tabs[attributesByTab.key] || {};
            const newTab = this.service.hooks.onConstructPersistentObjectAttributeTab(service, groups, attributesByTab.key, serviceTab.id, serviceTab.name, serviceTab.layout, this, serviceTab.columnCount, !this.isHidden);
            attributesByTab.value.forEach(attr => attr.tab = newTab);
            return newTab;
        }) : [];
        this._tabs = this.service.hooks.onSortPersistentObjectTabs(this, attributeTabs, this.queries.map(q => this.service.hooks.onConstructPersistentObjectQueryTab(this.service, q)));
        if (this._tabs.length === 0)
            this._tabs = [this.service.hooks.onConstructPersistentObjectAttributeTab(service, [], "", "", "", null, this, 0, true)];
        this._tag = po.tag;
        this._lastResult = po;
        if (this.isNew || this.stateBehavior === "OpenInEdit" || this.stateBehavior.indexOf("OpenInEdit") >= 0 || this.stateBehavior === "StayInEdit" || this.stateBehavior.indexOf("StayInEdit") >= 0)
            this.beginEdit();
        this._initializeActions();
        this.dialogSaveAction = po.dialogSaveAction ? this.getAction(po.dialogSaveAction) : (this.getAction("EndEdit") || this.getAction("Save"));
        this.service.hooks.onRefreshFromResult(this);
        this._setLastUpdated(new Date());
    }
    _createPersistentObjectAttribute(attr) {
        if (attr.displayAttribute || attr.objectId)
            return this.service.hooks.onConstructPersistentObjectAttributeWithReference(this.service, attr, this);
        if (attr.objects || attr.details)
            return this.service.hooks.onConstructPersistentObjectAttributeAsDetail(this.service, attr, this);
        return this.service.hooks.onConstructPersistentObjectAttribute(this.service, attr, this);
    }
    get id() {
        return this._id;
    }
    get isSystem() {
        return this._isSystem;
    }
    get type() {
        return this._type;
    }
    get isBulkEdit() {
        return this.bulkObjectIds && this.bulkObjectIds.length > 0;
    }
    get tabs() {
        return this._tabs;
    }
    set tabs(tabs) {
        const oldTabs = this._tabs;
        this.notifyPropertyChanged("tabs", this._tabs = tabs, oldTabs);
    }
    get tag() {
        return this._tag;
    }
    get isEditing() {
        return this._isEditing;
    }
    setIsEditing(value) {
        this._isEditing = value;
        this.actions.forEach(action => action._onParentIsEditingChanged(value));
        this.notifyPropertyChanged("isEditing", value, !value);
    }
    get breadcrumb() {
        return this._breadcrumb;
    }
    _setBreadcrumb(breadcrumb) {
        const oldBreadcrumb = this._breadcrumb;
        if (oldBreadcrumb !== breadcrumb)
            this.notifyPropertyChanged("breadcrumb", this._breadcrumb = breadcrumb, oldBreadcrumb);
    }
    get isDirty() {
        return this._isDirty;
    }
    _setIsDirty(value, force) {
        if (value && (!this.isEditing && !force))
            throw "Cannot flag persistent object as dirty when not in edit mode.";
        const oldIsDirty = this._isDirty;
        if (oldIsDirty !== value) {
            this.notifyPropertyChanged("isDirty", this._isDirty = value, oldIsDirty);
            this.actions.forEach(action => action._onParentIsDirtyChanged(value));
            if (this.ownerDetailAttribute && value)
                this.ownerDetailAttribute.onChanged(false);
        }
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(isDeleted) {
        const oldIsDeleted = this._isDeleted;
        if (oldIsDeleted !== isDeleted)
            this.notifyPropertyChanged("isDeleted", this._isDeleted = isDeleted, oldIsDeleted);
    }
    get isFrozen() {
        return this._isFrozen;
    }
    freeze() {
        if (this._isFrozen)
            return;
        this.notifyPropertyChanged("isFrozen", this._isFrozen = true, false);
    }
    unfreeze() {
        if (!this._isFrozen)
            return;
        this.notifyPropertyChanged("isFrozen", this._isFrozen = false, true);
    }
    getAttribute(name) {
        return this.attributes[name];
    }
    getAttributeValue(name) {
        const attr = this.attributes[name];
        return attr != null ? attr.value : null;
    }
    setAttributeValue(name, value, allowRefresh) {
        const attr = this.attributes[name];
        if (!attr)
            return Promise.reject("Attribute does not exist.");
        return attr.setValue(value, allowRefresh);
    }
    get lastUpdated() {
        return this._lastUpdated;
    }
    _setLastUpdated(lastUpdated) {
        const oldLastUpdated = this._lastUpdated;
        this.notifyPropertyChanged("lastUpdated", this._lastUpdated = lastUpdated, oldLastUpdated);
    }
    getQuery(name) {
        return this.queries[name];
    }
    beginEdit() {
        if (!this.isEditing) {
            this._lastResultBackup = this._lastResult;
            this.setIsEditing(true);
        }
    }
    cancelEdit() {
        if (this.isEditing) {
            this.setIsEditing(false);
            this._setIsDirty(false);
            const backup = this._lastResultBackup;
            this._lastResultBackup = null;
            this.refreshFromResult(backup, true);
            if (!!this.notification)
                this.setNotification();
            if (this.stateBehavior === "StayInEdit" || this.stateBehavior.indexOf("StayInEdit") >= 0)
                this.beginEdit();
        }
    }
    save(waitForOwnerQuery) {
        return this.queueWork(async () => {
            if (this.isEditing) {
                const attributesToRefresh = this.attributes.filter(attr => attr.shouldRefresh);
                for (let i = 0; i < attributesToRefresh.length; i++)
                    await attributesToRefresh[i]._triggerAttributeRefresh(true);
                const po = await this.service.executeAction("PersistentObject.Save", this, null, null, null);
                if (!po)
                    return false;
                const wasNew = this.isNew;
                this.refreshFromResult(po, true);
                if (!this.notification || this.notification.trim().length === 0 || this.notificationType !== "Error") {
                    this._setIsDirty(false);
                    if (!wasNew) {
                        this.setIsEditing(false);
                        if (this.stateBehavior === "StayInEdit" || this.stateBehavior.indexOf("StayInEdit") >= 0)
                            this.beginEdit();
                    }
                    if (this.ownerAttributeWithReference) {
                        if (this.ownerAttributeWithReference.objectId !== this.objectId) {
                            let parent = this.ownerAttributeWithReference.parent;
                            if (parent.ownerDetailAttribute != null)
                                parent = parent.ownerDetailAttribute.parent;
                            parent.beginEdit();
                            this.ownerAttributeWithReference.changeReference([po.objectId]);
                        }
                        else if (this.ownerAttributeWithReference.value !== this.breadcrumb)
                            this.ownerAttributeWithReference.value = this.breadcrumb;
                    }
                    else if (this.ownerQuery)
                        this.ownerQuery.search({ keepSelection: this.isBulkEdit });
                }
                else if (!!this.notification && this.notification.trim().length > 0)
                    throw this.notification;
            }
            return true;
        });
    }
    toServiceObject(skipParent = false) {
        const result = this.copyProperties(["id", "type", "objectId", "isNew", "isHidden", "bulkObjectIds", "securityToken", "isSystem"]);
        if (this.ownerQuery)
            result.ownerQueryId = this.ownerQuery.id;
        if (this.parent && !skipParent)
            result.parent = this.parent.toServiceObject();
        if (this.attributes)
            result.attributes = this.attributes.map(attr => attr._toServiceObject());
        if (this._lastResult.metadata != null)
            result.metadata = this._lastResult.metadata;
        return result;
    }
    refreshFromResult(result, resultWins = false) {
        if (result instanceof PersistentObject)
            result = result._lastResult;
        const changedAttributes = [];
        let isDirty = false;
        if (!this.isEditing && result.attributes.some(a => a.isValueChanged))
            this.beginEdit();
        this._lastResult = result;
        this.attributes.removeAll(attr => {
            if (!result.attributes.some(serviceAttr => serviceAttr.id === attr.id)) {
                delete this.attributes[attr.name];
                attr.parent = null;
                changedAttributes.push(attr);
                return true;
            }
            return false;
        });
        this.attributes.forEach(attr => {
            let serviceAttr = result.attributes.find(serviceAttr => serviceAttr.id === attr.id);
            if (serviceAttr) {
                if (!(serviceAttr instanceof PersistentObjectAttribute$1))
                    serviceAttr = this._createPersistentObjectAttribute(serviceAttr);
                if (attr._refreshFromResult(serviceAttr, resultWins))
                    changedAttributes.push(attr);
            }
            if (attr.isValueChanged)
                isDirty = true;
        });
        result.attributes.forEach(serviceAttr => {
            if (!this.attributes.some(a => a.id === serviceAttr.id)) {
                const attr = this._createPersistentObjectAttribute(serviceAttr);
                this.attributes.push(attr);
                attr.parent = this;
                changedAttributes.push(attr);
                if (attr.isValueChanged)
                    isDirty = true;
            }
        });
        if (changedAttributes.length > 0)
            this.refreshTabsAndGroups(...changedAttributes);
        this.setNotification(result.notification, result.notificationType, result.notificationDuration);
        this._setIsDirty(isDirty, true);
        this.objectId = result.objectId;
        if (this.isNew)
            this.isNew = result.isNew;
        this.securityToken = result.securityToken;
        if (result.breadcrumb)
            this._setBreadcrumb(result.breadcrumb);
        if (result.queriesToRefresh) {
            result.queriesToRefresh.forEach(async (id) => {
                const query = this.queries.find(q => q.id === id || q.name === id);
                if (query && (query.hasSearched || query.notification || query.totalItems != null))
                    await query.search();
            });
        }
        this._tag = result.tag;
        this.service.hooks.onRefreshFromResult(this);
        this._setLastUpdated(new Date());
    }
    refreshTabsAndGroups(...changedAttributes) {
        const tabGroupsChanged = new Set();
        const tabGroupAttributesChanged = new Set();
        let tabsRemoved = false;
        let tabsAdded = false;
        changedAttributes.forEach(attr => {
            let tab = this.tabs.find(t => t instanceof PersistentObjectAttributeTab && t.key === attr.tabKey);
            if (!tab) {
                if (!attr.isVisible)
                    return;
                const groups = [this.service.hooks.onConstructPersistentObjectAttributeGroup(this.service, attr.groupKey, [attr], this)];
                groups[0].index = 0;
                const serviceTab = this._lastResult.tabs[attr.tabKey];
                attr.tab = tab = this.service.hooks.onConstructPersistentObjectAttributeTab(this.service, groups, attr.tabKey, serviceTab.id, serviceTab.name, serviceTab.layout, this, serviceTab.columnCount, !this.isHidden);
                this.tabs.push(tab);
                tabsAdded = true;
                return;
            }
            let group = tab.groups.find(g => g.key === attr.groupKey);
            if (!group && attr.isVisible) {
                group = this.service.hooks.onConstructPersistentObjectAttributeGroup(this.service, attr.groupKey, [attr], this);
                tab.groups.push(group);
                tab.groups.sort((g1, g2) => g1.attributes.min(a => a.offset) - g2.attributes.min(a => a.offset));
                tab.groups.forEach((g, n) => g.index = n);
                tabGroupsChanged.add(tab);
            }
            else if (attr.isVisible && attr.parent) {
                if (group.attributes.indexOf(attr) < 0) {
                    group.attributes.push(attr);
                    tabGroupAttributesChanged.add(group);
                    tab.attributes.push(attr);
                    tab.attributes[attr.name] = group.attributes[attr.name] = attr;
                    group.attributes.sort((x, y) => x.offset - y.offset);
                }
            }
            else if (group) {
                group.attributes.remove(attr);
                delete group.attributes[attr.name];
                tab.attributes.remove(attr);
                delete tab.attributes[attr.name];
                if (group.attributes.length === 0) {
                    tab.groups.remove(group);
                    tabGroupsChanged.add(tab);
                    if (tab.groups.length === 0) {
                        this.tabs.remove(tab);
                        tabsRemoved = true;
                        return;
                    }
                    else
                        tab.groups.forEach((g, n) => g.index = n);
                }
                else
                    tabGroupAttributesChanged.add(group);
            }
        });
        const attributeTabs = this.tabs.filter(t => t instanceof PersistentObjectAttributeTab);
        if (tabsAdded) {
            attributeTabs.sort((t1, t2) => [].concat(...t1.groups.map(g => g.attributes)).min(a => a.offset) - [].concat(...t2.groups.map(g => g.attributes)).min(a => a.offset));
            const queryTabs = this.tabs.filter(t => t instanceof PersistentObjectQueryTab);
            queryTabs.sort((q1, q2) => q1.query.offset - q2.query.offset);
            this.tabs = this.service.hooks.onSortPersistentObjectTabs(this, attributeTabs, queryTabs);
        }
        else if (tabsRemoved)
            this.tabs = this.tabs.slice();
        if (tabGroupsChanged.size > 0)
            tabGroupsChanged.forEach(tab => tab.groups = tab.groups.slice());
        if (tabGroupAttributesChanged.size > 0) {
            tabGroupAttributesChanged.forEach(group => {
                group.attributes = group.attributes.slice();
            });
        }
        attributeTabs.forEach(tab => tab.isVisible = tab.attributes.some(a => a.isVisible));
    }
    triggerDirty() {
        if (this.isEditing)
            this._setIsDirty(true);
        return this.isDirty;
    }
    _triggerAttributeRefresh(attr, immediate) {
        const attrValue = attr.value;
        const work = async () => {
            if (attrValue !== attr.value)
                return false;
            this._prepareAttributesForRefresh(attr);
            const result = await this.service.executeAction("PersistentObject.Refresh", this, null, null, { RefreshedPersistentObjectAttributeId: attr.id });
            if (this.isEditing)
                this.refreshFromResult(result);
            return true;
        };
        let result;
        if (!immediate)
            result = this.queueWork(work, false);
        else
            result = work();
        if (result && Boolean.parse(attr.getTypeHint("TriggerRefreshOnOwner", "false")?.toLowerCase()) && this.ownerDetailAttribute?.triggersRefresh) {
            return result.then(async (res) => {
                await this.ownerDetailAttribute._triggerAttributeRefresh(immediate);
                return res;
            });
        }
        return result;
    }
    _prepareAttributesForRefresh(sender) {
        this.attributes.filter(a => a.id !== sender.id).forEach(attr => {
            attr._refreshServiceValue = attr._serviceValue;
            if (attr instanceof PersistentObjectAttributeWithReference) {
                const attrWithRef = attr;
                attrWithRef._refreshObjectId = attrWithRef.objectId;
            }
        });
    }
};

let PersistentObjectAttributeAsDetail$1 = class PersistentObjectAttributeAsDetail extends PersistentObjectAttribute$1 {
    constructor(service, attr, parent) {
        super(service, attr, parent);
        this.parent = parent;
        if (attr.details)
            this.details = this.service.hooks.onConstructQuery(service, attr.details, parent, false, 1);
        else
            this.details = null;
        if (attr.objects) {
            this._objects = attr.objects.map(po => {
                const detailObj = this.service.hooks.onConstructPersistentObject(service, po);
                detailObj.parent = this.parent;
                detailObj.ownerDetailAttribute = this;
                return detailObj;
            });
        }
        else
            this._objects = [];
        this.parent.propertyChanged.attach((sender, args) => {
            if (args.propertyName === "isEditing" && args.newValue)
                this.objects.forEach(o => o.beginEdit());
            else if (args.propertyName === "isFrozen") {
                if (args.newValue)
                    this.objects.forEach(obj => obj.freeze());
                else
                    this.objects.forEach(obj => obj.unfreeze());
            }
        });
        this.lookupAttribute = attr.lookupAttribute;
    }
    get objects() {
        return this._objects;
    }
    _setObjects(objects) {
        if (objects === this._objects) {
            if (!!objects && objects.length === this._objects.length) {
                let hasDifferences;
                for (let n = 0; n < objects.length; n++) {
                    if (objects[n] !== this.objects[n]) {
                        hasDifferences = true;
                        break;
                    }
                }
                if (!hasDifferences)
                    return;
            }
        }
        const oldObjects = this.objects;
        this.notifyPropertyChanged("objects", this._objects = objects, oldObjects);
    }
    async newObject() {
        const po = await this.details.actions["New"].execute({ throwExceptions: true, skipOpen: true });
        if (!po)
            return null;
        po.ownerQuery = null;
        po.ownerDetailAttribute = this;
        return po;
    }
    _refreshFromResult(resultAttr, resultWins) {
        const asDetailAttr = resultAttr;
        const visibilityChanged = super._refreshFromResult(resultAttr, resultWins);
        if (this.objects != null && asDetailAttr.objects != null) {
            const isEditing = this.parent.isEditing;
            this._setObjects(asDetailAttr.objects.map(obj => {
                obj.parent = this.parent;
                obj.ownerDetailAttribute = this;
                if (isEditing)
                    obj.beginEdit();
                return obj;
            }));
        }
        return visibilityChanged;
    }
    _toServiceObject() {
        const result = super._toServiceObject();
        if (this.objects != null) {
            result.objects = this.objects.map(obj => {
                const detailObj = obj.toServiceObject(true);
                if (obj.isDeleted)
                    detailObj.isDeleted = true;
                return detailObj;
            });
        }
        return result;
    }
    async onChanged(allowRefresh) {
        if (!this.parent.isEditing || this.isReadOnly)
            return this.value;
        this.parent.triggerDirty();
        if (this.triggersRefresh) {
            if (allowRefresh)
                await this._triggerAttributeRefresh();
            else
                this._shouldRefresh = true;
        }
        return this.value;
    }
};

class QueryResultItem extends ServiceObject {
    constructor(service, item, query, _isSelected) {
        super(service);
        this.query = query;
        this._isSelected = _isSelected;
        this.id = item.id;
        if (item.values) {
            const columnNames = query.columns.map(c => c.name);
            this.rawValues = item.values.filter(v => columnNames.indexOf(v.key) >= 0).map(v => service.hooks.onConstructQueryResultItemValue(this.service, this, v));
        }
        else
            this.rawValues = [];
        this.typeHints = item.typeHints;
        this._tag = this._tag;
    }
    get values() {
        if (!this._values) {
            this._values = {};
            this.rawValues.forEach(v => {
                const col = this.query.columns[v.key];
                if (!col)
                    return;
                this._values[v.key] = Service.fromServiceString(v.value, col.type);
            });
        }
        return this._values;
    }
    get isSelected() {
        if (this._ignoreSelect)
            return false;
        return this._isSelected;
    }
    set isSelected(val) {
        if (val && this.ignoreSelect)
            return;
        const oldIsSelected = this._isSelected;
        this.notifyPropertyChanged("isSelected", this._isSelected = val, oldIsSelected);
        this.query._notifyItemSelectionChanged(this);
    }
    get ignoreSelect() {
        if (typeof this._ignoreSelect === "undefined")
            this._ignoreSelect = this.getTypeHint("extraclass", "").toUpperCase().split(" ").some(c => c === "DISABLED" || c === "READONLY");
        return this._ignoreSelect;
    }
    get tag() {
        return this._tag;
    }
    getValue(key) {
        return this.values[key];
    }
    getFullValue(key) {
        if (!this._fullValuesByName) {
            this._fullValuesByName = {};
            this.rawValues.forEach(v => {
                this._fullValuesByName[v.key] = v;
            });
        }
        return this._fullValuesByName[key] || (this._fullValuesByName[key] = null);
    }
    getTypeHint(name, defaultValue, typeHints) {
        return PersistentObjectAttribute$1.prototype.getTypeHint.apply(this, arguments);
    }
    getPersistentObject(throwExceptions) {
        return this.query.queueWork(async () => {
            try {
                const po = await this.service.getPersistentObject(this.query.parent, this.query.persistentObject.id, this.id);
                po.ownerQuery = this.query;
                return po;
            }
            catch (e) {
                this.query.setNotification(e);
                if (throwExceptions)
                    throw e;
                return null;
            }
        }, false);
    }
    _toServiceObject() {
        const result = this.copyProperties(["id"]);
        result.values = this.rawValues.map(v => v._toServiceObject());
        return result;
    }
}

class ActionDefinition {
    constructor(_service, itemOrDefinition) {
        this._service = _service;
        if (itemOrDefinition instanceof QueryResultItem) {
            this._definition = {
                name: itemOrDefinition.getValue("Name"),
                displayName: itemOrDefinition.getValue("DisplayName"),
                isPinned: itemOrDefinition.getValue("IsPinned"),
                isStreaming: itemOrDefinition.getValue("IsStreamingAction"),
                confirmation: itemOrDefinition.getValue("Confirmation"),
                refreshQueryOnCompleted: itemOrDefinition.getValue("RefreshQueryOnCompleted"),
                keepSelectionOnRefresh: itemOrDefinition.getValue("KeepSelectionOnRefresh"),
                offset: itemOrDefinition.getValue("Offset"),
                showedOn: (itemOrDefinition.getValue("ShowedOn") || "").split(",").map(v => v.trim()),
                selectionRule: itemOrDefinition.getValue("SelectionRule"),
                options: itemOrDefinition.getValue("Options")?.split(";").filter(o => !!o) ?? [],
                icon: itemOrDefinition.getValue("Icon") || `Action_${itemOrDefinition.getValue("Name")}`
            };
            const groupAction = itemOrDefinition.getFullValue("GroupAction");
            if (groupAction != null)
                this._groupDefinition = groupAction.objectId;
        }
        else {
            this._definition = Object.assign({
                options: []
            }, itemOrDefinition);
        }
        this._selectionRule = ExpressionParser.get(this._definition.selectionRule);
    }
    get name() {
        return this._definition.name;
    }
    get displayName() {
        return this._definition.displayName;
    }
    get isPinned() {
        return this._definition.isPinned ?? false;
    }
    get isStreaming() {
        return !!this._definition.isStreaming;
    }
    get refreshQueryOnCompleted() {
        return this._definition.refreshQueryOnCompleted;
    }
    get keepSelectionOnRefresh() {
        return this._definition.keepSelectionOnRefresh;
    }
    get offset() {
        return this._definition.offset;
    }
    get confirmation() {
        return this._definition.confirmation;
    }
    get options() {
        return this._definition.options;
    }
    get selectionRule() {
        return this._selectionRule;
    }
    get showedOn() {
        return this._definition.showedOn;
    }
    get groupDefinition() {
        if (this._groupDefinition == null)
            return null;
        if (typeof this._groupDefinition === "string")
            this._groupDefinition = this._service.actionDefinitions[this._groupDefinition];
        return this._groupDefinition;
    }
    get icon() {
        return this._definition.icon;
    }
}

const ClientOperations = {
    enableDatadog: function (hooks, applicationId, clientToken, site, service, version, environment) {
        const _enableDatadog = (h, o, u, n, d) => {
            h = h[d] = h[d] || { q: [], onReady: function (c) { h.q.push(c); } };
            d = o.createElement(u);
            d.async = 1;
            d.src = n;
            n = o.getElementsByTagName(u)[0];
            n.parentNode.insertBefore(d, n);
        };
        _enableDatadog(window, document, 'script', 'https://www.datadoghq-browser-agent.com/datadog-rum.js', 'DD_RUM');
        window["DD_RUM"].onReady(function () {
            window["DD_RUM"].init({
                applicationId: applicationId,
                clientToken: clientToken,
                site: site,
                service: service,
                sampleRate: 100,
                trackInteractions: true,
                version: version,
                env: environment
            });
            window["DD_RUM"].setUser({
                id: hooks.service.application.userId,
                name: hooks.service.userName
            });
        });
    },
    navigate: function (hooks, path, replaceCurrent) {
        hooks.onNavigate(path, replaceCurrent);
    },
    openUrl: function (hooks, url) {
        if (!url.startsWith("http"))
            url = `http://${url}`;
        window.open(url, "_blank");
    },
    refreshForUpdate: function (hooks, path, replaceCurrent) {
        hooks.onUpdateAvailable();
    },
    reloadPage: function () {
        document.location.reload();
    },
    showMessageBox: function (hooks, title, message, rich = false, delay = 0) {
        setTimeout(function () {
            hooks.onMessageDialog(title, message, rich, hooks.service.getTranslatedMessage("OK"));
        }, delay);
    }
};

class ProgramUnitItem extends ServiceObject {
    constructor(service, unitItem, path, nameKebab) {
        super(service);
        this.path = path;
        this.nameKebab = nameKebab;
        this.id = unitItem.id;
        this.title = unitItem.title;
        this.name = unitItem.name;
    }
}
class ProgramUnitItemGroup extends ProgramUnitItem {
    constructor(service, unitItem, items) {
        super(service, unitItem);
        this.items = items;
    }
}
class ProgramUnitItemQuery extends ProgramUnitItem {
    constructor(service, routes, unitItem, parent) {
        super(service, unitItem, parent.path + ProgramUnitItemQuery._getPath(routes, unitItem.query));
        this.queryId = unitItem.query;
    }
    static _getPath(routes, id) {
        for (const name in routes.queries) {
            if (routes.queries[name] === id)
                return "/" + name;
        }
        return "/query." + id;
    }
}
class ProgramUnitItemPersistentObject extends ProgramUnitItem {
    constructor(service, routes, unitItem, parent) {
        super(service, unitItem, parent.path + ProgramUnitItemPersistentObject._getPath(routes, unitItem.persistentObject, unitItem.objectId));
        this.persistentObjectId = unitItem.persistentObject;
        this.persistentObjectObjectId = unitItem.objectId;
    }
    static _getPath(routes, id, objectId) {
        for (const name in routes.persistentObjects) {
            if (routes.persistentObjects[name] === id)
                return "/" + name + (objectId ? "/" + objectId : "");
        }
        return "/persistent-object." + id + (objectId ? "/" + objectId : "");
    }
}
class ProgramUnitItemUrl extends ProgramUnitItem {
    constructor(service, unitItem) {
        super(service, unitItem, unitItem.objectId);
    }
}
class ProgramUnitItemSeparator extends ProgramUnitItem {
    constructor(service, unitItem) {
        super(service, unitItem);
    }
}

class ProgramUnit extends ProgramUnitItem {
    constructor(service, routes, unit) {
        super(service, unit, unit.name.toKebabCase(), unit.name.toKebabCase());
        this.offset = unit.offset;
        this.openFirst = unit.openFirst;
        if (unit.items) {
            this.items = [];
            const usedGroups = {};
            unit.items.forEach(itemData => {
                let itemsTarget = this.items;
                if (!itemData.group) {
                    const pathIndex = itemData.name.lastIndexOf("\\");
                    if (pathIndex >= 0) {
                        const groupNames = itemData.name.split("\\");
                        groupNames.pop();
                        let groupId = null;
                        groupNames.forEach(groupName => {
                            const parentGroup = usedGroups[groupId];
                            let group = usedGroups[groupId = groupId ? `${groupId}\\${groupName}` : groupName];
                            if (!group) {
                                usedGroups[groupId] = group = new ProgramUnitItemGroup(service, { id: groupId, title: groupName, name: groupId }, []);
                                if (parentGroup)
                                    parentGroup.items.push(group);
                                else
                                    this.items.push(group);
                            }
                            itemsTarget = group.items;
                        });
                    }
                }
                else {
                    if (!usedGroups[itemData.group.id])
                        itemsTarget.push(usedGroups[itemData.group.id] = new ProgramUnitItemGroup(service, itemData.group, []));
                    itemsTarget = usedGroups[itemData.group.id].items;
                }
                itemsTarget.push(this._createItem(routes, itemData));
            });
        }
        if (this.openFirst && this.items.length > 0 && (!(this.items[0] instanceof ProgramUnitItemUrl) || !this.items[0].path?.startsWith("http"))) {
            this.path = this.items[0].path;
            if (this.items[0].title === this.title)
                this.items.splice(0, 1);
        }
    }
    _createItem(routes, itemData) {
        if (itemData.query)
            return new ProgramUnitItemQuery(this.service, routes, itemData, this);
        if (itemData.persistentObject)
            return new ProgramUnitItemPersistentObject(this.service, routes, itemData, this);
        if (itemData.isSeparator)
            return new ProgramUnitItemSeparator(this.service, itemData);
        return new ProgramUnitItemUrl(this.service, itemData);
    }
}

class Application extends PersistentObject$1 {
    constructor(service, { application, hasSensitive }) {
        super(service, application);
        this._userId = this.getAttributeValue("UserId");
        this._friendlyUserName = this.getAttributeValue("FriendlyUserName") || service.userName;
        this._feedbackId = this.getAttributeValue("FeedbackId");
        this._userSettingsId = this.getAttributeValue("UserSettingsId");
        this._globalSearchId = this.getAttributeValue("GlobalSearchId");
        this._analyticsKey = this.getAttributeValue("AnalyticsKey");
        this._setRoutes(JSON.parse(this.getAttributeValue("Routes")));
        const puRoutes = "^((" + Object.keys(this._routes.programUnits).join("|") + ")/)?";
        const poTypes = Object.keys(this._routes.persistentObjects).concat(this._routes.persistentObjectKeys);
        this._poRe = poTypes.length === 0 ? /$ ^/ : new RegExp(puRoutes + "(" + poTypes.join("|") + ")(/.+)?$");
        const queryNames = Object.keys(this._routes.queries).concat(this._routes.queryKeys);
        this._queryRe = queryNames.length === 0 ? /$ ^/ : new RegExp(puRoutes + "(" + queryNames.join("|") + ")$");
        const userSettings = this.getAttributeValue("UserSettings");
        this._userSettings = JSON.parse(String.isNullOrEmpty(userSettings) ? (localStorage["UserSettings"] || "{}") : userSettings);
        this._canProfile = this.getAttributeValue("CanProfile");
        const pus = JSON.parse(this.getAttributeValue("ProgramUnits"));
        this._hasManagement = pus.hasManagement;
        this.programUnits = pus.units.map(unit => new ProgramUnit(this.service, this.routes, unit));
        this.hasSensitive = !!hasSensitive;
    }
    get userId() {
        return this._userId;
    }
    get friendlyUserName() {
        return this._friendlyUserName;
    }
    get feedbackId() {
        return this._feedbackId;
    }
    get userSettingsId() {
        return this._userSettingsId;
    }
    get globalSearchId() {
        return this._globalSearchId;
    }
    get analyticsKey() {
        return this._analyticsKey;
    }
    get userSettings() {
        return this._userSettings;
    }
    get canProfile() {
        return this._canProfile;
    }
    get hasManagement() {
        return this._hasManagement;
    }
    get session() {
        return this._session;
    }
    get routes() {
        return this._routes;
    }
    _setRoutes(routes) {
        const queryKeys = Object.keys(routes.queries);
        const persistentObjectKeys = Object.keys(routes.persistentObjects);
        this._routes = {
            queries: Object.assign({}, ...queryKeys.map(q => ({ [q.toKebabCase()]: routes.queries[q] }))),
            queryKeys: queryKeys,
            persistentObjects: Object.assign({}, ...Object.keys(routes.persistentObjects).map(po => ({ [po.toKebabCase()]: routes.persistentObjects[po] }))),
            persistentObjectKeys: persistentObjectKeys,
            programUnits: Object.assign(routes.programUnits, ...Object.keys(routes.programUnits).map(pu => ({ [pu.toKebabCase()]: routes.programUnits[pu] })))
        };
    }
    get poRe() {
        return this._poRe;
    }
    get queryRe() {
        return this._queryRe;
    }
    async saveUserSettings() {
        if (this.userSettingsId !== "00000000-0000-0000-0000-000000000000") {
            const po = await this.service.getPersistentObject(null, this.userSettingsId, null);
            po.attributes["Settings"].value = JSON.stringify(this.userSettings);
            await po.save();
        }
        else
            localStorage["UserSettings"] = JSON.stringify(this.userSettings);
        return this.userSettings;
    }
    _updateSession(session) {
        const oldSession = this._session;
        if (!session) {
            if (this._session)
                this._session = null;
        }
        else {
            if (this._session)
                this._session.refreshFromResult(new PersistentObject$1(this.service, session));
            else
                this._session = new PersistentObject$1(this.service, session);
        }
        if (oldSession !== this._session)
            this.notifyPropertyChanged("session", this._session, oldSession);
    }
}

class PersistentObjectAttributeGroup extends Observable {
    constructor(service, key, _attributes, parent) {
        super();
        this.service = service;
        this.key = key;
        this.parent = parent;
        this.label = key || "";
        this.attributes = _attributes;
    }
    get attributes() {
        return this._attributes;
    }
    set attributes(attributes) {
        const oldAttributes = this._attributes;
        const newAttributes = attributes;
        newAttributes.forEach(attr => newAttributes[attr.name] = attr);
        this.notifyPropertyChanged("attributes", this._attributes = newAttributes, oldAttributes);
    }
}

class QueryColumn extends ServiceObject {
    constructor(service, col, query) {
        super(service);
        this.query = query;
        this._id = col.id;
        this._canSort = !!col.canSort;
        this._canGroupBy = !!col.canGroupBy;
        this._canFilter = !!col.canFilter;
        this._canListDistincts = !!col.canListDistincts;
        this._displayAttribute = col.displayAttribute;
        this._isSensitive = !!col.isSensitive;
        if (col instanceof QueryColumn) {
            this._selectedDistincts = col._selectedDistincts;
            this._selectedDistinctsInversed = col._selectedDistinctsInversed;
        }
        else {
            this._selectedDistincts = col.includes || col.excludes || [];
            this._selectedDistinctsInversed = !!col.excludes && col.excludes.length > 0;
        }
        this._label = col.label;
        this._name = col.name;
        this.offset = col.offset || 0;
        this._type = col.type;
        this.isPinned = !!col.isPinned;
        this.isHidden = !!col.isHidden;
        this.width = col.width;
        this.typeHints = col.typeHints;
        this._sortDirection = "";
        this._tag = col._tag;
        query.propertyChanged.attach(this._queryPropertyChanged.bind(this));
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._name;
    }
    get type() {
        return this._type;
    }
    get label() {
        return this._label;
    }
    get canFilter() {
        return this._canFilter;
    }
    get canSort() {
        return this._canSort;
    }
    get canGroupBy() {
        return this._canGroupBy;
    }
    get canListDistincts() {
        return this._canListDistincts;
    }
    get displayAttribute() {
        return this._displayAttribute;
    }
    get isSensitive() {
        return this._isSensitive;
    }
    get isSorting() {
        return this._sortDirection !== "";
    }
    get sortDirection() {
        return this._sortDirection;
    }
    get selectedDistincts() {
        return this._selectedDistincts;
    }
    set selectedDistincts(selectedDistincts) {
        const oldSelectedIncludes = this._selectedDistincts;
        this.notifyPropertyChanged("selectedDistincts", this._selectedDistincts = (selectedDistincts || []), oldSelectedIncludes);
        this.query.columns.forEach(c => {
            if (c === this)
                return;
            if (c.distincts)
                c.distincts.isDirty = true;
        });
    }
    get selectedDistinctsInversed() {
        return this._selectedDistinctsInversed;
    }
    set selectedDistinctsInversed(selectedDistinctsInversed) {
        const oldSelectedDistinctsInversed = this._selectedDistinctsInversed;
        this.notifyPropertyChanged("selectedDistinctsInversed", this._selectedDistinctsInversed = selectedDistinctsInversed, oldSelectedDistinctsInversed);
    }
    get distincts() {
        return this._distincts;
    }
    set distincts(distincts) {
        const oldDistincts = this._distincts;
        this.notifyPropertyChanged("distincts", this._distincts = distincts, oldDistincts);
    }
    get total() {
        return this._total;
    }
    get tag() {
        return this._tag;
    }
    _setTotal(total) {
        const oldTotal = this._total;
        this.notifyPropertyChanged("total", this._total = total, oldTotal);
    }
    _setSortDirection(direction) {
        if (this._sortDirection === direction)
            return;
        const oldSortDirection = this._sortDirection;
        this.notifyPropertyChanged("sortDirection", this._sortDirection = direction, oldSortDirection);
    }
    _toServiceObject() {
        const serviceObject = this.copyProperties(["id", "name", "label", "type", "displayAttribute"]);
        serviceObject.includes = !this.selectedDistinctsInversed ? this.selectedDistincts : [];
        serviceObject.excludes = this.selectedDistinctsInversed ? this.selectedDistincts : [];
        return serviceObject;
    }
    getTypeHint(name, defaultValue, typeHints, ignoreCasing) {
        return PersistentObjectAttribute$1.prototype.getTypeHint.apply(this, arguments);
    }
    async refreshDistincts(search) {
        const parameters = { ColumnName: this.name, AsLookup: this.query.asLookup };
        if (search)
            parameters.Search = search;
        let result;
        try {
            result = await this.service.executeAction("QueryFilter.RefreshColumn", this.query.parent, this.query.clone(), null, parameters);
        }
        catch (e) {
            return this.distincts;
        }
        this.query.columns.filter(q => q !== this).forEach(col => {
            if (col.distincts)
                col.distincts.isDirty = true;
        });
        const matchingDistinctsAttr = result.attributes["MatchingDistincts"];
        const remainingDistinctsAttr = result.attributes["RemainingDistincts"];
        this.distincts = {
            matching: matchingDistinctsAttr.options,
            remaining: remainingDistinctsAttr.options,
            isDirty: false,
            hasMore: matchingDistinctsAttr.typeHints.hasmore || remainingDistinctsAttr.typeHints.hasmore
        };
        return this.distincts;
    }
    async sort(direction, multiSort) {
        if (!!multiSort) {
            const sortOption = this.query.sortOptions.filter(option => option.column === this)[0];
            if (sortOption && sortOption.direction === direction)
                return;
            if (!sortOption) {
                if (direction !== "")
                    this.query.sortOptions = this.query.sortOptions.concat([{ column: this, name: this.name, direction: direction }]);
            }
            else {
                if (direction !== "") {
                    sortOption.direction = direction;
                    this.query.sortOptions = this.query.sortOptions.slice();
                }
                else
                    this.query.sortOptions = this.query.sortOptions.filter(option => option !== sortOption);
            }
        }
        else
            this.query.sortOptions = direction !== "" ? [{ column: this, name: this.name, direction: direction }] : [];
        try {
            await this.query.search({ throwExceptions: true });
        }
        catch (e) {
            return this.query.items;
        }
        const querySettings = (this.service.application.userSettings["QuerySettings"] || (this.service.application.userSettings["QuerySettings"] = {}))[this.query.id] || {};
        querySettings["sortOptions"] = this.query.sortOptions.filter(option => option.direction !== "").map(option => `${option.name} ${option.direction}`.trimEnd()).join("; ");
        this.service.application.userSettings["QuerySettings"][this.query.id] = querySettings;
        await this.service.application.saveUserSettings();
        return this.query.items;
    }
    _queryPropertyChanged(sender, args) {
        if (args.propertyName === "sortOptions") {
            const sortOption = this.query.sortOptions ? this.query.sortOptions.filter(option => option.column === this)[0] : null;
            this._setSortDirection(sortOption ? sortOption.direction : "");
        }
        else if (args.propertyName === "totalItem")
            this._setTotal(sender.totalItem ? sender.totalItem.getFullValue(this.name) : null);
    }
}

class QueryFilters extends Observable {
    constructor(_query, _filtersPO) {
        super();
        this._query = _query;
        this._filtersPO = _filtersPO;
        this._filtersAsDetail = this._filtersPO.attributes["Filters"];
        this._computeFilters(true);
        const defaultFilter = this._filters.find(f => f.isDefault);
        if (defaultFilter) {
            this._skipSearch = true;
            try {
                this.currentFilter = defaultFilter;
            }
            finally {
                this._skipSearch = false;
            }
        }
    }
    get filters() {
        return this._filters;
    }
    _setFilters(filters) {
        const oldFilters = this._filters;
        this.notifyPropertyChanged("filters", this._filters = filters, oldFilters);
    }
    get detailsAttribute() {
        return this._filtersAsDetail;
    }
    get currentFilter() {
        return this._currentFilter;
    }
    set currentFilter(filter) {
        let doSearch;
        if (!!filter) {
            if (!filter.persistentObject.isNew) {
                let columnsFilterData = JSON.parse(filter.persistentObject.getAttributeValue("Columns"));
                this._query.columns.forEach(col => {
                    let columnFilterData = columnsFilterData.find(c => c.name === col.name);
                    if (columnFilterData) {
                        if (columnFilterData.includes && columnFilterData.includes.length > 0)
                            col.selectedDistincts = columnFilterData.includes;
                        else if (columnFilterData.excludes && columnFilterData.excludes.length > 0)
                            col.selectedDistincts = columnFilterData.excludes;
                        else
                            col.selectedDistincts = [];
                        col.selectedDistinctsInversed = columnFilterData.excludes && columnFilterData.excludes.length > 0;
                        col.distincts = null;
                        doSearch = doSearch || (col.selectedDistincts.length > 0);
                    }
                    else
                        col.selectedDistincts = [];
                });
            }
        }
        else {
            this._query.columns.forEach(col => {
                col.selectedDistincts = [];
                col.selectedDistinctsInversed = false;
                col.distincts = null;
            });
            doSearch = !!this._currentFilter;
        }
        const oldCurrentFilter = this._currentFilter;
        this.notifyPropertyChanged("currentFilter", this._currentFilter = filter, oldCurrentFilter);
        if (doSearch && !this._skipSearch)
            this._query.search();
    }
    _computeFilters(setDefaultFilter) {
        if (!this._filtersAsDetail) {
            this._setFilters([]);
            return;
        }
        const currentFilters = {};
        if (this._filters)
            this._filters.forEach(f => currentFilters[f.name || ""] = f);
        this._setFilters(this._filtersAsDetail.objects.map(filter => new QueryFilter(filter)));
        if (setDefaultFilter)
            this._currentFilter = this._filters.find(f => f.persistentObject.getAttributeValue("IsDefault")) || null;
    }
    _computeFilterData() {
        return JSON.stringify(this._query.columns.filter(c => c.selectedDistincts.length > 0).map(c => {
            return {
                name: c.name,
                includes: !c.selectedDistinctsInversed ? c.selectedDistincts : [],
                excludes: c.selectedDistinctsInversed ? c.selectedDistincts : []
            };
        }));
    }
    clone(targetQuery) {
        return new QueryFilters(targetQuery, targetQuery.service.hooks.onConstructPersistentObject(targetQuery.service, this._filtersPO["_lastResult"]));
    }
    getFilter(name) {
        return this.filters.find(f => f.name === name);
    }
    createNew() {
        const newAction = this._filtersAsDetail.details.actions["New"];
        return this._query.queueWork(async () => {
            const po = await newAction.execute({ skipOpen: true });
            return new QueryFilter(po);
        });
    }
    save(filter = this.currentFilter) {
        if (!filter)
            return Promise.reject("Expected argument filter.");
        if (filter.isLocked)
            return Promise.reject("Filter is locked.");
        if (this._filtersAsDetail.objects.some(f => f.isNew))
            return Promise.reject("Only one new filter can be saved at a time.");
        this._filtersPO.beginEdit();
        if (filter === this.currentFilter || filter.persistentObject.isNew) {
            filter.persistentObject.beginEdit();
            filter.persistentObject.attributes["Columns"].setValue(this._computeFilterData());
        }
        if (filter.persistentObject.isNew)
            this._filtersAsDetail.objects.push(filter.persistentObject);
        return this._query.queueWork(async () => {
            let result;
            try {
                result = await this._filtersPO.save();
            }
            catch (e) {
                result = false;
                filter.persistentObject.setNotification(e, "Error");
            }
            const newFilter = this._filtersAsDetail.objects.find(f => f.isNew);
            if (newFilter)
                this._filtersAsDetail.objects.remove(filter.persistentObject = newFilter);
            this._computeFilters();
            this.currentFilter = this.filters.find(f => f.name === filter.name);
            return result;
        });
    }
    delete(name) {
        const filter = typeof name === "string" ? this.getFilter(name) : name;
        if (!filter)
            return Promise.reject(`No filter found with name '${name}'.`);
        if (filter.isLocked)
            return Promise.reject("Filter is locked.");
        if (!filter.persistentObject.isNew) {
            filter.persistentObject.isDeleted = true;
            return this._query.queueWork(async () => {
                this._filtersPO.beginEdit();
                await this._filtersPO.save();
                this._computeFilters();
                if (this.currentFilter === filter)
                    this.currentFilter = null;
                return null;
            });
        }
        this._filtersAsDetail.objects.remove(filter.persistentObject);
        this._computeFilters();
        return Promise.resolve(null);
    }
}
class QueryFilter extends Observable {
    constructor(persistentObject) {
        super();
        this.persistentObject = persistentObject;
    }
    get name() {
        return this.persistentObject.getAttributeValue("Name") || "";
    }
    get isLocked() {
        return this.persistentObject.getAttributeValue("IsLocked");
    }
    get isDefault() {
        return this.persistentObject.getAttributeValue("IsDefault");
    }
}

class QueryChart extends Observable {
    constructor(_query, _label, _name, _options, _type) {
        super();
        this._query = _query;
        this._label = _label;
        this._name = _name;
        this._options = _options;
        this._type = _type;
    }
    get query() {
        return this._query;
    }
    get label() {
        return this._label;
    }
    get name() {
        return this._name;
    }
    get options() {
        return this._options;
    }
    get type() {
        return this._type;
    }
    async execute(parameters = {}) {
        const result = await this._query.service.executeAction("QueryFilter.Chart", this._query.parent, this._query, null, Object.assign(parameters, { name: this.name }));
        return JSON.parse(result.getAttributeValue("Data"));
    }
}

class QueryResultItemGroup extends Observable {
    constructor(query, group, _start, _end, _notifier) {
        super();
        this.query = query;
        this._start = _start;
        this._end = _end;
        this._notifier = _notifier;
        this._name = group.name;
        this._count = group.count;
        this._items = new Array(this._count);
        const items = query.items.slice(_start, _end);
        this._items.splice(0, items.length, ...items);
        this._isCollapsed = false;
    }
    get name() {
        return this._name;
    }
    get count() {
        return this._count;
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    get items() {
        return this._items;
    }
    get isCollapsed() {
        return this._isCollapsed;
    }
    set isCollapsed(isCollapsed) {
        if (this._isCollapsed === isCollapsed)
            return;
        const oldIsCollapsed = this._isCollapsed;
        this.notifyPropertyChanged("isCollapsed", this._isCollapsed = isCollapsed, oldIsCollapsed);
        this._notifier();
    }
    update(group, start, end) {
        this._count = group.count;
        this._start = start;
        this._end = end;
        this._items = new Array(this._count);
        const items = this.query.items.slice(start, end);
        this._items.splice(0, items.length, ...items);
    }
}

class QuerySelectAllImpl extends Observable {
    constructor(_query, _isAvailable, observer) {
        super();
        this._query = _query;
        this._isAvailable = _isAvailable;
        this._allSelected = false;
        this._inverse = false;
        this.propertyChanged.attach(observer);
    }
    get isAvailable() {
        if (this._query.maxSelectedItems)
            return;
        return this._isAvailable;
    }
    set isAvailable(isAvailable) {
        if (this._query.maxSelectedItems)
            return;
        if (this._isAvailable === isAvailable)
            return;
        this.allSelected = this.inverse = false;
        const oldValue = this._isAvailable;
        this.notifyPropertyChanged("isAvailable", this._isAvailable = isAvailable, oldValue);
    }
    get allSelected() {
        return this._allSelected;
    }
    set allSelected(allSelected) {
        if (!this.isAvailable)
            return;
        if (this._allSelected === allSelected)
            return;
        const oldInverse = this._inverse;
        if (oldInverse)
            this._inverse = false;
        const oldValue = this._allSelected;
        this.notifyPropertyChanged("allSelected", this._allSelected = allSelected, oldValue);
        if (oldInverse)
            this.notifyPropertyChanged("inverse", this._inverse, oldValue);
    }
    get inverse() {
        return this._inverse;
    }
    set inverse(inverse) {
        if (!this.isAvailable)
            return;
        if (this._inverse === inverse)
            return;
        const oldValue = this._inverse;
        this.notifyPropertyChanged("inverse", this._inverse = inverse, oldValue);
    }
}
let Query$1 = class Query extends ServiceObjectWithActions {
    constructor(service, query, parent, asLookup = false, maxSelectedItems) {
        super(service, query._actionNames || query.actions, query.actionLabels);
        this.parent = parent;
        this.maxSelectedItems = maxSelectedItems;
        this._queriedPages = [];
        this._charts = null;
        this._defaultChartName = null;
        this._currentChart = null;
        this._hasMore = null;
        this._asLookup = asLookup;
        this._isSystem = !!query.isSystem;
        this.id = query.id;
        this.name = query.name;
        this.autoQuery = query.autoQuery;
        this._allowTextSearch = query.allowTextSearch;
        this._canRead = !!query.canRead;
        this.isHidden = query.isHidden;
        this.label = query.label;
        this.setNotification(query.notification, query.notificationType, query.notificationDuration);
        this.offset = query.offset || 0;
        this.textSearch = query.textSearch || "";
        this.pageSize = query.pageSize;
        this.skip = query.skip;
        this.top = query.top;
        this.persistentObject = query.persistentObject instanceof PersistentObject$1 ? query.persistentObject : service.hooks.onConstructPersistentObject(service, query.persistentObject);
        this.singularLabel = this.persistentObject.label;
        this._updateColumns(query.columns);
        this._initializeActions();
        this._canReorder = !!query.canReorder && !asLookup;
        this.selectAll = new QuerySelectAllImpl(this, (!!query.isSystem || !!query.enableSelectAll) && !query.maxSelectedItems && this.actions.some(a => a.isVisible && a.definition.selectionRule !== ExpressionParser.alwaysTrue), this._selectAllPropertyChanged.bind(this));
        this._setTotalItems(query.totalItems);
        this._setSortOptionsFromService(query.sortOptions);
        if (query.disableBulkEdit) {
            const bulkEdit = this.actions["BulkEdit"];
            if (bulkEdit)
                bulkEdit.selectionRule = count => count === 1;
        }
        if (query.filters) {
            if (query.filters instanceof QueryFilters)
                this._filters = asLookup ? query.filters.clone(this) : null;
            else
                this._filters = new QueryFilters(this, service.hooks.onConstructPersistentObject(service, query.filters));
        }
        else
            this._filters = null;
        this._canFilter = this.actions.some(a => a.name === "Filter") && this.columns.some(c => c.canFilter);
        this._tag = query.tag;
        if (query.result)
            this._setResult(query.result);
        else {
            this.items = [];
            this._labelWithTotalItems = this.label;
            this._lastUpdated = new Date();
        }
        if (query instanceof Query && query.groupingInfo)
            this._setGroupingInfo({ groupedBy: query.groupingInfo.groupedBy });
    }
    get isSystem() {
        return this._isSystem;
    }
    get allowTextSearch() {
        return this._allowTextSearch;
    }
    get filters() {
        return this._filters;
    }
    get canFilter() {
        return this._canFilter;
    }
    _setCanFilter(val) {
        if (this._canFilter === val)
            return;
        const oldValue = this._canFilter;
        this.notifyPropertyChanged("canFilter", this._canFilter = val, oldValue);
    }
    get hasMore() {
        return this._hasMore;
    }
    _setHasMore(val) {
        const oldValue = this._hasMore;
        if (oldValue === val)
            return;
        this.notifyPropertyChanged("hasMore", this._hasMore = val, oldValue);
    }
    get canRead() {
        return this._canRead;
    }
    get canReorder() {
        return this._canReorder;
    }
    get charts() {
        return this._charts;
    }
    _setCharts(charts) {
        if (this._charts && charts && this._charts.length > 0 && this._charts.length === charts.length && this._charts.orderBy(c => c.name).join("\n") === charts.orderBy(c => c.name).join("\n"))
            return;
        const oldCharts = this._charts;
        this.notifyPropertyChanged("charts", this._charts = charts, oldCharts);
        if (charts && this.defaultChartName && !this.currentChart)
            this.currentChart = this.charts.find(c => c.name === this._defaultChartName);
    }
    get currentChart() {
        return this._currentChart;
    }
    set currentChart(currentChart) {
        if (this._currentChart === currentChart)
            return;
        const oldCurrentChart = this._currentChart;
        this.notifyPropertyChanged("currentChart", this._currentChart = currentChart !== undefined ? currentChart : null, oldCurrentChart);
    }
    get defaultChartName() {
        return this._defaultChartName;
    }
    set defaultChartName(defaultChart) {
        if (this._defaultChartName === defaultChart)
            return;
        const oldDefaultChart = this._defaultChartName;
        this.notifyPropertyChanged("defaultChartName", this._defaultChartName = defaultChart !== undefined ? defaultChart : null, oldDefaultChart);
        if (this.charts && defaultChart && !this.currentChart)
            this.currentChart = this.charts.find(c => c.name === this._defaultChartName);
    }
    get groupingInfo() {
        return this._groupingInfo;
    }
    _setGroupingInfo(groupingInfo) {
        const oldValue = this._groupingInfo;
        if (oldValue === groupingInfo)
            return;
        this.notifyPropertyChanged("groupingInfo", this._groupingInfo = groupingInfo, oldValue);
    }
    get tag() {
        return this._tag;
    }
    get lastUpdated() {
        return this._lastUpdated;
    }
    _setLastUpdated(date = new Date()) {
        if (this._lastUpdated === date)
            return;
        const oldLastUpdated = this._lastUpdated;
        this.notifyPropertyChanged("lastUpdated", this._lastUpdated = date, oldLastUpdated);
    }
    get selectedItems() {
        return this.items ? this.items.filter(i => i.isSelected) : [];
    }
    set selectedItems(items) {
        try {
            this._isSelectionModifying = true;
            items = items.filter(i => !i.ignoreSelect) || [];
            const selectedItems = this.selectedItems;
            if (selectedItems && selectedItems.length > 0)
                selectedItems.forEach(item => item.isSelected = false);
            items.forEach(item => item.isSelected = true);
            this.notifyPropertyChanged("selectedItems", items);
        }
        finally {
            this._isSelectionModifying = false;
        }
    }
    _selectAllPropertyChanged(selectAll, args) {
        if (args.propertyName === "allSelected")
            this.selectedItems = this.selectAll.allSelected ? this.items : [];
    }
    async resetFilters() {
        if (!!this._filters || !this.actions["Filter"])
            return;
        await this.queueWork(async () => {
            this._filters = new QueryFilters(this, await this.service.getPersistentObject(null, "a0a2bd29-2921-43a6-a322-b2dcf4c895c2", this.id));
        });
    }
    selectRange(from, to) {
        let selectionUpdated;
        try {
            this._isSelectionModifying = true;
            const itemsToSelect = this.items.slice(from, ++to);
            if (this.maxSelectedItems && this.selectedItems.concat(itemsToSelect).distinct().length > this.maxSelectedItems)
                return;
            if (Object.keys(itemsToSelect).length === to - from) {
                itemsToSelect.forEach(item => {
                    item.isSelected = true;
                });
                selectionUpdated = itemsToSelect.length > 0;
                this.notifyPropertyChanged("selectedItems", this.selectedItems);
                return true;
            }
            return false;
        }
        finally {
            this._isSelectionModifying = false;
            if (selectionUpdated)
                this._updateSelectAll();
        }
    }
    get asLookup() {
        return this._asLookup;
    }
    get totalItems() {
        return this._totalItems;
    }
    get labelWithTotalItems() {
        return this._labelWithTotalItems;
    }
    get sortOptions() {
        return this._sortOptions;
    }
    get totalItem() {
        return this._totalItem;
    }
    _setTotalItem(item) {
        if (this._totalItem === item)
            return;
        const oldTotalItem = this._totalItem;
        this.notifyPropertyChanged("totalItem", this._totalItem = item, oldTotalItem);
    }
    set sortOptions(options) {
        if (this._sortOptions === options)
            return;
        const oldSortOptions = this._sortOptions;
        this.notifyPropertyChanged("sortOptions", this._sortOptions = options, oldSortOptions);
    }
    async group(columnOrBy) {
        const by = columnOrBy instanceof QueryColumn ? columnOrBy.name : columnOrBy;
        if (this.groupingInfo && this.groupingInfo.groupedBy === by)
            return;
        this._updateGroupingInfo({
            groupedBy: by,
            groups: []
        });
        return this.search();
    }
    async reorder(before, item, after) {
        if (!this.canReorder)
            throw "Unable to reorder, canReorder is set to false.";
        return await this.queueWork(async () => {
            try {
                const po = await this.service.executeAction("QueryOrder.Reorder", this.parent, this, [before, item, after]);
                this._setResult(po.queries[0]._lastResult);
                return this.items;
            }
            catch (e) {
                return [];
            }
        });
    }
    _setSortOptionsFromService(options) {
        let newSortOptions;
        if (typeof options === "string") {
            if (!String.isNullOrEmpty(options)) {
                newSortOptions = [];
                options.split(";").map(option => option.trim()).forEach(option => {
                    const optionParts = option.splitWithTail(" ", 2).map(option => option.trim());
                    const col = this.getColumn(optionParts[0]);
                    newSortOptions.push({
                        column: col,
                        name: optionParts[0],
                        direction: optionParts.length < 2 ? "ASC" : optionParts[1]
                    });
                });
            }
        }
        else
            newSortOptions = !!options ? options.slice(0) : [];
        this.sortOptions = newSortOptions;
    }
    _setTotalItems(items) {
        if (this._totalItems === items)
            return;
        const oldTotalItems = this._totalItems;
        this.notifyPropertyChanged("totalItems", this._totalItems = items, oldTotalItems);
        const oldLabelWithTotalItems = this._labelWithTotalItems;
        this._labelWithTotalItems = (this.totalItems != null ? this.totalItems + (this.hasMore ? "+" : "") + " " : "") + (this.totalItems !== 1 ? this.label : (this.singularLabel || this.persistentObject.label || this.persistentObject.type));
        this.notifyPropertyChanged("labelWithTotalItems", this._labelWithTotalItems, oldLabelWithTotalItems);
    }
    get isFiltering() {
        return this._isFiltering;
    }
    _updateIsFiltering() {
        let isFiltering = !!this.columns.find(c => !!c.selectedDistincts && c.selectedDistincts.length > 0);
        if (isFiltering === this._isFiltering)
            return;
        const oldIsFiltering = this._isFiltering;
        this.notifyPropertyChanged("isFiltering", this._isFiltering = isFiltering, oldIsFiltering);
    }
    _toServiceObject() {
        const result = this.copyProperties(["id", "isSystem", "name", "label", "pageSize", "skip", "top", "textSearch", "continuation"]);
        if (this.selectAll.allSelected) {
            result["allSelected"] = true;
            if (this.selectAll.inverse)
                result["allSelectedInversed"] = true;
        }
        result["sortOptions"] = this.sortOptions ? this.sortOptions.filter(option => option.direction !== "").map(option => `${option.name}${option.direction === "DESC" ? " " + option.direction : ""}`).join("; ") : "";
        if (this.groupingInfo && this.groupingInfo.groupedBy)
            result["groupedBy"] = this.groupingInfo.groupedBy;
        if (this.persistentObject)
            result.persistentObject = this.persistentObject.toServiceObject();
        result.columns = this.columns.map(col => col._toServiceObject());
        return result;
    }
    _setResult(result) {
        this._lastResult = result;
        this.continuation = result.continuation;
        this.pageSize = result.pageSize || 0;
        if (this.pageSize > 0) {
            if (result.totalItems === -1) {
                result.totalItems = (this.skip || 0) + result.items.length;
                this._setHasMore(true);
            }
            else
                this._setHasMore(false);
            this._setTotalItems(result.totalItems || 0);
            this._queriedPages.push(Math.floor((this.skip || 0) / this.pageSize));
        }
        else
            this._setTotalItems(result.items.length);
        this.hasSearched = true;
        this._updateColumns(result.columns);
        this.items = result.items.map(item => this.service.hooks.onConstructQueryResultItem(this.service, item, this));
        this._updateGroupingInfo(result.groupingInfo);
        this._setSortOptionsFromService(result.sortOptions);
        this._setTotalItem(result.totalItem != null ? this.service.hooks.onConstructQueryResultItem(this.service, result.totalItem, this) : null);
        this.setNotification(result.notification, result.notificationType, result.notificationDuration);
        if ((this._charts && this._charts.length > 0) || (result.charts && result.charts.length > 0))
            this._setCharts(result.charts.map(c => new QueryChart(this, c.label, c.name, c.options, c.type)));
        this._tag = result.tag;
        this._setLastUpdated();
    }
    getColumn(name) {
        return this.columns.find(c => c.name === name);
    }
    get items() {
        return this._items;
    }
    set items(items) {
        this.selectAll.inverse = this.selectAll.allSelected = false;
        this.selectedItems = [];
        const oldItems = this._items;
        this.notifyPropertyChanged("items", this._items = new Proxy(items, { get: this._getItemsLazy.bind(this) }), oldItems);
        this.notifyArrayChanged("items", 0, oldItems, items.length);
    }
    _getItemsLazy(target, property, receiver) {
        if (typeof property === "string") {
            const index = parseInt(property);
            if (!isNaN(index)) {
                const item = Reflect.get(target, index, receiver);
                if (item === undefined && !this.disableLazyLoading && (index < this.totalItems || this.hasMore)) {
                    if (this._queuedLazyItemIndexes)
                        this._queuedLazyItemIndexes.push(index);
                    else
                        this._queuedLazyItemIndexes = [index];
                    clearTimeout(this._queuedLazyItemIndexesTimeout);
                    this._queuedLazyItemIndexesTimeout = setTimeout(async () => {
                        const queuedLazyItemIndexes = this._queuedLazyItemIndexes.filter(i => target[i] === null);
                        if (queuedLazyItemIndexes.length === 0)
                            return;
                        try {
                            await this.getItemsByIndex(...queuedLazyItemIndexes);
                        }
                        finally {
                            queuedLazyItemIndexes.forEach(i => {
                                if (target[i] == null)
                                    delete target[i];
                            });
                        }
                    }, 10);
                    return target[index] = null;
                }
                return item;
            }
            else if (property === "length")
                return this.totalItems;
            else if (property === "forEach") {
                return (callback, thisArg) => {
                    for (const key in target) {
                        const index = parseInt(key);
                        if (!isNaN(index)) {
                            const item = target[index];
                            if (item != null)
                                callback.call(thisArg, item, index, target);
                        }
                    }
                };
            }
            else if (property === "filter") {
                return (callback, thisArg) => {
                    const result = [];
                    for (const key in target) {
                        const index = parseInt(key);
                        if (!isNaN(index)) {
                            const item = target[index];
                            if (item != null && callback.call(thisArg, item, index, target))
                                result.push(item);
                        }
                    }
                    return result;
                };
            }
            if (["push", "pop", "shift", "unshift", "splice"].indexOf(property) >= 0)
                throw "Operation not allowed";
            if (["reverse", "sort"].indexOf(property) >= 0) {
                console.log(`WARNING: '${property}' works on a copy of the array and not on the original array.`);
                return Reflect.get(Array.from(target), property, receiver);
            }
        }
        return Reflect.get(target, property, receiver);
    }
    async getItemsByIndex(...indexes) {
        if (!indexes || !indexes.length)
            return [];
        if (this.pageSize > 0) {
            const pages = indexes.sort((a, b) => a - b).reduce((acc, i) => {
                const page = Math.floor(i / this.pageSize);
                if (acc.length > 0) {
                    const last = acc[acc.length - 1];
                    if (last[0] * this.pageSize + last[1] <= i) {
                        if (last[0] * this.pageSize + last[1] + this.pageSize <= i)
                            acc.push([page, this.pageSize]);
                        else
                            last[1] += this.pageSize;
                    }
                }
                else
                    acc.push([page, this.pageSize]);
                return acc;
            }, []);
            await Promise.all(pages.map(page => this.getItems(page[0] * this.pageSize, page[1])));
        }
        return indexes.map(i => this.items[i]);
    }
    async getItems(start, length = this.pageSize, skipQueue = false) {
        if (!this.hasSearched) {
            await this.search({ delay: 0, throwExceptions: true });
            return this.getItems(start, length);
        }
        if (this.totalItems >= 0) {
            if (start > this.totalItems)
                start = this.totalItems;
            if (!this.hasMore && start + length > this.totalItems)
                length = this.totalItems - start;
        }
        if (this.pageSize <= 0 || length === 0)
            return this.items.slice(start, start + length);
        let startPage = Math.floor(start / this.pageSize);
        let endPage = Math.floor((start + length - 1) / this.pageSize);
        while (startPage < endPage && this._queriedPages.indexOf(startPage) >= 0)
            startPage++;
        while (endPage > startPage && this._queriedPages.indexOf(endPage) >= 0)
            endPage--;
        if (startPage === endPage && this._queriedPages.indexOf(startPage) >= 0)
            return this.items.slice(start, start + length);
        const clonedQuery = this.clone(this._asLookup);
        const skip = startPage * this.pageSize;
        clonedQuery.top = (endPage - startPage + 1) * this.pageSize;
        if (this.hasMore && this.items.length > 0 && this.continuation)
            clonedQuery.continuation = this.continuation;
        else
            clonedQuery.skip = skip;
        const work = async () => {
            if (!Array.range(startPage, endPage).some(p => this._queriedPages.indexOf(p) < 0))
                return this.items.slice(start, start + length);
            try {
                const result = await this.service.executeQuery(this.parent, clonedQuery, this._asLookup, true);
                if (result.totalItems === -1) {
                    this.continuation = result.continuation;
                    this._setHasMore(true);
                    result.totalItems = skip + result.items.length;
                    this._setTotalItems(result.totalItems);
                }
                else if (this.hasMore) {
                    this._setHasMore(false);
                    result.totalItems = skip + result.items.length;
                    this._setTotalItems(result.totalItems);
                }
                for (let p = startPage; p <= endPage; p++)
                    this._queriedPages.push(p);
                const isChanged = !this.hasMore && this.pageSize > 0 && result.totalItems !== this.totalItems;
                if (isChanged) {
                    this._queriedPages = [];
                    for (let i = startPage; i <= endPage; i++)
                        this._queriedPages.push(i);
                    if (!this.selectAll.allSelected) {
                        var selectedItems = {};
                        this.selectedItems.forEach(i => selectedItems[i.id] = i);
                    }
                    this.items = [];
                    this._setTotalItems(result.totalItems);
                }
                let added;
                for (let n = 0; n < clonedQuery.top && (skip + n < result.totalItems); n++) {
                    const currentItem = this.items[skip + n];
                    if (currentItem == null) {
                        const item = this.items[skip + n] = this.service.hooks.onConstructQueryResultItem(this.service, result.items[n], this);
                        if (!added)
                            added = [skip, [], 0];
                        added[1].push(currentItem);
                        added[2]++;
                        if (this.selectAll.allSelected || (selectedItems && selectedItems[item.id]))
                            item._isSelected = true;
                    }
                    else if (added) {
                        this.notifyArrayChanged("items", added[0], added[1], added[2]);
                        added = null;
                    }
                }
                if (!!added)
                    this.notifyArrayChanged("items", added[0], added[1], added[2]);
                this._updateGroupingInfo(result.groupingInfo);
                if (isChanged) {
                    const result = await this.getItems(start, length, true);
                    this.notifyPropertyChanged("items", this.items);
                    return result;
                }
                this._setLastUpdated();
                return this.items.slice(start, start + length);
            }
            catch (e) {
                this.setNotification(e);
                throw e;
            }
        };
        if (skipQueue)
            return work();
        return this.queueWork(work, false);
    }
    async search(options) {
        const selectedIds = options?.keepSelection ? this.selectedItems.map(i => i.id) : null;
        const search = () => {
            this.continuation = null;
            this._queriedPages = [];
            this.hasSearched = false;
            this._setTotalItems(null);
            this.items = [];
            const now = new Date();
            return this.queueWork(async () => {
                if (this._lastUpdated && this._lastUpdated > now)
                    return this.items;
                const result = await this.service.executeQuery(this.parent, this, this._asLookup, !!options?.throwExceptions);
                if (!result)
                    return null;
                if (!this._lastUpdated || this._lastUpdated <= now) {
                    this.hasSearched = true;
                    this._setResult(result);
                }
                return this.items;
            }, false).then(items => {
                if (selectedIds != null && selectedIds.length > 0) {
                    const newSelectionItems = selectedIds.map(id => items.find(i => i.id === id)).filter(i => i != null);
                    if (newSelectionItems.length === selectedIds.length)
                        this.selectedItems = newSelectionItems;
                }
                return items;
            });
        };
        if (options?.delay > 0) {
            const now = new Date();
            await new Promise(resolve => setTimeout(resolve, options?.delay));
            if (!this._lastUpdated || this._lastUpdated <= now)
                return search();
            else
                return this.items;
        }
        return search();
    }
    clone(asLookup = false) {
        const cloned = this.service.hooks.onConstructQuery(this.service, this, this.parent, asLookup);
        cloned.ownerAttributeWithReference = this.ownerAttributeWithReference;
        return cloned;
    }
    _updateColumns(_columns = []) {
        const oldColumns = this.columns ? this.columns.slice(0) : this.columns;
        const columns = this.columns || [];
        let columnsChanged = columns !== this.columns;
        const _columnsEnum = _columns || [];
        let i = columns.length;
        while (i--) {
            if (_columnsEnum.find(c => columns[i].name === c.name) == null) {
                let column = columns.splice(i, 1)[0];
                columns[column.name] = null;
                columnsChanged = true;
            }
        }
        _columns.forEach(c => {
            if (!columns[c.name]) {
                columns.push(columns[c.name] = this.service.hooks.onConstructQueryColumn(this.service, c, this));
                columnsChanged = true;
            }
        });
        columns.sort((c1, c2) => c1.offset - c2.offset);
        columns.forEach(c => {
            if (c.distincts)
                c.distincts.isDirty = true;
        });
        if (columnsChanged) {
            const newColumns = columns.slice();
            columns.forEach(c => newColumns[c.name] = c);
            this.notifyPropertyChanged("columns", this.columns = newColumns, oldColumns);
            if (this._columnObservers)
                this._columnObservers.forEach(c => c());
            this._columnObservers = this.columns.map(c => c.propertyChanged.attach(this._queryColumnPropertyChanged.bind(this)));
            this._updateIsFiltering();
        }
        this._setCanFilter(this.actions.some(a => a.name === "Filter") && this.columns.some(c => c.canFilter));
    }
    _updateGroupingInfo(groupingInfo) {
        if (!groupingInfo) {
            this._setGroupingInfo(null);
            return;
        }
        const currentGroupingInfo = this.groupingInfo;
        if (groupingInfo) {
            let start = 0;
            const notifier = () => this._setLastUpdated(new Date());
            this._setGroupingInfo({
                groupedBy: groupingInfo.groupedBy,
                groups: groupingInfo.groups.map(g => new QueryResultItemGroup(this, g, start, (start = start + g.count) - 1, notifier))
            });
        }
        else
            this._setGroupingInfo(null);
        if (currentGroupingInfo) {
            currentGroupingInfo.groups.forEach(oldGroup => {
                const newGroup = this.groupingInfo.groups.find(g => g.name === oldGroup.name);
                if (newGroup)
                    newGroup.isCollapsed = oldGroup.isCollapsed;
            });
        }
    }
    _queryColumnPropertyChanged(sender, args) {
        if (args.propertyName === "selectedDistincts")
            this._updateIsFiltering();
    }
    _notifyItemSelectionChanged(item) {
        if (this._isSelectionModifying)
            return;
        let selectedItems = this.selectedItems;
        if (this.maxSelectedItems && selectedItems.length > this.maxSelectedItems) {
            try {
                this._isSelectionModifying = true;
                selectedItems.filter(i => i !== item && selectedItems.length > this.maxSelectedItems).forEach(i => i.isSelected = false);
                selectedItems = this.selectedItems;
            }
            finally {
                this._isSelectionModifying = false;
            }
        }
        this._updateSelectAll(item, selectedItems);
        this.notifyPropertyChanged("selectedItems", selectedItems);
    }
    _updateSelectAll(item, selectedItems = this.selectedItems) {
        if (this.selectAll.isAvailable) {
            if (this.selectAll.allSelected) {
                if (selectedItems.length > 0)
                    this.selectAll.inverse = selectedItems.length !== this.items.filter(i => !i.ignoreSelect).length;
                else
                    this.selectAll.allSelected = this.selectAll.inverse = false;
            }
            else if (selectedItems.length === this.totalItems)
                this.selectAll.allSelected = true;
        }
    }
};

class QueryResultItemValue extends ServiceObject {
    constructor(service, _item, value) {
        super(service);
        this._item = _item;
        this.key = value.key;
        this._column = this._item.query.getColumn(this.key);
        this.value = value.value;
        this.persistentObjectId = value.persistentObjectId;
        this.objectId = value.objectId;
        this.typeHints = value.typeHints;
    }
    get item() {
        return this._item;
    }
    get column() {
        return this._column;
    }
    getTypeHint(name, defaultValue, typeHints) {
        return PersistentObjectAttribute$1.prototype.getTypeHint.apply(this, arguments);
    }
    getValue() {
        if (this._valueParsed)
            return this._value;
        this._value = Service.fromServiceString(this.value, this._item.query.getColumn(this.key).type);
        this._valueParsed = true;
        return this._value;
    }
    _toServiceObject() {
        return this.copyProperties(["key", "value", "persistentObjectId", "objectId"]);
    }
}

let _cookiePrefix;
if (document.head) {
    const base = document.head.querySelector("base");
    if (base) {
        const parser = document.createElement("a");
        parser.href = base.href;
        _cookiePrefix = parser.pathname;
    }
}
if (!_cookiePrefix)
    _cookiePrefix = document.location.pathname;
const hasStorage = (function () {
    const vi = "Vidyano";
    try {
        window.localStorage.setItem(vi, vi);
        window.localStorage.removeItem(vi);
        window.sessionStorage.setItem(vi, vi);
        window.sessionStorage.removeItem(vi);
        return true;
    }
    catch (e) {
        return false;
    }
})();
function cookiePrefix(prefix) {
    if (!!prefix)
        _cookiePrefix = prefix;
    return _cookiePrefix;
}
function cookie(key, value, options) {
    const now = new Date();
    if (arguments.length > 1 && (Object.prototype.toString.call(value) === "[object String]" || value === null || value === undefined)) {
        options = { ...options };
        if (value == null)
            options.expires = -1;
        let expires = options.expires;
        if (typeof options.expires === "number") {
            expires = new Date();
            expires.setDate(expires.getDate() + options.expires);
        }
        value = String(value);
        if (hasStorage && !options.force) {
            document.cookie = encodeURIComponent(key) + "=; expires=" + new Date(Date.parse("2000-01-01")).toUTCString();
            key = cookiePrefix() + key;
            if (expires) {
                if (expires > now)
                    window.localStorage.setItem(key, JSON.stringify({ val: options.raw ? value : encodeURIComponent(value), exp: expires.toUTCString() }));
                else
                    window.localStorage.removeItem(key);
                window.sessionStorage.removeItem(key);
            }
            else {
                window.sessionStorage.setItem(key, JSON.stringify({ val: options.raw ? value : encodeURIComponent(value) }));
                window.localStorage.removeItem(key);
            }
            return key;
        }
        else {
            return (document.cookie = [
                encodeURIComponent(key), "=",
                options.raw ? value : encodeURIComponent(value),
                options.expires ? "; expires=" + expires.toUTCString() : "",
                "; path=" + (options.path || cookiePrefix()),
                options.domain ? "; domain=" + options.domain : "",
                options.secure ? "; secure" : ""
            ].join(""));
        }
    }
    options = value || {};
    const decode = options.raw ? s => s : decodeURIComponent;
    if (hasStorage && !options.force) {
        key = cookiePrefix() + key;
        let item = window.sessionStorage.getItem(key) || window.localStorage.getItem(key);
        if (item != null) {
            item = JSON.parse(item);
            if (item.exp && new Date(item.exp) < now) {
                window.localStorage.removeItem(key);
                return key.endsWith("/authToken") ? "Expired" : null;
            }
            return decode(item.val);
        }
    }
    else {
        const parts = document.cookie.split("; ");
        for (let i = 0, part; part = parts[i]; i++) {
            const pair = part.split("=");
            if (decodeURIComponent(pair[0]) === key)
                return decode(pair[1] || "");
        }
    }
    return null;
}

var messages = {
    "EnterPassword": "Enter password",
    "EnterTwoFactorCode": "Enter two-factor code",
    "ForgotPassword": "Forgot password?",
    "Next": "Next",
    "NotYou": "Not you?",
    "Or": "Or",
    "Password": "Password",
    "Previous": "Previous",
    "Register": "New here? Create an account",
    "RegisterSave": "Register",
    "Reload": "Reload",
    "SessionLost": "You signed out in another tab or window. Reload to refresh your session.",
    "SignIn": "Sign in",
    "SignInTo": "Sign in to {0}",
    "SignInUsing": "Sign in using",
    "StaySignedIn": "Stay signed in",
    "TwoFactorCode": "Two-factor code",
    "UserName": "User name",
};

class ServiceHooks {
    get service() {
        return this._service;
    }
    createData(data) {
    }
    onFetch(request) {
        return fetch(request);
    }
    trackEvent(name, option, owner) {
    }
    onInitialize(clientData) {
        return Promise.resolve(clientData);
    }
    onSessionExpired() {
        return Promise.resolve(false);
    }
    onActionConfirmation(action, option) {
        return Promise.resolve(true);
    }
    onAction(args) {
        return Promise.resolve(null);
    }
    onActionDefinitionNotFound(name) {
        console.error(`No action definition found for ${name}`);
        return null;
    }
    async onStreamingAction(action, messages, abort) {
    }
    onOpen(obj, replaceCurrent = false, forceFromAction) {
    }
    onClose(obj) {
    }
    onConstructApplication(application) {
        return new Application(this.service, application);
    }
    onConstructPersistentObject(service, po) {
        return new PersistentObject$1(service, po);
    }
    onConstructPersistentObjectAttributeTab(service, groups, key, id, name, layout, parent, columnCount, isVisible) {
        return new PersistentObjectAttributeTab(service, groups, key, id, name, layout, parent, columnCount, isVisible);
    }
    onConstructPersistentObjectQueryTab(service, query) {
        return new PersistentObjectQueryTab(service, query);
    }
    onConstructPersistentObjectAttributeGroup(service, key, attributes, parent) {
        return new PersistentObjectAttributeGroup(service, key, attributes, parent);
    }
    onConstructPersistentObjectAttribute(service, attr, parent) {
        return new PersistentObjectAttribute$1(service, attr, parent);
    }
    onConstructPersistentObjectAttributeWithReference(service, attr, parent) {
        return new PersistentObjectAttributeWithReference(service, attr, parent);
    }
    onConstructPersistentObjectAttributeAsDetail(service, attr, parent) {
        return new PersistentObjectAttributeAsDetail$1(service, attr, parent);
    }
    onConstructQuery(service, query, parent, asLookup = false, maxSelectedItems) {
        return new Query$1(service, query, parent, asLookup, maxSelectedItems);
    }
    onConstructQueryResultItem(service, item, query, isSelected = false) {
        return new QueryResultItem(service, item, query, isSelected);
    }
    onConstructQueryResultItemValue(service, item, value) {
        return new QueryResultItemValue(service, item, value);
    }
    onConstructQueryColumn(service, col, query) {
        return new QueryColumn(service, col, query);
    }
    onConstructAction(service, action) {
        return action;
    }
    onSortPersistentObjectTabs(parent, attributeTabs, queryTabs) {
        return attributeTabs.concat(queryTabs);
    }
    onMessageDialog(title, message, rich, ...actions) {
        return Promise.resolve(-1);
    }
    onShowNotification(notification, type, duration) {
    }
    onSelectReference(query) {
        return Promise.resolve([]);
    }
    onNavigate(path, replaceCurrent = false) {
    }
    onClientOperation(operation) {
        switch (operation.type) {
            case "ExecuteMethod":
                const executeMethod = operation;
                const method = ClientOperations[executeMethod.name];
                if (typeof (method) === "function") {
                    method.apply(ClientOperations, [this].concat(executeMethod.arguments));
                }
                else if (window.console && console.error)
                    console.error("Method not found: " + executeMethod.name, executeMethod);
                break;
            case "Open":
                const open = operation;
                this.onOpen(this.onConstructPersistentObject(this.service, open.persistentObject), open.replace);
                break;
            default:
                if (window.console && console.log)
                    console.log("Missing client operation type: " + operation.type, operation);
                break;
        }
    }
    onSelectedItemsActions(query, selectedItems, action) {
    }
    onRefreshFromResult(po) {
    }
    onUpdateAvailable() {
        localStorage.setItem("vi-updateAvailable", cookiePrefix());
        localStorage.removeItem("vi-updateAvailable");
    }
    onRetryAction(retry) {
        return Promise.resolve(null);
    }
    onGetAttributeDisplayValue(attribute, value) {
        return undefined;
    }
    setDefaultTranslations(languages) {
        languages.forEach(lang => {
            Object.keys(messages).forEach(key => {
                if (!lang.messages.hasOwnProperty(key)) {
                    lang.messages[key] = messages[key];
                }
            });
        });
    }
}

class NoInternetMessage {
    constructor(language, title, message, tryAgain) {
        this.language = language;
        this.title = title;
        this.message = message;
        this.tryAgain = tryAgain;
    }
}
NoInternetMessage.messages = Object.assign({}, ...[
    new NoInternetMessage("en", "Unable to connect to the server.", "Please check your internet connection settings and try again.", "Try again"),
    new NoInternetMessage("ar", "غير قادر على الاتصال بالخادم", "يرجى التحقق من إعدادات الاتصال بإنترنت ثم حاول مرة أخرى", "حاول مرة أخرى"),
    new NoInternetMessage("bg", "Не може да се свърже със сървъра", "Проверете настройките на интернет връзката и опитайте отново", "Опитайте отново"),
    new NoInternetMessage("ca", "No es pot connectar amb el servidor", "Si us plau aturi les seves escenes de connexió d'internet i provi una altra vegada", "Provi una altra vegada"),
    new NoInternetMessage("cs", "Nelze se připojit k serveru", "Zkontrolujte nastavení připojení k Internetu a akci opakujte", "Zkuste to znovu"),
    new NoInternetMessage("da", "Kunne ikke oprettes forbindelse til serveren", "Kontroller indstillingerne for internetforbindelsen, og prøv igen", "Prøv igen"),
    new NoInternetMessage("nl", "Kan geen verbinding maken met de server", "Controleer de instellingen van uw internet-verbinding en probeer opnieuw", "Opnieuw proberen"),
    new NoInternetMessage("et", "Ei saa ühendust serveriga", "Palun kontrollige oma Interneti-ühenduse sätteid ja proovige uuesti", "Proovi uuesti"),
    new NoInternetMessage("fa", "قادر به اتصال به سرویس دهنده", "لطفاً تنظیمات اتصال اینترنت را بررسی کرده و دوباره سعی کنید", "دوباره امتحان کن"),
    new NoInternetMessage("fi", "Yhteyttä palvelimeen", "Tarkista internet-yhteysasetukset ja yritä uudelleen", "Yritä uudestaan"),
    new NoInternetMessage("fr", "Impossible de se connecter au serveur", "S'il vous plaît vérifier vos paramètres de connexion internet et réessayez", "Réessayez"),
    new NoInternetMessage("de", "Keine Verbindung zum Server herstellen", "Überprüfen Sie die Einstellungen für die Internetverbindung und versuchen Sie es erneut", "Wiederholen"),
    new NoInternetMessage("el", "Δεν είναι δυνατή η σύνδεση με το διακομιστή", "Ελέγξτε τις ρυθμίσεις σύνδεσης στο internet και προσπαθήστε ξανά", "Δοκίμασε ξανά"),
    new NoInternetMessage("ht", "Pat kapab pou li konekte li pou sèvè a", "Souple tcheke ou paramètres kouche sou entènèt Et eseye ankò", "eseye ankò"),
    new NoInternetMessage("he", "אין אפשרות להתחבר לשרת", "נא בדוק את הגדרות החיבור לאינטרנט ונסה שוב", "נסה שוב"),
    new NoInternetMessage("hi", "सर्वर से कनेक्ट करने में असमर्थ", "कृपया अपना इंटरनेट कनेक्शन सेटिंग्स की जाँच करें और पुन: प्रयास करें", "फिर कोशिश करो"),
    new NoInternetMessage("hu", "Nem lehet kapcsolódni a szerverhez", "Kérjük, ellenőrizze az internetes kapcsolat beállításait, és próbálja újra", "próbáld újra"),
    new NoInternetMessage("id", "Tidak dapat terhubung ke server", "Silakan periksa setelan sambungan internet Anda dan coba lagi", "Coba lagi"),
    new NoInternetMessage("it", "Impossibile connettersi al server", "Si prega di controllare le impostazioni della connessione internet e riprovare", "Riprova"),
    new NoInternetMessage("ja", "サーバーに接続できません。", "インターネット接続設定を確認して、やり直してください。", "もう一度やり直してください"),
    new NoInternetMessage("ko", "서버에 연결할 수 없습니다.", "인터넷 연결 설정을 확인 하 고 다시 시도 하십시오", "다시 시도"),
    new NoInternetMessage("lv", "Nevar izveidot savienojumu ar serveri", "Lūdzu, pārbaudiet interneta savienojuma iestatījumus un mēģiniet vēlreiz", "mēģini vēlreiz"),
    new NoInternetMessage("lt", "Nepavyko prisijungti prie serverio", "Patikrinkite interneto ryšio parametrus ir bandykite dar kartą", "pabandyk dar kartą"),
    new NoInternetMessage("no", "Kan ikke koble til serveren", "Kontroller innstillingene for Internett-tilkoblingen og prøv igjen", "prøv igjen"),
    new NoInternetMessage("pl", "Nie można połączyć się z serwerem", "Proszę sprawdzić ustawienia połączenia internetowego i spróbuj ponownie", "Próbuj ponownie"),
    new NoInternetMessage("pt", "Incapaz de conectar ao servidor", "Por favor, verifique as suas configurações de ligação à internet e tente novamente", "Tentar novamente"),
    new NoInternetMessage("ro", "Imposibil de conectat la server", "Vă rugăm să verificaţi setările de conexiune la internet şi încercaţi din nou", "încearcă din nou"),
    new NoInternetMessage("ru", "Не удается подключиться к серверу", "Пожалуйста, проверьте параметры подключения к Интернету и повторите попытку", "Повторить"),
    new NoInternetMessage("sk", "Nedá sa pripojiť k serveru", "Skontrolujte nastavenie internetového pripojenia a skúste to znova", "skús znova"),
    new NoInternetMessage("sl", "Ne morem se povezati s strežnikom", "Preverite nastavitve internetne povezave in poskusite znova", "poskusi znova"),
    new NoInternetMessage("es", "No se puede conectar al servidor", "Por favor, compruebe la configuración de conexión a internet e inténtelo de nuevo", "Vuelve a intentarlo"),
    new NoInternetMessage("sv", "Det gick inte att ansluta till servern", "Kontrollera inställningarna för Internetanslutningen och försök igen", "Försök igen"),
    new NoInternetMessage("th", "สามารถเชื่อมต่อกับเซิร์ฟเวอร์", "กรุณาตรวจสอบการตั้งค่าการเชื่อมต่ออินเทอร์เน็ตของคุณ และลองอีกครั้ง", "ลองอีกครั้ง"),
    new NoInternetMessage("tr", "Sunucuya bağlantı kurulamıyor", "Lütfen Internet bağlantı ayarlarınızı denetleyin ve yeniden deneyin", "Yeniden Deneyin"),
    new NoInternetMessage("uk", "Не вдалося підключитися до сервера", "Перевірте параметри підключення до Інтернету та повторіть спробу", "Спробуй ще раз"),
    new NoInternetMessage("vi", "Không thể kết nối đến máy chủ", "Hãy kiểm tra cài đặt kết nối internet của bạn và thử lại", "Thử lại")
].map(m => ({ [m.language]: m })));

class ExecuteActionArgs {
    constructor(service, action, persistentObject, query, selectedItems, parameters) {
        this.service = service;
        this.persistentObject = persistentObject;
        this.query = query;
        this.selectedItems = selectedItems;
        this.parameters = parameters;
        this.isHandled = false;
        this._action = action;
        this.action = action.split(".")[1];
    }
    async executeServiceRequest() {
        this.result = await this.service.executeAction(this._action, this.persistentObject, this.query, this.selectedItems, this.parameters, true);
        this.isHandled = true;
        return this.result;
    }
}

class DataType {
    static isDateTimeType(type) {
        return [
            "NullableDate",
            "Date",
            "NullableTime",
            "Time",
            "NullableDateTime",
            "DateTime",
            "NullableDateTimeOffset",
            "DateTimeOffset"
        ].indexOf(type) >= 0;
    }
    static isNumericType(type) {
        return [
            "NullableDecimal",
            "Decimal",
            "NullableSingle",
            "Single",
            "NullableDouble",
            "Double",
            "NullableInt64",
            "Int64",
            "NullableUInt64",
            "UInt64",
            "NullableInt32",
            "Int32",
            "NullableUInt32",
            "UInt32",
            "NullableInt16",
            "Int16",
            "NullableUInt16",
            "UInt16",
            "NullableByte",
            "Byte",
            "NullableSByte",
            "SByte"
        ].indexOf(type) >= 0;
    }
    static isBooleanType(type) {
        return [
            "Boolean",
            "YesNo",
            "NullableBoolean"
        ].indexOf(type) >= 0;
    }
    static fromServiceString(value, type) {
        switch (type) {
            case "Decimal":
            case "Single":
            case "Double":
            case "Int64":
            case "UInt64":
                if (String.isNullOrEmpty(value))
                    return new BigNumber(0);
                return new BigNumber(value);
            case "NullableDecimal":
            case "NullableSingle":
            case "NullableDouble":
            case "NullableInt64":
            case "NullableUInt64":
                if (String.isNullOrEmpty(value))
                    return null;
                return new BigNumber(value);
            case "Int16":
            case "UInt16":
            case "Int32":
            case "UInt32":
            case "Byte":
            case "SByte":
                if (String.isNullOrEmpty(value))
                    return 0;
                return parseInt(value, 10);
            case "NullableInt16":
            case "NullableInt32":
            case "NullableUInt16":
            case "NullableUInt32":
            case "NullableByte":
            case "NullableSByte":
                if (String.isNullOrEmpty(value))
                    return null;
                return parseInt(value, 10);
            case "Date":
            case "NullableDate":
            case "DateTime":
            case "NullableDateTime":
            case "DateTimeOffset":
            case "NullableDateTimeOffset":
                if (!String.isNullOrEmpty(value) && value.length >= 19) {
                    const parts = value.split(" ");
                    const date = parts[0].split("-");
                    const time = parts[1].split(":");
                    const dateTime = DataType._getDate(date[2], date[1], date[0], time[0], time[1], time[2].substring(0, 2), time[2].length > 2 ? time[2].substr(3, 3) : null);
                    if (parts.length === 3) {
                        dateTime.netType("DateTimeOffset");
                        dateTime.netOffset(parts[2]);
                    }
                    return dateTime;
                }
                const now = new Date();
                if (type === "Date") {
                    now.setHours(0, 0, 0, 0);
                    return now;
                }
                else if (type === "DateTime")
                    return now;
                else if (type === "DateTimeOffset") {
                    now.netType("DateTimeOffset");
                    const zone = now.getTimezoneOffset() * -1;
                    const zoneHour = zone / 60;
                    const zoneMinutes = zone % 60;
                    now.netOffset(String.format("{0}{1:D2}:{2:D2}", zone < 0 ? "-" : "+", zoneHour, zoneMinutes));
                    return now;
                }
                return null;
            case "Time":
            case "NullableTime":
                return DataType.toServiceString(value, type);
            case "Boolean":
            case "NullableBoolean":
            case "YesNo":
                return value != null ? Boolean.parse(value) : null;
            default:
                return value;
        }
    }
    static toServiceString(value, type) {
        switch (type) {
            case "NullableDecimal":
            case "Decimal":
            case "NullableSingle":
            case "Single":
            case "NullableDouble":
            case "Double":
            case "NullableInt64":
            case "Int64":
            case "NullableUInt64":
            case "UInt64":
            case "NullableInt32":
            case "Int32":
            case "NullableUInt32":
            case "UInt32":
            case "NullableInt16":
            case "Int16":
            case "NullableUInt16":
            case "UInt16":
            case "NullableByte":
            case "Byte":
            case "NullableSByte":
            case "SByte":
                if (String.isNullOrEmpty(value) && !type.startsWith("Nullable"))
                    return "0";
                break;
            case "Date":
            case "NullableDate":
                if (!String.isNullOrEmpty(value)) {
                    let date = value;
                    if (typeof (date) === "string")
                        date = new Date(value);
                    return `${date.format("dd-MM-yyyy")} 00:00:00`;
                }
                break;
            case "DateTime":
            case "NullableDateTime":
                if (!String.isNullOrEmpty(value)) {
                    let date = value;
                    if (typeof (date) === "string")
                        date = new Date(value);
                    return date.format("dd-MM-yyyy HH:mm:ss.fff").trimEnd("0").trimEnd(".");
                }
                break;
            case "DateTimeOffset":
            case "NullableDateTimeOffset":
                if (!String.isNullOrEmpty(value)) {
                    let dateOffset = value;
                    if (typeof (value) === "string") {
                        if (value.length >= 23 && value.length <= 30) {
                            const dateParts = value.split(" ");
                            dateOffset = new Date(dateParts[0] + " " + dateParts[1]);
                            dateOffset.netOffset(dateParts[2]);
                            dateOffset.netType("DateTimeOffset");
                        }
                        else
                            return null;
                    }
                    return dateOffset.format("dd-MM-yyyy HH:mm:ss") + " " + (dateOffset.netOffset() || "+00:00");
                }
                break;
            case "Boolean":
            case "NullableBoolean":
            case "YesNo":
                if (value == null)
                    return null;
                if (typeof (value) === "string")
                    value = Boolean.parse(value);
                return value ? "True" : "False";
            case "Time":
                return DataType._getServiceTimeString(value, "0:00:00:00.0000000");
            case "NullableTime":
                return DataType._getServiceTimeString(value, null);
        }
        return typeof (value) === "string" || value == null ? value : String(value);
    }
}
DataType._getDate = function (yearString, monthString, dayString, hourString, minuteString, secondString, msString) {
    const year = parseInt(yearString, 10);
    const month = parseInt(monthString || "1", 10) - 1;
    const day = parseInt(dayString || "1", 10);
    const hour = parseInt(hourString || "0", 10);
    const minutes = parseInt(minuteString || "0", 10);
    const seconds = parseInt(secondString || "0", 10);
    const ms = parseInt(msString || "0", 10);
    return new Date(year, month, day, hour, minutes, seconds, ms);
};
DataType._getServiceTimeString = function (timeString, defaultValue) {
    if (!String.isNullOrWhiteSpace(timeString)) {
        timeString = timeString.trim();
        let ms = "0000000";
        const parts = timeString.split(".");
        if (parts.length === 2) {
            ms = parts[1];
            timeString = parts[0];
        }
        else if (parts.length !== 1)
            return defaultValue;
        const length = timeString.length;
        if (length >= 4) {
            const values = timeString.split(":"), valuesLen = values.length;
            let days = 0, hours, minutes, seconds = 0;
            if ((length === 4 || length === 5) && valuesLen === 2) {
                hours = parseInt(values[0], 10);
                minutes = parseInt(values[1], 10);
            }
            else if ((length === 7 || length === 8) && valuesLen === 3) {
                hours = parseInt(values[0], 10);
                minutes = parseInt(values[1], 10);
                seconds = parseInt(values[2], 10);
            }
            else if (length >= 10 && valuesLen === 4) {
                days = parseInt(values[0], 10);
                hours = parseInt(values[1], 10);
                minutes = parseInt(values[2], 10);
                seconds = parseInt(values[3], 10);
            }
            else
                return defaultValue;
            if (!isNaN(days) && !isNaN(hours) && !isNaN(minutes) && !isNaN(seconds) && days >= 0 && hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59 && seconds >= 0 && seconds <= 59)
                return String.format("{0}:{1:d2}:{2:d2}:{3:d2}.{4}", days, hours, minutes, seconds, ms.padRight(7, "0"));
        }
    }
    return defaultValue;
};

Actions.CancelEdit = class CancelEdit extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = this.parent.isEditing;
        this.canExecute = this.parent.stateBehavior.indexOf("StayInEdit") < 0 || this.parent.isDirty;
    }
    _onParentIsEditingChanged(isEditing) {
        this.isVisible = isEditing;
    }
    _onParentIsDirtyChanged(isDirty) {
        this.canExecute = this.parent.stateBehavior.indexOf("StayInEdit") < 0 || isDirty;
    }
    _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        this.parent.cancelEdit();
        return Promise.resolve(null);
    }
};
Actions.CancelSave = class CancelSave extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
    }
    _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        this.service.hooks.onClose(this.parent);
        return Promise.resolve(null);
    }
};
Actions.Edit = class Edit extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = !this.parent.isEditing;
        this.dependentActions = ["EndEdit", "CancelEdit"];
    }
    _onParentIsEditingChanged(isEditing) {
        this.isVisible = !isEditing;
    }
    _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        this.parent.beginEdit();
        return Promise.resolve(null);
    }
};
Actions.EndEdit = class EndEdit extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = this.parent.isEditing;
        this.canExecute = this.parent.isDirty;
    }
    _onParentIsEditingChanged(isEditing) {
        this.isVisible = isEditing;
    }
    _onParentIsDirtyChanged(isDirty) {
        this.canExecute = isDirty;
    }
    async _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        await this.parent.save();
        if (String.isNullOrWhiteSpace(this.parent.notification) || this.parent.notificationType !== "Error") {
            const edit = this.parent.actions["Edit"];
            const endEdit = this.parent.actions["EndEdit"];
            if (this.parent.stateBehavior.indexOf("StayInEdit") !== -1 && endEdit != null) {
                endEdit.canExecute = false;
            }
            else if (edit) {
                edit.isVisible = true;
                if (endEdit != null)
                    endEdit.isVisible = false;
            }
        }
        return this.parent;
    }
};
Actions.ExportToCsv = class ExportToCsv extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
    }
    _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        this.service.getStream(null, "Query.ExportToCsv", this.parent, this.query, null, this._getParameters(parameters, menuOption));
        return Promise.resolve(null);
    }
};
Actions.ExportToExcel = class ExportToExcel extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
    }
    _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        this.service.getStream(null, "Query.ExportToExcel", this.parent, this.query, null, this._getParameters(parameters, menuOption));
        return Promise.resolve(null);
    }
};
Actions.Filter = class Filter extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = false;
    }
};
Actions.RefreshQuery = class RefreshQuery extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = false;
    }
    _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        return this.query.search();
    }
};
Actions.Save = class Save extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.dependentActions = ["CancelSave"];
        this.canExecute = this.parent.isDirty || this.parent.isNew;
    }
    _onParentIsDirtyChanged(isDirty) {
        this.canExecute = isDirty;
    }
    async _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        const wasNew = this.parent.isNew;
        await this.parent.save();
        if (this.service.queuedClientOperations.length > 0 &&
            this.service.queuedClientOperations.some(o => {
                if (o.type === "Open") {
                    o.replace = this.parent.stateBehavior.indexOf("Dialog") === -1;
                    return true;
                }
                else if (o.type === "ExecuteMethod") {
                    const eo = o;
                    if (eo.name === "navigate") {
                        eo.arguments[1] = true;
                        return true;
                    }
                }
                return false;
            }))
            return this.parent;
        if (String.isNullOrWhiteSpace(this.parent.notification) || this.parent.notificationType !== "Error") {
            if (wasNew && this.parent.ownerAttributeWithReference == null && this.parent.stateBehavior.indexOf("OpenAfterNew") !== -1) {
                const newPO = await this.parent.queueWork(() => this.service.getPersistentObject(this.parent.parent, this.parent.id, this.parent.objectId));
                newPO.ownerQuery = this.parent.ownerQuery;
                this.service.hooks.onOpen(newPO, true);
            }
            else
                this.service.hooks.onClose(this.parent);
        }
        return this.parent;
    }
};
Actions.ShowHelp = class ShowHelp extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
    }
    async _onExecute({ menuOption, parameters, selectedItems, skipOpen, noConfirmation, throwExceptions }) {
        const owner = this.query ? this.query.persistentObject : this.parent;
        const helpWindow = window.open();
        try {
            const po = await this.service.executeAction("PersistentObject.ShowHelp", owner, null, null);
            if (po != null) {
                if (po.fullTypeName === "Vidyano.RegisteredStream" || po.getAttributeValue("Type") === "0") {
                    helpWindow.close();
                    this.service.getStream(po);
                }
                else {
                    helpWindow.location.href = po.getAttributeValue("Document");
                    helpWindow.focus();
                }
            }
            else
                helpWindow.close();
        }
        catch (e) {
            helpWindow.close();
            this.owner.setNotification(e);
        }
        return null;
    }
};
Actions.viConfigurePO = class viConfigurePO extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = false;
    }
};
Actions.viConfigureQuery = class viConfigureQuery extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = false;
    }
};
Actions.viSearch = class viSearch extends Action {
    constructor(service, definition, owner) {
        super(service, definition, owner);
        this.isVisible = this.parent == null || this.parent.fullTypeName === "Vidyano.Search";
        if (this.parent != null && this.parent.fullTypeName === "Vidyano.Search")
            this._isPinned = false;
    }
};

async function getBytes(stream, onChunk) {
    const reader = stream.getReader();
    let result;
    while (!(result = await reader.read()).done) {
        onChunk(result.value);
    }
}
function getLines(onLine) {
    let buffer;
    let position;
    let fieldLength;
    let discardTrailingNewline = false;
    return function onChunk(arr) {
        if (buffer === undefined) {
            buffer = arr;
            position = 0;
            fieldLength = -1;
        }
        else {
            buffer = concat(buffer, arr);
        }
        const bufLength = buffer.length;
        let lineStart = 0;
        while (position < bufLength) {
            if (discardTrailingNewline) {
                if (buffer[position] === 10) {
                    lineStart = ++position;
                }
                discardTrailingNewline = false;
            }
            let lineEnd = -1;
            for (; position < bufLength && lineEnd === -1; ++position) {
                switch (buffer[position]) {
                    case 58:
                        if (fieldLength === -1) {
                            fieldLength = position - lineStart;
                        }
                        break;
                    case 13:
                        discardTrailingNewline = true;
                    case 10:
                        lineEnd = position;
                        break;
                }
            }
            if (lineEnd === -1) {
                break;
            }
            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
            lineStart = position;
            fieldLength = -1;
        }
        if (lineStart === bufLength) {
            buffer = undefined;
        }
        else if (lineStart !== 0) {
            buffer = buffer.subarray(lineStart);
            position -= lineStart;
        }
    };
}
function getMessages(onId, onRetry, onMessage) {
    let message = newMessage();
    const decoder = new TextDecoder();
    return function onLine(line, fieldLength) {
        if (line.length === 0) {
            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
            message = newMessage();
        }
        else if (fieldLength > 0) {
            const field = decoder.decode(line.subarray(0, fieldLength));
            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
            const value = decoder.decode(line.subarray(valueOffset));
            switch (field) {
                case 'data':
                    message.data = message.data
                        ? message.data + '\n' + value
                        : value;
                    break;
                case 'event':
                    message.event = value;
                    break;
                case 'id':
                    onId(message.id = value);
                    break;
                case 'retry':
                    const retry = parseInt(value, 10);
                    if (!isNaN(retry)) {
                        onRetry(message.retry = retry);
                    }
                    break;
            }
        }
    };
}
function concat(a, b) {
    const res = new Uint8Array(a.length + b.length);
    res.set(a);
    res.set(b, a.length);
    return res;
}
function newMessage() {
    return {
        data: '',
        event: '',
        id: '',
        retry: undefined,
    };
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const EventStreamContentType = 'text/event-stream';
const DefaultRetryInterval = 1000;
const LastEventId = 'last-event-id';
function fetchEventSource(input, _a) {
    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
    return new Promise((resolve, reject) => {
        const headers = Object.assign({}, inputHeaders);
        if (!headers.accept) {
            headers.accept = EventStreamContentType;
        }
        let curRequestController;
        function onVisibilityChange() {
            curRequestController.abort();
            if (!document.hidden) {
                create();
            }
        }
        if (!openWhenHidden) {
            document.addEventListener('visibilitychange', onVisibilityChange);
        }
        let retryInterval = DefaultRetryInterval;
        let retryTimer = 0;
        function dispose() {
            document.removeEventListener('visibilitychange', onVisibilityChange);
            window.clearTimeout(retryTimer);
            curRequestController.abort();
        }
        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {
            dispose();
            resolve();
        });
        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
        async function create() {
            var _a;
            curRequestController = new AbortController();
            try {
                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
                await onopen(response);
                await getBytes(response.body, getLines(getMessages(id => {
                    if (id) {
                        headers[LastEventId] = id;
                    }
                    else {
                        delete headers[LastEventId];
                    }
                }, retry => {
                    retryInterval = retry;
                }, onmessage)));
                onclose === null || onclose === void 0 ? void 0 : onclose();
                dispose();
                resolve();
            }
            catch (err) {
                if (!curRequestController.signal.aborted) {
                    try {
                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;
                        window.clearTimeout(retryTimer);
                        retryTimer = window.setTimeout(create, interval);
                    }
                    catch (innerErr) {
                        dispose();
                        reject(innerErr);
                    }
                }
            }
        }
        create();
    });
}
function defaultOnOpen(response) {
    const contentType = response.headers.get('content-type');
    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {
        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
    }
}

let version$2 = "3.19.3";
class Service extends Observable {
    constructor(serviceUri, hooks = new ServiceHooks(), isTransient = false) {
        super();
        this.serviceUri = serviceUri;
        this.hooks = hooks;
        this.isTransient = isTransient;
        this._lastAuthTokenUpdate = new Date();
        this._queuedClientOperations = [];
        this.actionDefinitions = {};
        this.environment = "Web";
        this.environmentVersion = "3";
        this.hooks._service = this;
        if (!isTransient)
            this.staySignedIn = cookie("staySignedIn", { force: true }) === "true";
    }
    static set token(token) {
        Service._token = token;
    }
    _createUri(method) {
        let uri = this.serviceUri;
        if (!String.isNullOrEmpty(uri) && !uri.endsWith("/"))
            uri += "/";
        return uri + method;
    }
    _createData(method, data) {
        data = data || {};
        data.clientVersion = version$2;
        data.environment = this.environment;
        data.environmentVersion = this.environmentVersion;
        if (method !== "getApplication") {
            data.userName = this.userName;
            if (data.userName !== this.defaultUserName)
                data.authToken = this.authToken;
        }
        const requestedLanguage = this.requestedLanguage;
        if (requestedLanguage != null)
            data.requestedLanguage = requestedLanguage;
        if (this.application && this.application.session)
            data.session = this.application.session.toServiceObject(true);
        if (this.profile)
            data.profile = true;
        this.hooks.createData(data);
        return data;
    }
    async _fetch(request) {
        let response;
        do {
            response = await this.hooks.onFetch(request);
            if (response.status !== 429)
                return response;
            const retryAfter = response.headers?.get("Retry-After") || "5";
            let seconds = parseInt(retryAfter) * 1000;
            if (Number.isNaN(seconds)) {
                const when = new Date(retryAfter).getTime();
                if (!Number.isNaN(when))
                    seconds = Math.max(0, when - new Date().getTime());
            }
            await sleep$1(seconds || 5000);
        } while (true);
    }
    async _getJSON(url, headers) {
        const request = new Request(url, {
            method: "GET",
            headers: headers != null ? new Headers(headers) : undefined
        });
        try {
            const response = await this._fetch(request);
            if (response.ok)
                return await response.json();
            throw response.text;
        }
        catch (e) {
            throw e || (NoInternetMessage.messages[navigator.language.split("-")[0].toLowerCase()] || NoInternetMessage.messages["en"]).message;
        }
    }
    async _postJSON(url, data) {
        const createdRequest = new Date();
        let requestStart;
        let requestMethod;
        if (this.profile) {
            requestStart = window.performance.now();
            requestMethod = url.split("/").pop();
        }
        const headers = new Headers();
        if (this.authTokenType === "JWT") {
            headers.set("Authorization", "bearer " + this.authToken.substring(4));
            if (data) {
                delete data.userName;
                delete data.authToken;
            }
        }
        let body;
        if (!data.__form_data) {
            headers.append("Content-type", "application/json");
            body = JSON.stringify(data);
        }
        else {
            const formData = data.__form_data;
            delete data.__form_data;
            formData.set("data", JSON.stringify(data));
            body = formData;
        }
        if (typeof data.action === "string") {
            const action = data.action.split(".", 2).pop();
            const definition = this.actionDefinitions[action];
            if (definition?.isStreaming) {
                let cancel;
                let signal;
                let awaiter = new Promise((resolve, reject) => {
                    signal = resolve;
                    cancel = reject;
                });
                const abortController = new AbortController();
                const messages = [];
                const iterator = async function* () {
                    try {
                        while (true) {
                            await awaiter;
                            while (messages.length > 0) {
                                const message = messages.shift();
                                if (!!message.data)
                                    yield message.data;
                            }
                        }
                    }
                    catch { }
                };
                this.hooks.onStreamingAction(action, iterator, () => abortController.abort());
                fetchEventSource(url, {
                    method: "POST",
                    headers: Array.from(headers.entries()).reduce((headers, [key, value]) => {
                        headers[key] = value;
                        return headers;
                    }, {}),
                    body: body,
                    signal: abortController.signal,
                    onmessage: (e) => {
                        messages.push(e);
                        signal();
                        awaiter = new Promise((resolve, reject) => {
                            signal = resolve;
                            cancel = reject;
                        });
                    },
                    onclose: () => cancel(),
                    onerror: () => {
                        cancel();
                        return null;
                    },
                    openWhenHidden: true
                });
                await awaiter;
                return;
            }
        }
        try {
            const response = await this._fetch(new Request(url, {
                method: "POST",
                headers: headers,
                body: body
            }));
            if (!response.ok)
                throw response.statusText;
            let result;
            if (response.headers.get("content-type")?.contains("application/json"))
                result = await response.json();
            else if (response.headers.get("content-type") === "text/html") {
                const regex = /({(.*)+)</gm;
                result = JSON.parse(regex.exec(await response.text())[1]);
            }
            else
                throw "Invalid content-type";
            try {
                if (result.exception == null)
                    result.exception = result.ExceptionMessage;
                if (result.exception == null) {
                    if (createdRequest > this._lastAuthTokenUpdate && this.authTokenType !== "JWT") {
                        this.authToken = result.authToken;
                        this._lastAuthTokenUpdate = createdRequest;
                    }
                    if (this.application)
                        this.application._updateSession(result.session);
                    return result;
                }
                else if (result.exception === "Session expired") {
                    this.authToken = null;
                    delete data.authToken;
                    if (this.defaultUserName && this.defaultUserName === this.userName) {
                        delete data.password;
                        return await this._postJSON(url, data);
                    }
                    else if (!await this.hooks.onSessionExpired())
                        throw result.exception;
                    else if (this.defaultUserName) {
                        delete data.password;
                        data.userName = this.defaultUserName;
                        return await this._postJSON(url, data);
                    }
                    else
                        throw result.exception;
                }
                else
                    throw result.exception;
            }
            finally {
                this._postJSONProcess(data, result, requestMethod, createdRequest, requestStart, result.profiler ? response.headers.get("X-ElapsedMilliseconds") : undefined);
            }
        }
        catch (e) {
            throw e || (NoInternetMessage.messages[navigator.language.split("-")[0].toLowerCase()] || NoInternetMessage.messages["en"]).message;
        }
    }
    _postJSONProcess(data, result, requestMethod, createdRequest, requestStart, elapsedMs) {
        if (this.profile && result.profiler) {
            const requestEnd = window.performance.now();
            if (!result.profiler) {
                result.profiler = { elapsedMilliseconds: -1 };
                if (result.exception)
                    result.profiler.exceptions = [result.exception];
            }
            if (elapsedMs)
                result.profiler.elapsedMilliseconds = Service.fromServiceString(elapsedMs, "Int32");
            const request = {
                when: createdRequest,
                profiler: result.profiler,
                transport: Math.round(requestEnd - requestStart - result.profiler.elapsedMilliseconds),
                method: requestMethod,
                request: data,
                response: result
            };
            const requests = this.profiledRequests || [];
            requests.unshift(request);
            this._setProfiledRequests(requests.slice(0, 20));
        }
        if (result.operations) {
            this._queuedClientOperations.push(...result.operations);
            result.operations = null;
        }
        if (this._queuedClientOperations.length > 0) {
            setTimeout(() => {
                let operation;
                while (operation = this._queuedClientOperations.splice(0, 1)[0])
                    this.hooks.onClientOperation(operation);
            }, 0);
        }
    }
    get queuedClientOperations() {
        return this._queuedClientOperations;
    }
    get application() {
        return this._application;
    }
    _setApplication(application) {
        if (this._application === application)
            return;
        const oldApplication = this._application;
        this.notifyPropertyChanged("application", this._application = application, oldApplication);
        if (this._application && this._application.canProfile)
            this.profile = !!Boolean$1.parse(cookie("profile"));
        else
            this.profile = false;
    }
    get initial() {
        return this._initial;
    }
    get language() {
        return this._language;
    }
    set language(l) {
        if (this._language === l)
            return;
        const oldLanguage = this._language;
        this.notifyPropertyChanged("language", this._language = l, oldLanguage);
    }
    get requestedLanguage() {
        return cookie("requestedLanguage");
    }
    set requestedLanguage(val) {
        if (this.requestedLanguage === val)
            return;
        cookie("requestedLanguage", val);
    }
    get isSignedIn() {
        return this._isSignedIn;
    }
    _setIsSignedIn(val) {
        const oldIsSignedIn = this._isSignedIn;
        this._isSignedIn = val;
        const oldIsUsingDefaultCredentials = this._isUsingDefaultCredentials;
        this._isUsingDefaultCredentials = this.defaultUserName && this.userName && this.defaultUserName.toLowerCase() === this.userName.toLowerCase();
        if (oldIsSignedIn !== this._isSignedIn)
            this.notifyPropertyChanged("isSignedIn", this._isSignedIn, oldIsSignedIn);
        if (oldIsSignedIn !== this._isUsingDefaultCredentials)
            this.notifyPropertyChanged("isUsingDefaultCredentials", this._isUsingDefaultCredentials, oldIsUsingDefaultCredentials);
    }
    get languages() {
        return this._languages;
    }
    get windowsAuthentication() {
        return this._windowsAuthentication;
    }
    get providers() {
        return this._providers;
    }
    get isUsingDefaultCredentials() {
        return this._isUsingDefaultCredentials;
    }
    get userName() {
        return !this.isTransient ? cookie("userName") : this._userName;
    }
    set userName(val) {
        const oldUserName = this.userName;
        if (oldUserName === val)
            return;
        if (!this.isTransient)
            cookie("userName", val, { expires: this.staySignedIn ? 365 : 30 });
        else
            this._userName = val;
        this.notifyPropertyChanged("userName", val, oldUserName);
    }
    get defaultUserName() {
        return !!this._clientData ? this._clientData.defaultUser || null : null;
    }
    get registerUserName() {
        return !!this._providers && this._providers["Vidyano"] ? this._providers["Vidyano"].registerUser || null : null;
    }
    get authToken() {
        return !this.isTransient ? cookie("authToken") : this._authToken;
    }
    set authToken(val) {
        if (!this.isTransient) {
            const oldAuthToken = this.authToken;
            if (this.staySignedIn)
                cookie("authToken", val, { expires: 14 });
            else
                cookie("authToken", val);
            if (!oldAuthToken && val) {
                localStorage.setItem("vi-setAuthToken", JSON.stringify({ cookiePrefix: cookiePrefix(), authToken: val }));
                localStorage.removeItem("vi-setAuthToken");
            }
        }
        else
            this._authToken = val;
    }
    get authTokenType() {
        if (!this.authToken)
            return null;
        return this.authToken.startsWith("JWT:") ? "JWT" : "Basic";
    }
    get profile() {
        return this._profile;
    }
    set profile(val) {
        if (this._profile === val)
            return;
        const currentProfileCookie = !!Boolean$1.parse(cookie("profile"));
        if (currentProfileCookie !== val)
            cookie("profile", String(val));
        const oldValue = this._profile;
        this._profile = val;
        if (!val)
            this._setProfiledRequests([]);
        this.notifyPropertyChanged("profile", val, oldValue);
    }
    get profiledRequests() {
        return this._profiledRequests;
    }
    _setProfiledRequests(requests) {
        this.notifyPropertyChanged("profiledRequests", this._profiledRequests = requests);
    }
    getTranslatedMessage(key, ...params) {
        return String.format.apply(null, [this.language.messages[key] || key].concat(params));
    }
    async getCredentialType(userName) {
        return this._postJSON("authenticate/GetCredentialType", { userName: userName });
    }
    async initialize(skipDefaultCredentialLogin = false) {
        let url = "GetClientData?v=3";
        if (this.requestedLanguage)
            url = `${url}&lang=${this.requestedLanguage}`;
        this._clientData = await this.hooks.onInitialize(await (this._getJSON(this._createUri(url))));
        if (this._clientData.exception)
            throw this._clientData.exception;
        const languages = Object.keys(this._clientData.languages).map(culture => new Language(this._clientData.languages[culture], culture));
        this.hooks.setDefaultTranslations(languages);
        this._languages = languages;
        this.language = this._languages.find(l => l.isDefault) || this._languages[0];
        this._providers = {};
        for (const provider in this._clientData.providers) {
            this._providers[provider] = this._clientData.providers[provider].parameters;
        }
        this._windowsAuthentication = this._clientData.windowsAuthentication;
        if (Service._token) {
            if (!Service._token.startsWith("JWT:")) {
                const tokenParts = Service._token.split("/", 2);
                this.userName = atob(tokenParts[0]);
                this.authToken = tokenParts[1].replace("_", "/");
            }
            else
                this.authToken = Service._token;
            Service._token = undefined;
            const returnUrl = cookie("returnUrl", { force: true }) || "";
            if (returnUrl)
                cookie("returnUrl", null, { force: true });
            this.hooks.onNavigate(returnUrl, true);
            return this._getApplication();
        }
        this.userName = this.userName || this._clientData.defaultUser;
        let application;
        if (!String.isNullOrEmpty(this.authToken) || ((this._clientData.defaultUser || this.windowsAuthentication) && !skipDefaultCredentialLogin)) {
            try {
                application = await this._getApplication();
            }
            catch (e) {
                application = null;
            }
        }
        else
            this._setIsSignedIn(!!this.application);
        return application;
    }
    signInExternal(providerName) {
        if (!this.providers[providerName] || !this.providers[providerName].requestUri)
            throw "Provider not found or not flagged for external authentication.";
        document.location.href = this.providers[providerName].requestUri;
    }
    async signInUsingCredentials(userName, password, codeOrStaySignedIn, staySignedIn) {
        this.userName = userName;
        const data = this._createData("getApplication");
        data.userName = userName;
        data.password = password;
        if (typeof codeOrStaySignedIn === "string")
            data.code = codeOrStaySignedIn;
        try {
            const application = await this._getApplication(data);
            if (application && this.isSignedIn && !this.isTransient) {
                const ssi = (typeof codeOrStaySignedIn === "boolean" && codeOrStaySignedIn) || (typeof staySignedIn === "boolean" && staySignedIn);
                cookie("staySignedIn", (this.staySignedIn = ssi) ? "true" : null, { force: true, expires: 365 });
            }
            return application;
        }
        catch (e) {
            throw e;
        }
    }
    signInUsingDefaultCredentials() {
        this.userName = this.defaultUserName;
        return this._getApplication();
    }
    signOut(skipAcs) {
        if (this.clearSiteData && !!this.authToken)
            this.executeAction("PersistentObject.viSignOut", this.application, null, null, null, true);
        if (this.userName === this.defaultUserName || this.userName === this.registerUserName || this.clearSiteData)
            this.userName = null;
        this.authToken = null;
        this._setApplication(null);
        if (!skipAcs && this._providers["Acs"] && this._providers["Acs"].signOutUri) {
            return new Promise(resolve => {
                const iframe = document.createElement("iframe");
                iframe.setAttribute("hidden", "");
                iframe.width = "0";
                iframe.height = "0";
                iframe.src = this._providers["Acs"].signOutUri;
                iframe.onload = () => {
                    document.body.removeChild(iframe);
                    this._setIsSignedIn(false);
                    resolve(true);
                };
                iframe.onerror = () => {
                    this._setIsSignedIn(false);
                    resolve(true);
                };
                document.body.appendChild(iframe);
            });
        }
        this.clearSiteData = false;
        this._setIsSignedIn(false);
        return Promise.resolve(true);
    }
    async _getApplication(data = this._createData("")) {
        if (!(data.authToken || data.accessToken || data.password) && this.userName && this.userName !== this.defaultUserName && this.userName !== this.registerUserName) {
            if (this.defaultUserName)
                this.userName = this.defaultUserName;
            if (!this.userName && !this.hooks.onSessionExpired())
                throw "Session expired";
            data.userName = this.userName;
        }
        const result = await this._postJSON(this._createUri("GetApplication"), data);
        if (!String.isNullOrEmpty(result.exception))
            throw result.exception;
        if (result.application == null)
            throw "Unknown error";
        this._setApplication(this.hooks.onConstructApplication(result));
        const resourcesQuery = this.application.getQuery("Resources");
        this.icons = resourcesQuery ? Object.assign({}, ...resourcesQuery.items.filter(i => i.getValue("Type") === "Icon").map(i => ({ [i.getValue("Key")]: i.getValue("Data") }))) : {};
        Object.assign(this.actionDefinitions, ...this.application.getQuery("Actions").items.map(i => ({ [i.getValue("Name")]: new ActionDefinition(this, i) })));
        this.language = this._languages.find(l => l.culture === result.userLanguage) || this._languages.find(l => l.isDefault);
        const clientMessagesQuery = this.application.getQuery("ClientMessages");
        if (clientMessagesQuery) {
            const newMessages = { ...this.language.messages };
            clientMessagesQuery.items.forEach(msg => newMessages[msg.getValue("Key")] = msg.getValue("Value"));
            this.notifyPropertyChanged("language.messages", this.language.messages = newMessages, this.language.messages);
        }
        Object.keys(this.actionDefinitions).forEach(name => this.language.messages[`Action_${name}`] = this.actionDefinitions[name].displayName);
        CultureInfo.currentCulture = CultureInfo.cultures[result.userCultureInfo] || CultureInfo.cultures[result.userLanguage] || CultureInfo.invariantCulture;
        if (result.initial != null)
            this._initial = this.hooks.onConstructPersistentObject(this, result.initial);
        if (result.userName !== this.registerUserName || result.userName === this.defaultUserName) {
            this.userName = result.userName;
            if (result.session)
                this.application._updateSession(result.session);
            this._setIsSignedIn(true);
        }
        else
            this._setIsSignedIn(false);
        return this.application;
    }
    async getQuery(id, arg2, parent, textSearch, sortOptions) {
        const data = this._createData("getQuery");
        data.id = id;
        const options = typeof arg2 === "object" ? arg2 : {
            asLookup: arg2,
            parent,
            textSearch,
            sortOptions
        };
        if (options.parent != null)
            data.parent = options.parent.toServiceObject();
        if (!!options.textSearch)
            data.textSearch = options.textSearch;
        if (!!options.sortOptions)
            data.sortOptions = options.sortOptions;
        if (!!options.columnOverrides)
            data.columnOverrides = options.columnOverrides;
        const result = await this._postJSON(this._createUri("GetQuery"), data);
        if (result.exception)
            throw result.exception;
        return this.hooks.onConstructQuery(this, result.query, null, options.asLookup);
    }
    async getPersistentObject(parent, id, objectId, isNew) {
        const data = this._createData("getPersistentObject");
        data.persistentObjectTypeId = id;
        data.objectId = objectId;
        if (isNew)
            data.isNew = isNew;
        if (parent != null)
            data.parent = parent.toServiceObject();
        const result = await this._postJSON(this._createUri("GetPersistentObject"), data);
        if (result.exception)
            throw result.exception;
        else if (result.result && result.result.notification) {
            if (result.result.notificationDuration) {
                this.hooks.onShowNotification(result.result.notification, result.result.notificationType, result.result.notificationDuration);
                result.result.notification = null;
                result.result.notificationDuration = 0;
            }
            else if (result.result.notificationType === "Error")
                throw result.result.notification;
        }
        return this.hooks.onConstructPersistentObject(this, result.result);
    }
    async executeQuery(parent, query, asLookup = false, throwExceptions) {
        const data = this._createData("executeQuery");
        data.query = query._toServiceObject();
        if (parent != null)
            data.parent = parent.toServiceObject();
        if (asLookup)
            data.asLookup = asLookup;
        if (query.ownerAttributeWithReference)
            data.forReferenceAttribute = query.ownerAttributeWithReference.name;
        try {
            const result = await this._postJSON(this._createUri("ExecuteQuery"), data);
            if (result.exception)
                throw result.exception;
            const queryResult = result.result;
            if (queryResult.continuation) {
                const wanted = data.query.top || queryResult.pageSize;
                while (queryResult.continuation && queryResult.items.length < wanted) {
                    data.query.continuation = queryResult.continuation;
                    data.query.top = wanted - queryResult.items.length;
                    const innerResult = await this._postJSON(this._createUri("ExecuteQuery"), data);
                    if (innerResult.exception)
                        throw innerResult.exception;
                    const innerQueryResult = innerResult.result;
                    queryResult.items.push(...innerQueryResult.items);
                    queryResult.continuation = innerQueryResult.continuation;
                }
                if (!queryResult.continuation)
                    queryResult.totalItems = query.items.length + queryResult.items.length;
            }
            return queryResult;
        }
        catch (e) {
            query.setNotification(e);
            if (throwExceptions)
                throw e;
        }
    }
    async executeAction(action, parent, query, selectedItems, parameters, skipHooks = false) {
        const isObjectAction = action.startsWith("PersistentObject.") || query == null;
        const targetServiceObject = isObjectAction ? parent : query;
        if (!skipHooks) {
            targetServiceObject.setNotification();
            if (!isObjectAction && query.selectAll.allSelected && !query.selectAll.inverse)
                selectedItems = [];
            this.hooks.trackEvent(action, parameters ? parameters.MenuLabel || parameters.MenuOption : null, query || parent);
            const args = new ExecuteActionArgs(this, action, parent, query, selectedItems, parameters);
            try {
                await this.hooks.onAction(args);
                if (args.isHandled)
                    return args.result;
                return await this.executeAction(action, parent, query, selectedItems, args.parameters, true);
            }
            catch (e) {
                targetServiceObject.setNotification(e);
                throw e;
            }
        }
        const isFreezingAction = isObjectAction && action !== "PersistentObject.Refresh";
        const data = this._createData("executeAction");
        data.action = action;
        if (parent != null)
            data.parent = parent.toServiceObject();
        if (query != null)
            data.query = query._toServiceObject();
        if (selectedItems != null)
            data.selectedItems = selectedItems.map(item => item && item._toServiceObject());
        if (parameters != null)
            data.parameters = parameters;
        const executeThen = async (result) => {
            if (!result)
                return;
            if (result.operations) {
                this._queuedClientOperations.push(...result.operations);
                result.operations = null;
            }
            if (!result.retry)
                return result.result ? await this.hooks.onConstructPersistentObject(this, result.result) : null;
            if (result.retry.persistentObject)
                result.retry.persistentObject = this.hooks.onConstructPersistentObject(this, result.retry.persistentObject);
            const option = await this.hooks.onRetryAction(result.retry);
            (data.parameters || (data.parameters = {})).RetryActionOption = option;
            if (result.retry.persistentObject instanceof PersistentObject$1)
                data.retryPersistentObject = result.retry.persistentObject.toServiceObject();
            const retryResult = await this._postJSON(this._createUri("ExecuteAction"), data);
            return await executeThen(retryResult);
        };
        try {
            if (isFreezingAction)
                parent?.freeze();
            const getInputs = (result, attribute) => {
                if (attribute.input != null && attribute.isValueChanged) {
                    result.push([
                        !attribute.parent.ownerDetailAttribute ? attribute.name : `${attribute.parent.ownerDetailAttribute.name}.${attribute.parent.ownerDetailAttribute.objects.indexOf(attribute.parent)}.${attribute.name}`,
                        attribute.input
                    ]);
                }
                else if (attribute instanceof PersistentObjectAttributeAsDetail$1)
                    attribute.objects?.flatMap(parent => parent.attributes).reduce(getInputs, result);
                return result;
            };
            const inputs = parent?.attributes.reduce(getInputs, []);
            if (inputs?.length > 0) {
                const formData = new FormData();
                inputs.forEach(i => {
                    const [attributeName, input] = i;
                    formData.set(attributeName, input.files[0]);
                });
                data.__form_data = formData;
            }
            const result = await this._postJSON(this._createUri("ExecuteAction"), data);
            return await executeThen(result);
        }
        catch (e) {
            targetServiceObject.setNotification(e);
            throw e;
        }
        finally {
            if (isFreezingAction)
                parent?.unfreeze();
        }
    }
    async getStream(obj, action, parent, query, selectedItems, parameters) {
        const data = this._createData("getStream");
        data.action = action;
        if (obj != null)
            data.id = obj.objectId;
        if (parent != null)
            data.parent = parent.toServiceObject();
        if (query != null)
            data.query = query._toServiceObject();
        if (selectedItems != null)
            data.selectedItems = selectedItems.map(si => si._toServiceObject());
        if (parameters != null)
            data.parameters = parameters;
        const formData = new FormData();
        formData.append("data", JSON.stringify(data));
        const response = await this._fetch(new Request(this._createUri("GetStream"), {
            body: formData,
            method: "POST"
        }));
        if (response.ok) {
            const blob = await response.blob();
            const a = document.createElement("a");
            a.style.display = "none";
            const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
            const matches = filenameRegex.exec(response.headers.get("Content-Disposition"));
            if (matches != null && matches[1])
                a.download = matches[1].replace(/['"]/g, '');
            a.href = URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.dispatchEvent(new MouseEvent("click", { bubbles: false }));
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }
    }
    async getReport(token, { filter = "", orderBy, top, skip, hideIds, hideType = true } = {}) {
        let uri = this._createUri(`GetReport/${token}?format=json&$filter=${encodeURIComponent(filter)}`);
        if (orderBy)
            uri = `${uri}&$orderBy=${orderBy}`;
        if (top)
            uri = `${uri}&$top=${top}`;
        if (skip)
            uri = `${uri}&$skip=${skip}`;
        if (hideIds)
            uri = `${uri}&hideIds=true`;
        if (hideType)
            uri = `${uri}&hideType=true`;
        return (await this._getJSON(uri)).d;
    }
    async getInstantSearch(search) {
        const uri = this._createUri(`Instant?q=${encodeURIComponent(search)}`);
        let authorization;
        if (this.authTokenType !== "JWT") {
            const userName = encodeURIComponent(this.userName);
            const authToken = this.authToken ? this.authToken.replace("/", "_") : "";
            authorization = `${userName}/${authToken}`;
        }
        else
            authorization = this.authToken.substr(4);
        return (await this._getJSON(uri, {
            "Authorization": `Bearer ${authorization}`
        })).d;
    }
    forgotPassword(userName) {
        return this._postJSON(this._createUri("forgotpassword"), { userName: userName });
    }
    static fromServiceString(value, typeName) {
        return DataType.fromServiceString(value, typeName);
    }
    static toServiceString(value, typeName) {
        return DataType.toServiceString(value, typeName);
    }
}

var service = /*#__PURE__*/Object.freeze({
	__proto__: null
});

var Vidyano = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Action: Action,
	ActionDefinition: ActionDefinition,
	ActionGroup: ActionGroup,
	Actions: Actions,
	Application: Application,
	ArrayChangedArgs: ArrayChangedArgs,
	ClientOperations: ClientOperations,
	CultureInfo: CultureInfo,
	DataType: DataType,
	Dto: service,
	ExecuteActionArgs: ExecuteActionArgs,
	ExpressionParser: ExpressionParser,
	Language: Language,
	NoInternetMessage: NoInternetMessage,
	Observable: Observable,
	PersistentObject: PersistentObject$1,
	PersistentObjectAttribute: PersistentObjectAttribute$1,
	PersistentObjectAttributeAsDetail: PersistentObjectAttributeAsDetail$1,
	PersistentObjectAttributeGroup: PersistentObjectAttributeGroup,
	PersistentObjectAttributeTab: PersistentObjectAttributeTab,
	PersistentObjectAttributeWithReference: PersistentObjectAttributeWithReference,
	get PersistentObjectLayoutMode () { return PersistentObjectLayoutMode; },
	PersistentObjectQueryTab: PersistentObjectQueryTab,
	PersistentObjectTab: PersistentObjectTab$1,
	ProgramUnit: ProgramUnit,
	ProgramUnitItem: ProgramUnitItem,
	ProgramUnitItemGroup: ProgramUnitItemGroup,
	ProgramUnitItemPersistentObject: ProgramUnitItemPersistentObject,
	ProgramUnitItemQuery: ProgramUnitItemQuery,
	ProgramUnitItemSeparator: ProgramUnitItemSeparator,
	ProgramUnitItemUrl: ProgramUnitItemUrl,
	PropertyChangedArgs: PropertyChangedArgs,
	Query: Query$1,
	QueryChart: QueryChart,
	QueryColumn: QueryColumn,
	QueryFilter: QueryFilter,
	QueryFilters: QueryFilters,
	QueryResultItem: QueryResultItem,
	QueryResultItemGroup: QueryResultItemGroup,
	QueryResultItemValue: QueryResultItemValue,
	Queue: Queue,
	Service: Service,
	ServiceBus: ServiceBus,
	ServiceHooks: ServiceHooks,
	ServiceObject: ServiceObject,
	ServiceObjectWithActions: ServiceObjectWithActions,
	Subject: Subject,
	cookie: cookie,
	cookiePrefix: cookiePrefix,
	extend: extend$2,
	noop: noop$1,
	sleep: sleep$1,
	version: version$2
});

window.JSCompiler_renameProperty = function(prop, obj) {
  return prop;
};

let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  if (url === '//') {
    return url;
  }
  if (workingURL === undefined) {
    workingURL = false;
    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = (u.href === 'http://a/c%20d');
    } catch (e) {
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    try {
      return (new URL(url, baseURI)).href;
    } catch (e) {
      return url;
    }
  }
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
    return pre + '\'' +
      resolveUrl(url.replace(/["']/g, ''), baseURI) +
      '\'' + post;
  });
}
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

var resolveUrl$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	pathFromUrl: pathFromUrl,
	resolveCss: resolveCss,
	resolveUrl: resolveUrl
});

const useShadow = !(window.ShadyDOM) || !(window.ShadyDOM.inUse);
const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
const useNativeCustomElements = !(window.customElements.polyfillWrapFlushCallback);
const supportsAdoptingStyleSheets = useShadow &&
    ('adoptedStyleSheets' in Document.prototype) &&
    ('replaceSync' in CSSStyleSheet.prototype) &&
    (() => {
      try {
        const sheet = new CSSStyleSheet();
        sheet.replaceSync('');
        const host = document.createElement('div');
        host.attachShadow({mode: 'open'});
        host.shadowRoot.adoptedStyleSheets = [sheet];
        return (host.shadowRoot.adoptedStyleSheets[0] === sheet);
      } catch(e) {
        return false;
      }
    })();
let rootPath = window.Polymer && window.Polymer.rootPath ||
  pathFromUrl(document.baseURI || window.location.href);
const setRootPath = function(path) {
  rootPath = path;
};
let sanitizeDOMValue =
  window.Polymer && window.Polymer.sanitizeDOMValue || undefined;
const setSanitizeDOMValue = function(newSanitizeDOMValue) {
  sanitizeDOMValue = newSanitizeDOMValue;
};
const getSanitizeDOMValue = function() {
  return sanitizeDOMValue;
};
let passiveTouchGestures =
  window.Polymer && window.Polymer.setPassiveTouchGestures || false;
const setPassiveTouchGestures = function(usePassive) {
  passiveTouchGestures = usePassive;
};
let strictTemplatePolicy =
  window.Polymer && window.Polymer.strictTemplatePolicy || false;
const setStrictTemplatePolicy = function(useStrictPolicy) {
  strictTemplatePolicy = useStrictPolicy;
};
let allowTemplateFromDomModule =
  window.Polymer && window.Polymer.allowTemplateFromDomModule || false;
const setAllowTemplateFromDomModule = function(allowDomModule) {
  allowTemplateFromDomModule = allowDomModule;
};
let legacyOptimizations =
  window.Polymer && window.Polymer.legacyOptimizations || false;
const setLegacyOptimizations = function(useLegacyOptimizations) {
  legacyOptimizations = useLegacyOptimizations;
};
let legacyWarnings =
  window.Polymer && window.Polymer.legacyWarnings || false;
const setLegacyWarnings = function(useLegacyWarnings) {
  legacyWarnings = useLegacyWarnings;
};
let syncInitialRender =
  window.Polymer && window.Polymer.syncInitialRender || false;
const setSyncInitialRender = function(useSyncInitialRender) {
  syncInitialRender = useSyncInitialRender;
};
let legacyUndefined =
  window.Polymer && window.Polymer.legacyUndefined || false;
const setLegacyUndefined = function(useLegacyUndefined) {
  legacyUndefined = useLegacyUndefined;
};
let orderedComputed =
  window.Polymer && window.Polymer.orderedComputed || false;
const setOrderedComputed = function(useOrderedComputed) {
  orderedComputed = useOrderedComputed;
};
let cancelSyntheticClickEvents = true;
const setCancelSyntheticClickEvents = function(useCancelSyntheticClickEvents) {
  cancelSyntheticClickEvents = useCancelSyntheticClickEvents;
};
let removeNestedTemplates =
  window.Polymer && window.Polymer.removeNestedTemplates || false;
const setRemoveNestedTemplates = function(useRemoveNestedTemplates) {
  removeNestedTemplates = useRemoveNestedTemplates;
};
let fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
const setFastDomIf = function(useFastDomIf) {
  fastDomIf = useFastDomIf;
};
let suppressTemplateNotifications =
  window.Polymer && window.Polymer.suppressTemplateNotifications || false;
const setSuppressTemplateNotifications = function(suppress) {
  suppressTemplateNotifications = suppress;
};
let legacyNoObservedAttributes =
  window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
const setLegacyNoObservedAttributes = function(noObservedAttributes) {
  legacyNoObservedAttributes = noObservedAttributes;
};
let useAdoptedStyleSheetsWithBuiltCSS =
  window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;
const setUseAdoptedStyleSheetsWithBuiltCSS = function(value) {
  useAdoptedStyleSheetsWithBuiltCSS = value;
};

var settings = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get allowTemplateFromDomModule () { return allowTemplateFromDomModule; },
	get cancelSyntheticClickEvents () { return cancelSyntheticClickEvents; },
	get fastDomIf () { return fastDomIf; },
	getSanitizeDOMValue: getSanitizeDOMValue,
	get legacyNoObservedAttributes () { return legacyNoObservedAttributes; },
	get legacyOptimizations () { return legacyOptimizations; },
	get legacyUndefined () { return legacyUndefined; },
	get legacyWarnings () { return legacyWarnings; },
	get orderedComputed () { return orderedComputed; },
	get passiveTouchGestures () { return passiveTouchGestures; },
	get removeNestedTemplates () { return removeNestedTemplates; },
	get rootPath () { return rootPath; },
	get sanitizeDOMValue () { return sanitizeDOMValue; },
	setAllowTemplateFromDomModule: setAllowTemplateFromDomModule,
	setCancelSyntheticClickEvents: setCancelSyntheticClickEvents,
	setFastDomIf: setFastDomIf,
	setLegacyNoObservedAttributes: setLegacyNoObservedAttributes,
	setLegacyOptimizations: setLegacyOptimizations,
	setLegacyUndefined: setLegacyUndefined,
	setLegacyWarnings: setLegacyWarnings,
	setOrderedComputed: setOrderedComputed,
	setPassiveTouchGestures: setPassiveTouchGestures,
	setRemoveNestedTemplates: setRemoveNestedTemplates,
	setRootPath: setRootPath,
	setSanitizeDOMValue: setSanitizeDOMValue,
	setStrictTemplatePolicy: setStrictTemplatePolicy,
	setSuppressTemplateNotifications: setSuppressTemplateNotifications,
	setSyncInitialRender: setSyncInitialRender,
	setUseAdoptedStyleSheetsWithBuiltCSS: setUseAdoptedStyleSheetsWithBuiltCSS,
	get strictTemplatePolicy () { return strictTemplatePolicy; },
	supportsAdoptingStyleSheets: supportsAdoptingStyleSheets,
	get suppressTemplateNotifications () { return suppressTemplateNotifications; },
	get syncInitialRender () { return syncInitialRender; },
	get useAdoptedStyleSheetsWithBuiltCSS () { return useAdoptedStyleSheetsWithBuiltCSS; },
	useNativeCSSProperties: useNativeCSSProperties,
	useNativeCustomElements: useNativeCustomElements,
	useShadow: useShadow
});

let dedupeId$1 = 0;
const dedupingMixin = function(mixin) {
  let mixinApplications = (mixin).__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    (mixin).__mixinApplications = mixinApplications;
  }
  let mixinDedupeId = dedupeId$1++;
  function dedupingMixin(base) {
    let baseSet = (base).__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = (mixin)(base);
      map.set(base, extended);
      let mixinSet = Object.create((extended).__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      (extended).__mixinSet = mixinSet;
    }
    return extended;
  }
  return dedupingMixin;
};

let modules = {};
let lcModules = {};
function setModule(id, module) {
  modules[id] = lcModules[id.toLowerCase()] = module;
}
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}
function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}
class DomModule extends HTMLElement {
  static get observedAttributes() { return ['id']; }
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }
  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  get assetpath() {
    if (!this.__assetpath) {
      const owner = window.HTMLImports && HTMLImports.importForElement ?
        HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(
        this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = pathFromUrl(url);
    }
    return this.__assetpath;
  }
  register(id) {
    id = id || this.id;
    if (id) {
      if (strictTemplatePolicy && findModule(id) !== undefined) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }
      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }
}
DomModule.prototype['modules'] = modules;
customElements.define('dom-module', DomModule);

const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';
const SHADY_UNSCOPED_ATTR = 'shady-unscoped';
function importModule(moduleId) {
  return (DomModule.import(moduleId));
}
function styleForImport(importDoc) {
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(container.textContent,
    importDoc.baseURI);
  const style = document.createElement('style');
  style.textContent = importCss;
  return style;
}
function stylesFromModules(moduleIds) {
 const modules = moduleIds.trim().split(/\s+/);
 const styles = [];
 for (let i=0; i < modules.length; i++) {
   styles.push(...stylesFromModule(modules[i]));
 }
 return styles;
}
function stylesFromModule(moduleId) {
  const m = importModule(moduleId);
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
    return [];
  }
  if (m._styles === undefined) {
    const styles = [];
    styles.push(..._stylesFromModuleImports(m));
    const template = (
        m.querySelector('template'));
    if (template) {
      styles.push(...stylesFromTemplate(template,
        (m).assetpath));
    }
    m._styles = styles;
  }
  return m._styles;
}
function stylesFromTemplate(template, baseURI) {
  if (!template._styles) {
    const styles = [];
    const e$ = template.content.querySelectorAll('style');
    for (let i=0; i < e$.length; i++) {
      let e = e$[i];
      let include = e.getAttribute(INCLUDE_ATTR);
      if (include) {
        styles.push(...stylesFromModules(include).filter(function(item, index, self) {
          return self.indexOf(item) === index;
        }));
      }
      if (baseURI) {
        e.textContent =
            resolveCss(e.textContent,  (baseURI));
      }
      styles.push(e);
    }
    template._styles = styles;
  }
  return template._styles;
}
function stylesFromModuleImports(moduleId) {
 let m = importModule(moduleId);
 return m ? _stylesFromModuleImports(m) : [];
}
function _stylesFromModuleImports(module) {
  const styles = [];
  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i=0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, '');
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }
      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }
  return styles;
}
function cssFromModules(moduleIds) {
 let modules = moduleIds.trim().split(/\s+/);
 let cssText = '';
 for (let i=0; i < modules.length; i++) {
   cssText += cssFromModule(modules[i]);
 }
 return cssText;
}
function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    let cssText = _cssFromModuleImports(m);
    let t = (m.querySelector('template'));
    if (t) {
      cssText += cssFromTemplate(t,
        (m).assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}
function cssFromTemplate(template, baseURI) {
  let cssText = '';
  const e$ = stylesFromTemplate(template, baseURI);
  for (let i=0; i < e$.length; i++) {
    let e = e$[i];
    if (e.parentNode) {
      e.parentNode.removeChild(e);
    }
    cssText += e.textContent;
  }
  return cssText;
}
function _cssFromModuleImports(module) {
  let cssText = '';
  let styles = _stylesFromModuleImports(module);
  for (let i=0; i < styles.length; i++) {
    cssText += styles[i].textContent;
  }
  return cssText;
}

const wrap = (window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap']) ?
  window['ShadyDOM']['wrap'] :
  (window['ShadyDOM'] ? (n) => ShadyDOM['patch'](n) : (n) => n);

function isPath(path) {
  return path.indexOf('.') >= 0;
}
function root$1(path) {
  let dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}
function isAncestor(base, path) {
  return base.indexOf(path + '.') === 0;
}
function isDescendant(base, path) {
  return path.indexOf(base + '.') === 0;
}
function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}
function matches$2(base, path) {
  return (base === path) ||
         isAncestor(base, path) ||
         isDescendant(base, path);
}
function normalize$1(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i=0; i<path.length; i++) {
      let args = path[i].toString().split('.');
      for (let j=0; j<args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}
function split(path) {
  if (Array.isArray(path)) {
    return normalize$1(path).split('.');
  }
  return path.toString().split('.');
}
function get$2(root, path, info) {
  let prop = root;
  let parts = split(path);
  for (let i=0; i<parts.length; i++) {
    if (!prop) {
      return;
    }
    let part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}
function set$2(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length-1];
  if (parts.length > 1) {
    for (let i=0; i<parts.length-1; i++) {
      let part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    prop[last] = value;
  } else {
    prop[path] = value;
  }
  return parts.join('.');
}

const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;
function dashToCamelCase(dash) {
  return caseMap[dash] || (
    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,
      (m) => m[1].toUpperCase()
    )
  );
}
function camelToDashCase(camel) {
  return caseMap[camel] || (
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()
  );
}

var caseMap$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	camelToDashCase: camelToDashCase,
	dashToCamelCase: dashToCamelCase
});

let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskScheduled = false;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});
function microtaskFlush() {
  microtaskScheduled = false;
  const len = microtaskCallbacks.length;
  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => { throw e; });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}
const timeOut = {
  after(delay) {
    return {
      run(fn) { return window.setTimeout(fn, delay); },
      cancel(handle) {
        window.clearTimeout(handle);
      }
    };
  },
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },
  cancel(handle) {
    window.clearTimeout(handle);
  }
};
const animationFrame = {
  run(fn) {
    return window.requestAnimationFrame(fn);
  },
  cancel(handle) {
    window.cancelAnimationFrame(handle);
  }
};
const idlePeriod = {
  run(fn) {
    return window.requestIdleCallback ?
      window.requestIdleCallback(fn) :
      window.setTimeout(fn, 16);
  },
  cancel(handle) {
    window.cancelIdleCallback ?
      window.cancelIdleCallback(handle) :
      window.clearTimeout(handle);
  }
};
const microTask = {
  run(callback) {
    if (!microtaskScheduled) {
      microtaskScheduled = true;
      microtaskNode.textContent = microtaskNodeContent++;
    }
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }
};

var async = /*#__PURE__*/Object.freeze({
	__proto__: null,
	animationFrame: animationFrame,
	idlePeriod: idlePeriod,
	microTask: microTask,
	timeOut: timeOut
});

const microtask = microTask;
const PropertiesChanged = dedupingMixin(
    (superClass) => {
  class PropertiesChanged extends superClass {
    static createProperties(props) {
      const proto = this.prototype;
      for (let prop in props) {
        if (!(prop in proto)) {
          proto._createPropertyAccessor(prop);
        }
      }
    }
    static attributeNameForProperty(property) {
      return property.toLowerCase();
    }
    static typeForProperty(name) { }
    _createPropertyAccessor(property, readOnly) {
      this._addPropertyToAttributeMap(property);
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }
      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;
        this._definePropertyAccessor(property, readOnly);
      }
    }
    _addPropertyToAttributeMap(property) {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {
        this.__dataAttributes = Object.assign({}, this.__dataAttributes);
      }
      let attr = this.__dataAttributes[property];
      if (!attr) {
        attr = this.constructor.attributeNameForProperty(property);
        this.__dataAttributes[attr] = property;
      }
      return attr;
    }
     _definePropertyAccessor(property, readOnly) {
      Object.defineProperty(this, property, {
        get() {
          return this.__data[property];
        },
        set: readOnly ? function () {} : function (value) {
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }
      });
    }
    constructor() {
      super();
      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      this.__dataInstanceProps = null;
      this.__dataCounter = 0;
      this.__serializing = false;
      this._initializeProperties();
    }
    ready() {
      this.__dataReady = true;
      this._flushProperties();
    }
    _initializeProperties() {
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }
    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }
    _getProperty(property) {
      return this.__data[property];
    }
    _setPendingProperty(property, value, ext) {
      let old = this.__data[property];
      let changed = this._shouldPropertyChange(property, value, old);
      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }
        this.__data[property] = value;
        this.__dataPending[property] = value;
      }
      return changed;
    }
    _isPropertyPending(property) {
      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));
    }
    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;
            this._flushProperties();
          }
        });
      }
    }
    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;
        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);
          this.__dataInstanceProps = null;
        }
        this.ready();
      }
    }
    _flushProperties() {
      this.__dataCounter++;
      const props = this.__data;
      const changedProps = this.__dataPending;
      const old = this.__dataOld;
      if (this._shouldPropertiesChange(props, changedProps, old)) {
        this.__dataPending = null;
        this.__dataOld = null;
        this._propertiesChanged(props, changedProps, old);
      }
      this.__dataCounter--;
    }
    _shouldPropertiesChange(currentProps, changedProps, oldProps) {
      return Boolean(changedProps);
    }
    _propertiesChanged(currentProps, changedProps, oldProps) {
    }
    _shouldPropertyChange(property, value, old) {
      return (
        (old !== value &&
          (old === old || value === value))
      );
    }
    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }
      if (super.attributeChangedCallback) {
        super.attributeChangedCallback(name, old, value, namespace);
      }
    }
    _attributeToProperty(attribute, value, type) {
      if (!this.__serializing) {
        const map = this.__dataAttributes;
        const property = map && map[attribute] || attribute;
        this[property] = this._deserializeValue(value, type ||
          this.constructor.typeForProperty(property));
      }
    }
    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = (arguments.length < 3) ? this[property] : value;
      this._valueToNodeAttribute((this), value,
        attribute || this.constructor.attributeNameForProperty(property));
      this.__serializing = false;
    }
    _valueToNodeAttribute(node, value, attribute) {
      const str = this._serializeValue(value);
      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {
        node = (wrap(node));
      }
      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(
            attribute,
            (str === '' && window.trustedTypes) ?
                 (window.trustedTypes.emptyScript) :
                str);
      }
    }
    _serializeValue(value) {
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;
        default:
          return value != null ? value.toString() : undefined;
      }
    }
    _deserializeValue(value, type) {
      switch (type) {
        case Boolean:
          return (value !== null);
        case Number:
          return Number(value);
        default:
          return value;
      }
    }
  }
  return PropertiesChanged;
});

const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i=0; i<props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}
const isTrustedType = (() => {
  if (!window.trustedTypes) {
    return () => false;
  }
  return (val) => trustedTypes.isHTML(val) ||
        trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);
})();
function saveAccessorValue(model, property) {
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        model._setPendingProperty(property, value);
      } else {
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}
const PropertyAccessors = dedupingMixin(superClass => {
   const base = PropertiesChanged(superClass);
  class PropertyAccessors extends base {
    static createPropertiesForAttributes() {
      let a$ =   (this).observedAttributes;
      for (let i=0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));
      }
    }
    static attributeNameForProperty(property) {
      return camelToDashCase(property);
    }
    _initializeProperties() {
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      super._initializeProperties();
    }
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }
    _ensureAttribute(attribute, value) {
      const el = (this);
      if (!el.hasAttribute(attribute)) {
        this._valueToNodeAttribute(el, value, attribute);
      }
    }
    _serializeValue(value) {
      switch (typeof value) {
        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            if (isTrustedType(value)) {
              return  (value);
            }
            try {
              return JSON.stringify(value);
            } catch(x) {
              return '';
            }
          }
        default:
          return super._serializeValue(value);
      }
    }
    _deserializeValue(value, type) {
      let outValue;
      switch (type) {
        case Object:
          try {
            outValue = JSON.parse((value));
          } catch(x) {
            outValue = value;
          }
          break;
        case Array:
          try {
            outValue = JSON.parse((value));
          } catch(x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;
        case Date:
          outValue = isNaN(value) ? String(value) : Number(value);
          outValue = new Date(outValue);
          break;
        default:
          outValue = super._deserializeValue(value, type);
          break;
      }
      return outValue;
    }
    _definePropertyAccessor(property, readOnly) {
      saveAccessorValue(this, property);
      super._definePropertyAccessor(property, readOnly);
    }
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && (prop in this.__dataPending));
    }
  }
  return PropertyAccessors;
});

const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
let placeholderBugDetect = false;
let placeholderBug = false;
function hasPlaceholderBug() {
  if (!placeholderBugDetect) {
    placeholderBugDetect = true;
    const t = document.createElement('textarea');
    t.placeholder = 'a';
    placeholderBug = t.placeholder === t.textContent;
  }
  return placeholderBug;
}
function fixPlaceholder(node) {
  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder
        && node.placeholder === node.textContent) {
    node.textContent = null;
  }
}
const copyAttributeWithTemplateEventPolicy = (() => {
  const polymerTemplateEventAttributePolicy = window.trustedTypes &&
      window.trustedTypes.createPolicy(
          'polymer-template-event-attribute-policy', {
            createScript: x => x,
          });
  return (dest, src, name) => {
    const value = src.getAttribute(name);
    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {
      dest.setAttribute(
          name, polymerTemplateEventAttributePolicy.createScript(value, name));
      return;
    }
    dest.setAttribute(name, value);
  };
})();
function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while(t.attributes.length) {
      const {name} = t.attributes[0];
      copyAttributeWithTemplateEventPolicy(node, t, name);
      t.removeAttribute(name);
    }
  }
  return node;
}
function findTemplateNode(root, nodeInfo) {
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  if (parent) {
    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}
function applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
    node._parentTemplateInfo = parentTemplateInfo;
  }
}
function createNodeEventHandler(context, eventName, methodName) {
  context = context._methodHost || context;
  let handler = function(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}
const TemplateStamp = dedupingMixin(
    (superClass) => {
  class TemplateStamp extends superClass {
    static _parseTemplate(template, outerTemplateInfo) {
      if (!template._templateInfo) {
        let  templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);
        templateInfo.stripWhiteSpace =
          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
          (template.hasAttribute && template.hasAttribute('strip-whitespace'));
         this._parseTemplateContent(
             template, templateInfo,  ({parent: null}));
      }
      return template._templateInfo;
    }
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = false;
      let element =  (node);
      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        templateInfo.hasInsertionPoint = true;
      }
      fixPlaceholder(element);
      if (element.firstChild) {
        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);
      }
      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }
      return noted || nodeInfo.noted;
    }
    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      if (root.localName === 'script' || root.localName === 'style') {
        return;
      }
      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        }
        next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let  n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }
        let childInfo =
             ({parentIndex, parentInfo: nodeInfo});
        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;
        }
        if (node.parentNode) {
          parentIndex++;
        }
      }
    }
    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      let element =  (node);
      let templateInfo = this._parseTemplate(element, outerTemplateInfo);
      let content = templateInfo.content =
          element.content.ownerDocument.createDocumentFragment();
      content.appendChild(element.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }
    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      let noted = false;
      let attrs = Array.from(node.attributes);
      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }
      return noted;
    }
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      }
      else if (name === 'id') {
        nodeInfo.id = value;
        return true;
      }
      return false;
    }
    static _contentForTemplate(template) {
      let templateInfo =  (template)._templateInfo;
      return (templateInfo && templateInfo.content) || template.content;
    }
    _stampTemplate(template, templateInfo) {
      if (template && !template.content &&
          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }
      templateInfo = templateInfo || this.constructor._parseTemplate(template);
      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom =  (document.importNode(content, true));
      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};
      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateInfo(this, node, info, templateInfo);
        applyEventListener(this, node, info);
      }
      dom = (dom);
      return dom;
    }
    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);
      this._addEventListenerToNode(node, eventName, handler);
      return handler;
    }
    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }
    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }
  }
  return TemplateStamp;
});

let dedupeId = 0;
const NOOP = [];
const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};
const COMPUTE_INFO = '__computeInfo';
const capitalAttributeRegex = /[A-Z]/;
function ensureOwnEffectMap(model, type, cloneArrays) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    if (cloneArrays) {
      for (let p in effects) {
        let protoFx = effects[p];
        let instFx = effects[p] = Array(protoFx.length);
        for (let i=0; i<protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
  }
  return effects;
}
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    const id = dedupeId++;
    for (let prop in props) {
      let rootProperty = hasPaths ? root$1(prop) : prop;
      let fxs = effects[rootProperty];
      if (fxs) {
        for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
          if ((!fx.info || fx.info.lastRun !== id) &&
              (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
            if (fx.info) {
              fx.info.lastRun = id;
            }
            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
            ran = true;
          }
        }
      }
    }
    return ran;
  }
  return false;
}
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? root$1(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) &&
          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath =  (trigger.name);
    return (triggerPath == path) ||
        !!(trigger.structured && isAncestor(triggerPath, path)) ||
        !!(trigger.wildcard && isDescendant(triggerPath, path));
  } else {
    return true;
  }
}
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = typeof info.method === "string" ? inst[info.method] : info.method;
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.method + '` not defined');
  }
}
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++;
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}
function notifyPath(inst, path, props) {
  let rootProperty = root$1(path);
  if (rootProperty !== path) {
    let eventName = camelToDashCase(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  wrap((inst)).dispatchEvent(new CustomEvent(eventName, { detail }));
}
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? root$1(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? get$2(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property];
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = (event.detail);
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = translate(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.currentTarget[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))
      && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, info.attrName, 'attribute', (inst));
  }
  inst._propertyToAttribute(property, info.attrName, value);
}
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    if (orderedComputed) {
      dedupeId++;
      const order = getComputedOrder(inst);
      const queue = [];
      for (let p in changedProps) {
        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);
      }
      let info;
      while ((info = queue.shift())) {
        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {
          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);
        }
      }
      Object.assign( (oldProps), inst.__dataOld);
      Object.assign( (changedProps), inst.__dataPending);
      inst.__dataPending = null;
    } else {
      let inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign( (oldProps), inst.__dataOld);
        Object.assign( (changedProps), inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }
}
const insertEffect = (info, queue, order) => {
  let start = 0;
  let end = queue.length - 1;
  let idx = -1;
  while (start <= end) {
    const mid = (start + end) >> 1;
    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);
    if (cmp < 0) {
      start = mid + 1;
    } else if (cmp > 0) {
      end = mid - 1;
    } else {
      idx = mid;
      break;
    }
  }
  if (idx < 0) {
    idx = end + 1;
  }
  queue.splice(idx, 0, info);
};
const enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {
  const rootProperty = hasPaths ? root$1(prop) : prop;
  const fxs = computeEffects[rootProperty];
  if (fxs) {
    for (let i=0; i<fxs.length; i++) {
      const fx = fxs[i];
      if ((fx.info.lastRun !== dedupeId) &&
          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        fx.info.lastRun = dedupeId;
        insertEffect(fx.info, queue, order);
      }
    }
  }
};
function getComputedOrder(inst) {
  let ordered = inst.constructor.__orderedComputedDeps;
  if (!ordered) {
    ordered = new Map();
    const effects = inst[TYPES.COMPUTE];
    let {counts, ready, total} = dependencyCounts(inst);
    let curr;
    while ((curr = ready.shift())) {
      ordered.set(curr, ordered.size);
      const computedByCurr = effects[curr];
      if (computedByCurr) {
        computedByCurr.forEach(fx => {
          const computedProp = fx.info.methodInfo;
          --total;
          if (--counts[computedProp] === 0) {
            ready.push(computedProp);
          }
        });
      }
    }
    if (total !== 0) {
      const el =  (inst);
      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);
    }
    inst.constructor.__orderedComputedDeps = ordered;
  }
  return ordered;
}
function dependencyCounts(inst) {
  const infoForComputed = inst[COMPUTE_INFO];
  const counts = {};
  const computedDeps = inst[TYPES.COMPUTE];
  const ready = [];
  let total = 0;
  for (let p in infoForComputed) {
    const info = infoForComputed[p];
    total += counts[p] =
      info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);
  }
  for (let p in computedDeps) {
    if (!infoForComputed[p]) {
      ready.push(p);
    }
  }
  return {counts, ready, total};
}
function runComputedEffect(inst, property, changedProps, oldProps, info) {
  let result = runMethodEffect(inst, property, changedProps, oldProps, info);
  if (result === NOOP) {
    return false;
  }
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    return inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
    return false;
  }
}
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a in links) {
      let b = links[a];
      if (isDescendant(a, path)) {
        link = translate(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (isDescendant(b, path)) {
        link = translate(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  nodeInfo.bindings = nodeInfo.bindings || [];
  let  binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };
  nodeInfo.bindings.push(binding);
  if (shouldAddListener(binding)) {
    let {event, negate} = binding.parts[0];
    binding.listenerEvent = event || (camelToDashCase(target) + '-changed');
    binding.listenerNegate = negate;
  }
  let index = templateInfo.nodeInfoList.length;
  for (let i=0; i<binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target +
        ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j=0; j<dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info, trigger
        });
      }
    }
  }
}
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  if (hasPaths && part.source && (path.length > part.source.length) &&
      (binding.kind == 'property') && !binding.isCompound &&
      node.__isPropertyEffectsClient &&
      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = translate(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    if (value !== NOOP) {
      applyBindingValue(inst, node, binding, part, value);
    }
  }
}
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    inst._valueToNodeAttribute((node), value, binding.target);
  } else {
    let prop = binding.target;
    if (node.__isPropertyEffectsClient &&
        node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    if (binding.target === 'textContent' ||
        (binding.target === 'value' &&
          (node.localName === 'input' || node.localName === 'textarea'))) {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}
function shouldAddListener(binding) {
  return Boolean(binding.target) &&
         binding.kind != 'attribute' &&
         binding.kind != 'text' &&
         !binding.isCompound &&
         binding.parts[0].mode === '{';
}
function setupBindings(inst, templateInfo) {
  let {nodeList, nodeInfoList} = templateInfo;
  if (nodeInfoList.length) {
    for (let i=0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;
      if (bindings) {
        for (let i=0; i<bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage ||
      (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    let literals = new Array(parts.length);
    for (let j=0; j<parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    if (binding.literal && binding.kind == 'property') {
      if (target === 'className') {
        node = wrap(node);
      }
      node[target] = binding.literal;
    }
  }
}
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || (dynamicFn &&
    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
  return info;
}
function runMethodEffect(inst, property, props, oldProps, info) {
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = inst._marshalArgs(info.args, property, props);
    return args === NOOP ? NOOP : fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}
const emptyArray = [];
const IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                              '(?:' + ARGUMENTS + '?' + ')' +
                            '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?';
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
function literalFromParts(parts) {
  let s = '';
  for (let i=0; i<parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}
function parseMethod(expression) {
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    let methodName = m[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}
function parseArg(rawArg) {
  let arg = rawArg.trim()
    .replace(/&comma;/g, ',')
    .replace(/\\(.)/g, '$1')
    ;
  let a = {
    name: arg,
    value: '',
    literal: false
  };
  let fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch(fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  if (!a.literal) {
    a.rootProperty = root$1(arg);
    a.structured = isPath(arg);
    if (a.structured) {
      a.wildcard = (arg.slice(-2) == '.*');
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}
function getArgValue(data, props, path) {
  let value = get$2(data, path);
  if (value === undefined) {
    value = props[path];
  }
  return value;
}
function notifySplices(inst, array, path, splices) {
  const splicesData = { indexSplices: splices };
  if (legacyUndefined && !inst._overrideLegacyUndefined) {
    array.splices = splicesData;
  }
  inst.notifyPath(path + '.splices', splicesData);
  inst.notifyPath(path + '.length', array.length);
  if (legacyUndefined && !inst._overrideLegacyUndefined) {
    splicesData.indexSplices = [];
  }
}
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}
const PropertyEffects = dedupingMixin(superClass => {
  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));
  class PropertyEffects extends propertyEffectsBase {
    constructor() {
      super();
      this.__isPropertyEffectsClient = true;
      this.__dataClientsReady;
      this.__dataPendingClients;
      this.__dataToNotify;
      this.__dataLinkedPaths;
      this.__dataHasPaths;
      this.__dataCompoundStorage;
      this.__dataHost;
      this.__dataTemp;
      this.__dataClientsInitialized;
      this.__data;
      this.__dataPending;
      this.__dataOld;
      this.__computeEffects;
      this.__computeInfo;
      this.__reflectEffects;
      this.__notifyEffects;
      this.__propagateEffects;
      this.__observeEffects;
      this.__readOnly;
      this.__templateInfo;
      this._overrideLegacyUndefined;
    }
    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }
    _initializeProperties() {
      super._initializeProperties();
      this._registerHost();
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }
    _registerHost() {
      if (hostStack.length) {
        let host = hostStack[hostStack.length-1];
        host._enqueueClient(this);
        this.__dataHost = host;
      }
    }
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      let effects = ensureOwnEffectMap(this, type, true)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type, true)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification ||
          root$1(Array.isArray(path) ? path[0] : path) !== path) {
        if (!isPathNotification) {
          let old = get$2(this, path);
          path =  (set$2(this, path, value));
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty((path), value, shouldNotify)) {
          computeLinkedPaths(this,  (path), value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty((path), value, shouldNotify);
        } else {
          this[path] = value;
        }
      }
      return false;
    }
    _setUnmanagedPropertyToNode(node, prop, value) {
      if (value !== node[prop] || typeof value == 'object') {
        if (prop === 'className') {
          node = (wrap(node));
        }
        node[prop] = value;
      }
    }
    _setPendingProperty(property, value, shouldNotify) {
      let propIsPath = this.__dataHasPaths && isPath(property);
      let prevProps = propIsPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        if (propIsPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        this.__dataPending[property] = value;
        if (propIsPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i=0; i < clients.length; i++) {
          let client = clients[i];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }
    _readyClients() {
      this.__enableOrFlushClients();
    }
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }
    ready() {
      this._flushProperties();
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      if (this.__dataPending) {
        this._flushProperties();
      }
    }
    _propertiesChanged(currentProps, changedProps, oldProps) {
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      let notifyProps;
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      this._flushClients();
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
    }
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      if (this.__templateInfo) {
        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);
      }
    }
    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {
      const baseRunEffects = (changedProps, hasPaths) => {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,
          hasPaths, templateInfo.nodeList);
        for (let info=templateInfo.firstChild; info; info=info.nextSibling) {
          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);
        }
      };
      if (templateInfo.runEffects) {
        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);
      } else {
        baseRunEffects(changedProps, hasPaths);
      }
    }
    linkPaths(to, from) {
      to = normalize$1(to);
      from = normalize$1(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }
    unlinkPaths(path) {
      path = normalize$1(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }
    notifySplices(path, splices) {
      let info = {path: ''};
      let array = (get$2(this, path, info));
      notifySplices(this, array, info.path, splices);
    }
    get(path, root) {
      return get$2(root || this, path);
    }
    set(path, value, root) {
      if (root) {
        set$2(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][(path)]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }
    push(path, ...items) {
      let info = {path: ''};
      let array = (get$2(this, path, info));
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }
    pop(path) {
      let info = {path: ''};
      let array = (get$2(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }
    splice(path, start, deleteCount, ...items) {
      let info = {path : ''};
      let array = (get$2(this, path, info));
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else if (start) {
        start = Math.floor(start);
      }
      let ret;
      if (arguments.length === 2) {
        ret = array.splice(start);
      } else {
        ret = array.splice(start, deleteCount, ...items);
      }
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }
    shift(path) {
      let info = {path: ''};
      let array = (get$2(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }
    unshift(path, ...items) {
      let info = {path: ''};
      let array = (get$2(this, path, info));
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }
    notifyPath(path, value) {
      let propPath;
      if (arguments.length == 1) {
        let info = {path: ''};
        value = get$2(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        propPath = normalize$1(path);
      } else {
        propPath = (path);
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this['_set' + upper(property)] = function(value) {
          this._setProperty(property, value);
        };
      }
    }
    _createPropertyObserver(property, method, dynamicFn) {
      let info = { property, method, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect, info, trigger: {name: property}
      });
      if (dynamicFn) {
        this._addPropertyEffect((method), TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: {name: method}
        });
      }
    }
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }
    _createReflectedProperty(property) {
      let attr = this.constructor.attributeNameForProperty(property);
      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' +
          attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;
    }
    _marshalArgs(args, path, props) {
      const data = this.__data;
      const values = [];
      for (let i=0, l=args.length; i<l; i++) {
        let {name, structured, wildcard, value, literal} = args[i];
        if (!literal) {
          if (wildcard) {
            const matches = isDescendant(name, path);
            const pathValue = getArgValue(data, props, matches ? path : name);
            value = {
              path: matches ? path : name,
              value: pathValue,
              base: matches ? get$2(data, name) : pathValue
            };
          } else {
            value = structured ? getArgValue(data, props, name) : data[name];
          }
        }
        if (legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {
          return NOOP;
        }
        values[i] = value;
      }
      return values;
    }
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }
    static createPropertyObserver(property, method, dynamicFn) {
      this.prototype._createPropertyObserver(property, method, dynamicFn);
    }
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }
    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    }
    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);
      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        templateInfo = (Object.create(templateInfo));
        templateInfo.wasPreBound = wasPreBound;
        if (!this.__templateInfo) {
          this.__templateInfo = templateInfo;
        } else {
          const parent = template._parentTemplateInfo || this.__templateInfo;
          const previous = parent.lastChild;
          templateInfo.parent = parent;
          parent.lastChild = templateInfo;
          templateInfo.previousSibling = previous;
          if (previous) {
            previous.nextSibling = templateInfo;
          } else {
            parent.firstChild = templateInfo;
          }
        }
      } else {
        this.__preBoundTemplateInfo = templateInfo;
      }
      return templateInfo;
    }
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }
    _stampTemplate(template, templateInfo) {
      templateInfo =  templateInfo || (this._bindTemplate(template, true));
      hostStack.push(this);
      let dom = super._stampTemplate(template, templateInfo);
      hostStack.pop();
      templateInfo.nodeList = dom.nodeList;
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n=dom.firstChild; n; n=n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      setupBindings(this, templateInfo);
      if (this.__dataClientsReady) {
        this._runEffectsForTemplate(templateInfo, this.__data, null, false);
        this._flushClients();
      }
      return dom;
    }
    _removeBoundDom(dom) {
      const templateInfo = dom.templateInfo;
      const {previousSibling, nextSibling, parent} = templateInfo;
      if (previousSibling) {
        previousSibling.nextSibling = nextSibling;
      } else if (parent) {
        parent.firstChild = nextSibling;
      }
      if (nextSibling) {
        nextSibling.previousSibling = previousSibling;
      } else if (parent) {
        parent.lastChild = previousSibling;
      }
      templateInfo.nextSibling = templateInfo.previousSibling = null;
      let nodes = templateInfo.childNodes;
      for (let i=0; i<nodes.length; i++) {
        let node = nodes[i];
        wrap(wrap(node).parentNode).removeChild(node);
      }
    }
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = propertyEffectsBase._parseTemplateNode.call(
        this, node, templateInfo, nodeInfo);
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }
      return noted;
    }
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        let origName = name;
        let kind = 'property';
        if (capitalAttributeRegex.test(name)) {
          kind = 'attribute';
        } else if (name[name.length-1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        }
        let literal = literalFromParts(parts);
        if (literal && kind == 'attribute') {
          if (name == 'class' && node.hasAttribute('class')) {
            literal += ' ' + node.getAttribute(name);
          }
          node.setAttribute(name, literal);
        }
        if (kind == 'attribute' && origName == 'disable-upgrade$') {
          node.setAttribute(name, '');
        }
        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        }
        node.removeAttribute(origName);
        if (kind === 'property') {
          name = dashToCamelCase(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return propertyEffectsBase._parseTemplateNodeAttribute.call(
          this, node, templateInfo, nodeInfo, name, value);
      }
    }
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(
        this, node, templateInfo, nodeInfo);
      const parent = node.parentNode;
      const nestedTemplateInfo = nodeInfo.templateInfo;
      const isDomIf = parent.localName === 'dom-if';
      const isDomRepeat = parent.localName === 'dom-repeat';
      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {
        parent.removeChild(node);
        nodeInfo = nodeInfo.parentInfo;
        nodeInfo.templateInfo = nestedTemplateInfo;
        nodeInfo.noted = true;
        noted = false;
      }
      let hostProps = nestedTemplateInfo.hostProps;
      if (fastDomIf && isDomIf) {
        if (hostProps) {
          templateInfo.hostProps =
            Object.assign(templateInfo.hostProps || {}, hostProps);
          if (!removeNestedTemplates) {
            nodeInfo.parentInfo.noted = true;
          }
        }
      } else {
        let mode = '{';
        for (let source in hostProps) {
          let parts = [{ mode, source, dependencies: [source], hostProp: true }];
          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
        }
      }
      return noted;
    }
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m;
      while ((m = bindingRegex.exec(text)) !== null) {
        if (m.index > lastIndex) {
          parts.push({literal: text.slice(lastIndex, m.index)});
        }
        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false, notifyEvent = '', colon = -1;
        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          let {args, methodName} = signature;
          for (let i=0; i<args.length; i++) {
            let arg = args[i];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          dependencies.push(source);
        }
        parts.push({
          source, mode, negate, customEvent, signature, dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = get$2(inst, part.source);
      } else {
        if (hasPaths && isPath(path)) {
          value = get$2(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }
  }
  return PropertyEffects;
});
const hostStack = [];

function register$1(prototype) {
}

function normalizeProperties(props) {
  const output = {};
  for (let p in props) {
    const o = props[p];
    output[p] = (typeof o === 'function') ? {type: o} : o;
  }
  return output;
}
const PropertiesMixin = dedupingMixin(superClass => {
 const base = PropertiesChanged(superClass);
 function superPropertiesClass(constructor) {
   const superCtor = Object.getPrototypeOf(constructor);
   return (superCtor.prototype instanceof PropertiesMixin) ?
      (superCtor) : null;
 }
 function ownProperties(constructor) {
   if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
     let props = null;
     if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {
       const properties = constructor.properties;
       if (properties) {
        props = normalizeProperties(properties);
       }
     }
     constructor.__ownProperties = props;
   }
   return constructor.__ownProperties;
 }
 class PropertiesMixin extends base {
   static get observedAttributes() {
     if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
       register$1(this.prototype);
       const props = this._properties;
       this.__observedAttributes = props ? Object.keys(props).map(p => this.prototype._addPropertyToAttributeMap(p)) : [];
     }
     return this.__observedAttributes;
   }
   static finalize() {
     if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
       const superCtor = superPropertiesClass((this));
       if (superCtor) {
         superCtor.finalize();
       }
       this.__finalized = true;
       this._finalizeClass();
     }
   }
   static _finalizeClass() {
     const props = ownProperties((this));
     if (props) {
        (this).createProperties(props);
     }
   }
   static get _properties() {
     if (!this.hasOwnProperty(
       JSCompiler_renameProperty('__properties', this))) {
       const superCtor = superPropertiesClass((this));
       this.__properties = Object.assign({},
         superCtor && superCtor._properties,
         ownProperties((this)));
     }
     return this.__properties;
   }
   static typeForProperty(name) {
     const info = this._properties[name];
     return info && info.type;
   }
   _initializeProperties() {
     this.constructor.finalize();
     super._initializeProperties();
   }
   connectedCallback() {
     if (super.connectedCallback) {
       super.connectedCallback();
     }
     this._enableProperties();
   }
   disconnectedCallback() {
     if (super.disconnectedCallback) {
       super.disconnectedCallback();
     }
   }
 }
 return PropertiesMixin;
});

const version$1 = '3.5.1';
const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];
const ElementMixin = dedupingMixin(base => {
  const polymerElementBase = PropertiesMixin(PropertyEffects(base));
  function propertyDefaults(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty('__propertyDefaults', constructor))) {
      constructor.__propertyDefaults = null;
      let props = constructor._properties;
      for (let p in props) {
        let info = props[p];
        if ('value' in info) {
          constructor.__propertyDefaults = constructor.__propertyDefaults || {};
          constructor.__propertyDefaults[p] = info;
        }
      }
    }
    return constructor.__propertyDefaults;
  }
  function ownObservers(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty('__ownObservers', constructor))) {
      constructor.__ownObservers =
          constructor.hasOwnProperty(
              JSCompiler_renameProperty('observers', constructor)) ?
           (constructor).observers :
          null;
    }
    return constructor.__ownObservers;
  }
  function createPropertyFromConfig(proto, name, info, allProps) {
    if (info.computed) {
      info.readOnly = true;
    }
    if (info.computed) {
      if (proto._hasReadOnlyEffect(name)) {
        console.warn(`Cannot redefine computed property '${name}'.`);
      } else {
        proto._createComputedProperty(name, info.computed, allProps);
      }
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {
      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {
      console.warn(`Cannot make reflected property '${name}' non-reflected.`);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    } else if (info.notify === false && proto._hasNotifyEffect(name)) {
      console.warn(`Cannot make notify property '${name}' non-notify.`);
    }
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
    proto._addPropertyToAttributeMap(name);
  }
  function processElementStyles(klass, template, is, baseURI) {
    if (!builtCSS) {
      const templateStyles = template.content.querySelectorAll('style');
      const stylesWithImports = stylesFromTemplate(template);
      const linkedStyles = stylesFromModuleImports(is);
      const firstTemplateChild = template.content.firstElementChild;
      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s = linkedStyles[idx];
        s.textContent = klass._processStyleText(s.textContent, baseURI);
        template.content.insertBefore(s, firstTemplateChild);
      }
      let templateStyleIndex = 0;
      for (let i = 0; i < stylesWithImports.length; i++) {
        let s = stylesWithImports[i];
        let templateStyle = templateStyles[templateStyleIndex];
        if (templateStyle !== s) {
          s = s.cloneNode(true);
          templateStyle.parentNode.insertBefore(s, templateStyle);
        } else {
          templateStyleIndex++;
        }
        s.textContent = klass._processStyleText(s.textContent, baseURI);
      }
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is);
    }
    if (useAdoptedStyleSheetsWithBuiltCSS && builtCSS &&
        supportsAdoptingStyleSheets) {
      const styles = template.content.querySelectorAll('style');
      if (styles) {
        let css = '';
        Array.from(styles).forEach(s => {
          css += s.textContent;
          s.parentNode.removeChild(s);
        });
        klass._styleSheet = new CSSStyleSheet();
        klass._styleSheet.replaceSync(css);
      }
    }
  }
  function getTemplateFromDomModule(is) {
    let template = null;
    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {
      template =  (
          DomModule.import(is, 'template'));
      if (strictTemplatePolicy && !template) {
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
      }
    }
    return template;
  }
  class PolymerElement extends polymerElementBase {
    static get polymerElementVersion() {
      return version$1;
    }
    static _finalizeClass() {
      polymerElementBase._finalizeClass.call(this);
      const observers = ownObservers(this);
      if (observers) {
        this.createObservers(observers, this._properties);
      }
      this._prepareTemplate();
    }
    static _prepareTemplate() {
      let template =  (this).template;
      if (template) {
        if (typeof template === 'string') {
          console.error('template getter must return HTMLTemplateElement');
          template = null;
        } else if (!legacyOptimizations) {
          template = template.cloneNode(true);
        }
      }
      this.prototype._template = template;
    }
    static createProperties(props) {
      for (let p in props) {
        createPropertyFromConfig(
             (this.prototype), p, props[p], props);
      }
    }
    static createObservers(observers, dynamicFns) {
      const proto = this.prototype;
      for (let i=0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        let protoTemplate = this.prototype.hasOwnProperty(
          JSCompiler_renameProperty('_template', this.prototype)) ?
          this.prototype._template : undefined;
        if (typeof protoTemplate === 'function') {
          protoTemplate = protoTemplate();
        }
        this._template =
          protoTemplate !== undefined ? protoTemplate :
          ((this.hasOwnProperty(JSCompiler_renameProperty('is', this)) &&
          (getTemplateFromDomModule( (this).is))) ||
          Object.getPrototypeOf( (this).prototype).constructor.template);
      }
      return this._template;
    }
    static set template(value) {
      this._template = value;
    }
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
        const meta = this.importMeta;
        if (meta) {
          this._importPath = pathFromUrl(meta.url);
        } else {
          const module = DomModule.import( (this).is);
          this._importPath = (module && module.assetpath) ||
            Object.getPrototypeOf( (this).prototype).constructor.importPath;
        }
      }
      return this._importPath;
    }
    constructor() {
      super();
      this._template;
      this._importPath;
      this.rootPath;
      this.importPath;
      this.root;
      this.$;
    }
    _initializeProperties() {
      this.constructor.finalize();
      this.constructor._finalizeTemplate((this).localName);
      super._initializeProperties();
      this.rootPath = rootPath;
      this.importPath = this.constructor.importPath;
      let p$ = propertyDefaults(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        if (this._canApplyPropertyDefault(p)) {
          let value = typeof info.value == 'function' ?
            info.value.call(this) :
            info.value;
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }
    _canApplyPropertyDefault(property) {
      return !this.hasOwnProperty(property);
    }
    static _processStyleText(cssText, baseURI) {
      return resolveCss(cssText, baseURI);
    }
    static _finalizeTemplate(is) {
      const template = this.prototype._template;
      if (template && !template.__polymerFinalized) {
        template.__polymerFinalized = true;
        const importPath = this.importPath;
        const baseURI = importPath ? resolveUrl(importPath) : '';
        processElementStyles(this, template, is, baseURI);
        this.prototype._bindTemplate(template);
      }
    }
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement((this));
      }
      super.connectedCallback();
    }
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom((this.root));
      }
      super._readyClients();
    }
    _attachDom(dom) {
      const n = wrap(this);
      if (n.attachShadow) {
        if (dom) {
          if (!n.shadowRoot) {
            n.attachShadow({mode: 'open', shadyUpgradeFragment: dom});
            n.shadowRoot.appendChild(dom);
            if (this.constructor._styleSheet) {
              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];
            }
          }
          if (syncInitialRender && window.ShadyDOM) {
            window.ShadyDOM.flushInitial(n.shadowRoot);
          }
          return n.shadowRoot;
        }
        return null;
      } else {
        throw new Error('ShadowDOM not available. ' +
        'PolymerElement can create dom as children instead of in ' +
        'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree((this), properties);
      }
    }
    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = resolveUrl(this.importPath);
      }
      return resolveUrl(url, base);
    }
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
      return polymerElementBase._parseTemplateContent.call(
        this, template, templateInfo, nodeInfo);
    }
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      if (legacyWarnings && !(prop in this._properties) &&
          !(effect.info.part.signature && effect.info.part.signature.static) &&
          !effect.info.part.hostProp && !templateInfo.nestedTemplate) {
        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` +
          `attribute will not be observed.`);
      }
      return polymerElementBase._addTemplatePropertyEffect.call(
        this, templateInfo, prop, effect);
    }
  }
  return PolymerElement;
});

const policy = window.trustedTypes &&
    trustedTypes.createPolicy('polymer-html-literal', {createHTML: (s) => s});
class LiteralString {
  constructor(strings, values) {
    assertValidTemplateStringParameters(strings, values);
    const string = values.reduce(
        (acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]);
    this.value = string.toString();
  }
  toString() {
    return this.value;
  }
}
function literalValue(value) {
  if (value instanceof LiteralString) {
    return (value).value;
  } else {
    throw new Error(
        `non-literal value passed to Polymer's htmlLiteral function: ${value}`
    );
  }
}
function htmlValue(value) {
  if (value instanceof HTMLTemplateElement) {
    return (value).innerHTML;
  } else if (value instanceof LiteralString) {
    return literalValue(value);
  } else {
    throw new Error(
        `non-template value passed to Polymer's html function: ${value}`);
  }
}
const html$3 = function html(strings, ...values) {
  assertValidTemplateStringParameters(strings, values);
  const template =
       (document.createElement('template'));
  let value = values.reduce(
      (acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);
  if (policy) {
    value = policy.createHTML(value);
  }
  template.innerHTML = value;
  return template;
};
const assertValidTemplateStringParameters = (strings, values) => {
  if (!Array.isArray(strings) || !Array.isArray(strings.raw) ||
      (values.length !== strings.length - 1)) {
    throw new TypeError('Invalid call to the html template tag');
  }
};

const PolymerElement = ElementMixin(HTMLElement);

function mutablePropertyChange$1(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = (typeof value === 'object' && value !== null);
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  let shouldChange = (old !== value && (old === old || value === value));
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}
const MutableData = dedupingMixin(superClass => {
  class MutableData extends superClass {
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange$1(this, property, value, old, true);
    }
  }
  return MutableData;
});
const OptionalMutableData = dedupingMixin(superClass => {
  class OptionalMutableData extends superClass {
    static get properties() {
      return {
        mutableData: Boolean
      };
    }
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange$1(this, property, value, old, this.mutableData);
    }
  }
  return OptionalMutableData;
});
MutableData._mutablePropertyChange = mutablePropertyChange$1;

class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue.delete(this);
      this._callback();
    });
  }
  cancel() {
    if (this.isActive()) {
      this._cancelAsync();
      debouncerQueue.delete(this);
    }
  }
  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel((this._timer));
      this._timer = null;
    }
  }
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  isActive() {
    return this._timer != null;
  }
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}
let debouncerQueue = new Set();
const enqueueDebouncer = function(debouncer) {
  debouncerQueue.add(debouncer);
};
const flushDebouncers = function() {
  const didFlush = Boolean(debouncerQueue.size);
  debouncerQueue.forEach(debouncer => {
    try {
      debouncer.flush();
    } catch(e) {
      setTimeout(() => {
        throw e;
      });
    }
  });
  return didFlush;
};

var debounce = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Debouncer: Debouncer,
	enqueueDebouncer: enqueueDebouncer,
	flushDebouncers: flushDebouncers
});

let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
let TRACK_LENGTH = 2;
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
let MOUSE_HAS_BUTTONS = (function() {
  try {
    return new MouseEvent('test', {buttons: 1}).buttons === 1;
  } catch (e) {
    return false;
  }
})();
function isMouseEvent(name) {
  return MOUSE_EVENTS.indexOf(name) > -1;
}
let supportsPassive = false;
(function() {
  try {
    let opts = Object.defineProperty({}, 'passive', {get() {supportsPassive = true;}});
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch(e) {}
})();
function PASSIVE_TOUCH(eventName) {
  if (isMouseEvent(eventName) || eventName === 'touchend') {
    return;
  }
  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {
    return {passive: true};
  } else {
    return;
  }
}
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
const clickedLabels = [];
const labellable = {
  'button': true,
  'input': true,
  'keygen': true,
  'meter': true,
  'output': true,
  'textarea': true,
  'progress': true,
  'select': true
};
const canBeDisabled = {
  'button': true,
  'command': true,
  'fieldset': true,
  'input': true,
  'keygen': true,
  'optgroup': true,
  'option': true,
  'select': true,
  'textarea': true
};
function canBeLabelled(el) {
  return labellable[el.localName] || false;
}
function matchingLabels(el) {
  let labels = Array.prototype.slice.call((el).labels || []);
  if (!labels.length) {
    labels = [];
    try {
      let root = el.getRootNode();
      if (el.id) {
        let matching = root.querySelectorAll(`label[for = '${el.id}']`);
        for (let i = 0; i < matching.length; i++) {
          labels.push((matching[i]));
        }
      }
    } catch (e) {
    }
  }
  return labels;
}
let mouseCanceller = function(mouseEvent) {
  let sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  mouseEvent[HANDLED_OBJ] = {skip: true};
  if (mouseEvent.type === 'click') {
    let clickFromLabel = false;
    let path = getComposedPath(mouseEvent);
    for (let i = 0; i < path.length; i++) {
      if (path[i].nodeType === Node.ELEMENT_NODE) {
        if (path[i].localName === 'label') {
          clickedLabels.push( (path[i]));
        } else if (canBeLabelled( (path[i]))) {
          let ownerLabels =
              matchingLabels( (path[i]));
          for (let j = 0; j < ownerLabels.length; j++) {
            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
          }
        }
      }
      if (path[i] === POINTERSTATE.mouse.target) {
        return;
      }
    }
    if (clickFromLabel) {
      return;
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};
function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (let i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      clickedLabels.length = 0;
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}
function ignoreMouse(e) {
  if (!cancelSyntheticClickEvents) {
    return;
  }
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  let unset = function() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = getComposedPath(e)[0];
  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(
        POINTERSTATE.mouse.mouseIgnoreJob
      , timeOut.after(MOUSE_TIMEOUT)
      , unset);
}
function hasLeftMouseButton(ev) {
  let type = ev.type;
  if (!isMouseEvent(type)) {
    return false;
  }
  if (type === 'mousemove') {
    let buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    return Boolean(buttons & 1);
  } else {
    let button = ev.button === undefined ? 0 : ev.button;
    return button === 0;
  }
}
function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    if (ev.detail === 0) {
      return true;
    }
    let t = _findOriginalTarget(ev);
    if (!t.nodeType || (t).nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    let bcr = (t).getBoundingClientRect();
    let x = ev.pageX, y = ev.pageY;
    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
  }
  return false;
}
let POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};
function firstTouchAction(ev) {
  let ta = 'auto';
  let path = getComposedPath(ev);
  for (let i = 0, n; i < path.length; i++) {
    n = path[i];
    if (n[TOUCH_ACTION]) {
      ta = n[TOUCH_ACTION];
      break;
    }
  }
  return ta;
}
function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}
if (cancelSyntheticClickEvents) {
  document.addEventListener('touchend', ignoreMouse, supportsPassive ? {passive: true} : false);
}
const getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ?
  window.ShadyDOM.composedPath :
  (event) => event.composedPath && event.composedPath() || [];
const gestures = {};
const recognizers = [];
function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node;
  while (next && next.shadowRoot && !window.ShadyDOM) {
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}
function _findOriginalTarget(ev) {
  const path = getComposedPath( (ev));
  return path.length > 0 ? path[0] : ev.target;
}
function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  let gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = (ev);
      let t = ev.changedTouches[0];
      if (type === 'touchstart') {
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  if (handled.skip) {
    return;
  }
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}
function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let shouldPrevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) ; else if (ta === 'none') {
      shouldPrevent = true;
    } else if (ta === 'pan-x') {
      shouldPrevent = dy > dx;
    } else if (ta === 'pan-y') {
      shouldPrevent = dx > dy;
    }
    if (shouldPrevent) {
      ev.preventDefault();
    } else {
      prevent('track');
    }
  }
}
function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}
function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}
function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = {_count: 0};
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}
function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}
function register(recog) {
  recognizers.push(recog);
  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}
function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}
function setTouchAction(node, value) {
  if (HAS_NATIVE_TA && node instanceof HTMLElement) {
    microTask.run(() => {
      node.style.touchAction = value;
    });
  }
  node[TOUCH_ACTION] = value;
}
function _fire(target, type, detail) {
  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  wrap((target)).dispatchEvent(ev);
  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}
function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}
function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}
register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],
  info: {
    movefn: null,
    upfn: null
  },
  reset: function() {
    untrackDocument(this.info);
  },
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        downupFire('up', t, e);
        untrackDocument(self.info);
      }
    };
    let upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        downupFire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    downupFire('down', t, e);
  },
  touchstart: function(e) {
    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  touchend: function(e) {
    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  }
});
function downupFire(type, target, event, preventer) {
  if (!target) {
    return;
  }
  _fire(target, type, {
    x: event.clientX,
    y: event.clientY,
    sourceEvent: event,
    preventer: preventer,
    prevent: function(e) {
      return prevent(e);
    }
  });
}
register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],
  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    addMove: function(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },
  reset: function() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      let x = e.clientX, y = e.clientY;
      if (trackHasMovedEnough(self.info, x, y)) {
        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
        if (self.info.state === 'start') {
          prevent('tap');
        }
        self.info.addMove({x: x, y: y});
        if (!hasLeftMouseButton(e)) {
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        if (t) {
          trackFire(self.info, t, e);
        }
        self.info.started = true;
      }
    };
    let upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  touchstart: function(e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  touchmove: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    let x = ct.clientX, y = ct.clientY;
    if (trackHasMovedEnough(this.info, x, y)) {
      if (this.info.state === 'start') {
        prevent('tap');
      }
      this.info.addMove({x: x, y: y});
      trackFire(this.info, t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  touchend: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    if (this.info.started) {
      this.info.state = 'end';
      this.info.addMove({x: ct.clientX, y: ct.clientY});
      trackFire(this.info, t, ct);
    }
  }
});
function trackHasMovedEnough(info, x, y) {
  if (info.prevent) {
    return false;
  }
  if (info.started) {
    return true;
  }
  let dx = Math.abs(info.x - x);
  let dy = Math.abs(info.y - y);
  return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
}
function trackFire(info, target, touch) {
  if (!target) {
    return;
  }
  let secondlast = info.moves[info.moves.length - 2];
  let lastmove = info.moves[info.moves.length - 1];
  let dx = lastmove.x - info.x;
  let dy = lastmove.y - info.y;
  let ddx, ddy = 0;
  if (secondlast) {
    ddx = lastmove.x - secondlast.x;
    ddy = lastmove.y - secondlast.y;
  }
  _fire(target, 'track', {
    state: info.state,
    x: touch.clientX,
    y: touch.clientY,
    dx: dx,
    dy: dy,
    ddx: ddx,
    ddy: ddy,
    sourceEvent: touch,
    hover: function() {
      return deepTargetFind(touch.clientX, touch.clientY);
    }
  });
}
register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  reset: function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  mousedown: function(e) {
    if (hasLeftMouseButton(e)) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    }
  },
  click: function(e) {
    if (hasLeftMouseButton(e)) {
      trackForward(this.info, e);
    }
  },
  touchstart: function(e) {
    const touch = e.changedTouches[0];
    this.info.x = touch.clientX;
    this.info.y = touch.clientY;
  },
  touchend: function(e) {
    trackForward(this.info, e.changedTouches[0], e);
  }
});
function trackForward(info, e, preventer) {
  let dx = Math.abs(e.clientX - info.x);
  let dy = Math.abs(e.clientY - info.y);
  let t = _findOriginalTarget((preventer || e));
  if (!t || (canBeDisabled[(t).localName] && t.hasAttribute('disabled'))) {
    return;
  }
  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
    if (!info.prevent) {
      _fire(t, 'tap', {
        x: e.clientX,
        y: e.clientY,
        sourceEvent: e,
        preventer: preventer
      });
    }
  }
}
const findOriginalTarget = _findOriginalTarget;
const add$1 = addListener;
const remove$1 = removeListener;

var gestures$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	add: add$1,
	addListener: addListener,
	deepTargetFind: deepTargetFind,
	findOriginalTarget: findOriginalTarget,
	gestures: gestures,
	prevent: prevent,
	recognizers: recognizers,
	register: register,
	remove: remove$1,
	removeListener: removeListener,
	resetMouseCanceller: resetMouseCanceller,
	setTouchAction: setTouchAction
});

const GestureEventListeners = dedupingMixin((superClass) => {
  class GestureEventListeners extends superClass {
    _addEventListenerToNode(node, eventName, handler) {
      if (!addListener(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }
    _removeEventListenerFromNode(node, eventName, handler) {
      if (!removeListener(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }
  }
  return GestureEventListeners;
});

let elementsHidden = false;
function hideElementsGlobally() {
  if (legacyOptimizations && !useShadow) {
    if (!elementsHidden) {
      elementsHidden = true;
      const style = document.createElement('style');
      style.textContent = 'dom-bind,dom-if,dom-repeat{display:none;}';
      document.head.appendChild(style);
    }
    return true;
  }
  return false;
}

const domBindBase =
  GestureEventListeners(
    OptionalMutableData(
      PropertyEffects(HTMLElement)));
class DomBind extends domBindBase {
  static get observedAttributes() { return ['mutable-data']; }
  constructor() {
    super();
    if (strictTemplatePolicy) {
      throw new Error(`strictTemplatePolicy: dom-bind not allowed`);
    }
    this.root = null;
    this.$ = null;
    this.__children = null;
  }
  attributeChangedCallback(name, old, value, namespace) {
    this.mutableData = true;
  }
  connectedCallback() {
    if (!hideElementsGlobally()) {
      this.style.display = 'none';
    }
    this.render();
  }
  disconnectedCallback() {
    this.__removeChildren();
  }
  __insertChildren() {
    wrap(wrap(this).parentNode).insertBefore(this.root, this);
  }
  __removeChildren() {
    if (this.__children) {
      for (let i=0; i<this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }
  render() {
    let template;
    if (!this.__children) {
      template = (template || this.querySelector('template'));
      if (!template) {
        let observer = new MutationObserver(() => {
          template = (this.querySelector('template'));
          if (template) {
            observer.disconnect();
            this.render();
          } else {
            throw new Error('dom-bind requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return;
      }
      this.root = this._stampTemplate(
        (template));
      this.$ = this.root.$;
      this.__children = [];
      for (let n=this.root.firstChild; n; n=n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
  }
}
customElements.define('dom-bind', DomBind);

const flush$1 = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};

let newInstance = null;
function HTMLTemplateElementExtension() { return newInstance; }
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
const DataTemplate = PropertyEffects(HTMLTemplateElementExtension);
const MutableDataTemplate = MutableData(DataTemplate);
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}
const templateInstanceBase = PropertyEffects(class {});
function showHideChildren(hide, children) {
  for (let i=0; i<children.length; i++) {
    let n = children[i];
    if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
      if (n.nodeType === Node.TEXT_NODE) {
        if (hide) {
          n.__polymerTextContent__ = n.textContent;
          n.textContent = '';
        } else {
          n.textContent = n.__polymerTextContent__;
        }
      } else if (n.localName === 'slot') {
        if (hide) {
          n.__polymerReplaced__ = document.createComment('hidden-slot');
          wrap(wrap(n).parentNode).replaceChild(n.__polymerReplaced__, n);
        } else {
          const replace = n.__polymerReplaced__;
          if (replace) {
            wrap(wrap(replace).parentNode).replaceChild(n, replace);
          }
        }
      }
      else if (n.style) {
        if (hide) {
          n.__polymerDisplay__ = n.style.display;
          n.style.display = 'none';
        } else {
          n.style.display = n.__polymerDisplay__;
        }
      }
    }
    n.__hideTemplateChildren__ = hide;
    if (n._showHideChildren) {
      n._showHideChildren(hide);
    }
  }
}
class TemplateInstanceBase extends templateInstanceBase {
  constructor(props) {
    super();
    this._configureProperties(props);
    this.root = this._stampTemplate(this.__dataHost);
    let children = [];
    this.children =  (children);
    for (let n = this.root.firstChild; n; n=n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner &&
      this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    let options = this.__templatizeOptions;
    if ((props && options.instanceProps) || !options.instanceProps) {
      this._enableProperties();
    }
  }
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (options.forwardHostProp) {
      for (let hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
      }
    }
    for (let iprop in props) {
      this._setPendingProperty(iprop, props[iprop]);
    }
  }
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      this._methodHost._addEventListenerToNode(node, eventName, (e) => {
        e.model = this;
        handler(e);
      });
    } else {
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  _showHideChildren(hide) {
    showHideChildren(hide, this.children);
  }
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ &&
        node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }
   dispatchEvent(event) {
     return true;
  }
}
TemplateInstanceBase.prototype.__dataHost;
TemplateInstanceBase.prototype.__templatizeOptions;
TemplateInstanceBase.prototype._methodHost;
TemplateInstanceBase.prototype.__templatizeOwner;
TemplateInstanceBase.prototype.__hostProps;
const MutableTemplateInstanceBase = MutableData(
     (TemplateInstanceBase));
function findMethodHost(template) {
  let templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}
function createTemplatizerClass(template, templateInfo, options) {
  let templatizerBase = options.mutableData ?
    MutableTemplateInstanceBase : TemplateInstanceBase;
  if (templatize.mixin) {
    templatizerBase = templatize.mixin(templatizerBase);
  }
  let klass = class extends templatizerBase { };
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}
function addPropagateEffects(target, templateInfo, options, methodHost) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp && templateInfo.hasHostProps) {
    const isTemplate = target.localName == 'template';
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      if (isTemplate) {
        let templatizedBase =
            options.mutableData ? MutableDataTemplate : DataTemplate;
        class TemplatizedTemplate extends templatizedBase {}
        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
      } else {
        const templatizedBase = target.constructor;
        class TemplatizedTemplateExtension extends templatizedBase {}
        klass = templateInfo.templatizeTemplateClass =
            TemplatizedTemplateExtension;
      }
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          {fn: createForwardHostPropEffect(prop, userForwardHostProp)});
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
      if (legacyWarnings && methodHost) {
        warnOnUndeclaredProperties(templateInfo, options, methodHost);
      }
    }
    if (target.__dataProto) {
      Object.assign(target.__data, target.__dataProto);
    }
    if (isTemplate) {
      upgradeTemplate(target, klass);
      target.__dataTemp = {};
      target.__dataPending = null;
      target.__dataOld = null;
      target._enableProperties();
    } else {
      Object.setPrototypeOf(target, klass.prototype);
      const hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        prop = '_host_' + prop;
        if (prop in target) {
          const val = target[prop];
          delete target[prop];
          target.__data[prop] = val;
        }
      }
    }
  }
}
function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner,
      prop.substring('_host_'.length), props[prop]);
  };
}
function addNotifyEffects(klass, template, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (let hprop in hostProps) {
      if (!templateInfo.hasHostProps) {
        templateInfo.hasHostProps = true;
      }
      klass.prototype._addPropertyEffect(hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyHostPropEffect()});
    }
  }
}
function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner,
      inst, prop, props[prop]);
  };
}
function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}
function templatize(template, owner, options) {
  if (strictTemplatePolicy && !findMethodHost(template)) {
    throw new Error('strictTemplatePolicy: template owner not trusted');
  }
  options = (options || {});
  if (template.__templatizeOwner) {
    throw new Error('A <template> can only be templatized once');
  }
  template.__templatizeOwner = owner;
  const ctor = owner ? owner.constructor : TemplateInstanceBase;
  let templateInfo = ctor._parseTemplate(template);
  let baseClass = templateInfo.templatizeInstanceClass;
  if (!baseClass) {
    baseClass = createTemplatizerClass(template, templateInfo, options);
    templateInfo.templatizeInstanceClass = baseClass;
  }
  const methodHost = findMethodHost(template);
  addPropagateEffects(template, templateInfo, options, methodHost);
  let klass = class TemplateInstance extends baseClass {};
  klass.prototype._methodHost = methodHost;
  klass.prototype.__dataHost =  (template);
  klass.prototype.__templatizeOwner =  (owner);
  klass.prototype.__hostProps = templateInfo.hostProps;
  klass = (klass);
  return klass;
}
function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
  const declaredProps = methodHost.constructor._properties;
  const {propertyEffects} = templateInfo;
  const {instanceProps} = options;
  for (let prop in propertyEffects) {
    if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
      const effects = propertyEffects[prop];
      for (let i=0; i<effects.length; i++) {
        const {part} = effects[i].info;
        if (!(part.signature && part.signature.static)) {
          console.warn(`Property '${prop}' used in template but not ` +
            `declared in 'properties'; attribute will not be observed.`);
          break;
        }
      }
    }
  }
}
function modelForElement(template, node) {
  let model;
  while (node) {
    if ((model = node.__dataHost ? node : node.__templatizeInstance)) {
      if (model.__dataHost != template) {
        node = model.__dataHost;
      } else {
        return model;
      }
    } else {
      node = wrap(node).parentNode;
    }
  }
  return null;
}

var templatize$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	TemplateInstanceBase: TemplateInstanceBase,
	modelForElement: modelForElement,
	showHideChildren: showHideChildren,
	templatize: templatize
});

class DomIfBase extends PolymerElement {
  static get is() { return 'dom-if'; }
  static get template() { return null; }
  static get properties() {
    return {
      if: {
        type: Boolean,
        observer: '__debounceRender'
      },
      restamp: {
        type: Boolean,
        observer: '__debounceRender'
      },
      notifyDomChange: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__renderDebouncer = null;
    this._lastIf = false;
    this.__hideTemplateChildren__ = false;
    this.__template;
    this._templateInfo;
  }
  __debounceRender() {
    this.__renderDebouncer = Debouncer.debounce(
          this.__renderDebouncer
        , microTask
        , () => this.__render());
    enqueueDebouncer(this.__renderDebouncer);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = wrap(this).parentNode;
    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
        !wrap(parent).host)) {
      this.__teardownInstance();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = 'none';
    }
    if (this.if) {
      this.__debounceRender();
    }
  }
  __ensureTemplate() {
    if (!this.__template) {
      const thisAsTemplate =  (
           (this));
      let template = thisAsTemplate._templateInfo ?
          thisAsTemplate :
          (wrap(thisAsTemplate).querySelector('template'));
      if (!template) {
        let observer = new MutationObserver(() => {
          if (wrap(this).querySelector('template')) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error('dom-if requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return false;
      }
      this.__template = template;
    }
    return true;
  }
  __ensureInstance() {
    let parentNode = wrap(this).parentNode;
    if (!this.__hasInstance()) {
      if (!parentNode) {
        return false;
      }
      if (!this.__ensureTemplate()) {
        return false;
      }
      this.__createAndInsertInstance(parentNode);
    } else {
      let children = this.__getInstanceNodes();
      if (children && children.length) {
        let lastChild = wrap(this).previousSibling;
        if (lastChild !== children[children.length-1]) {
          for (let i=0, n; (i<children.length) && (n=children[i]); i++) {
            wrap(parentNode).insertBefore(n, this);
          }
        }
      }
    }
    return true;
  }
  render() {
    flush$1();
  }
  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        return;
      }
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    this._showHideChildren();
    if ((!suppressTemplateNotifications || this.notifyDomChange)
        && this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }
  __hasInstance() { }
  __getInstanceNodes() { }
  __createAndInsertInstance(parentNode) { }
  __teardownInstance() { }
  _showHideChildren() { }
}
class DomIfFast extends DomIfBase {
  constructor() {
    super();
    this.__instance = null;
    this.__syncInfo = null;
  }
  __hasInstance() {
    return Boolean(this.__instance);
  }
  __getInstanceNodes() {
    return this.__instance.templateInfo.childNodes;
  }
  __createAndInsertInstance(parentNode) {
    const host = this.__dataHost || this;
    if (strictTemplatePolicy) {
      if (!this.__dataHost) {
        throw new Error('strictTemplatePolicy: template owner not trusted');
      }
    }
    const templateInfo = host._bindTemplate(
         (this.__template), true);
    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {
      let syncInfo = this.__syncInfo;
      if (this.if) {
        if (syncInfo) {
          this.__syncInfo = null;
          this._showHideChildren();
          changedProps = Object.assign(syncInfo.changedProps, changedProps);
        }
        runEffects(changedProps, hasPaths);
      } else {
        if (this.__instance) {
          if (!syncInfo) {
            syncInfo = this.__syncInfo = { runEffects, changedProps: {} };
          }
          if (hasPaths) {
            for (const p in changedProps) {
              const rootProp = root$1(p);
              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
            }
          } else {
            Object.assign(syncInfo.changedProps, changedProps);
          }
        }
      }
    };
    this.__instance = host._stampTemplate(
         (this.__template), templateInfo);
    wrap(parentNode).insertBefore(this.__instance, this);
  }
  __syncHostProperties() {
    const syncInfo = this.__syncInfo;
    if (syncInfo) {
      this.__syncInfo = null;
      syncInfo.runEffects(syncInfo.changedProps, false);
    }
  }
  __teardownInstance() {
    const host = this.__dataHost || this;
    if (this.__instance) {
      host._removeBoundDom(this.__instance);
      this.__instance = null;
      this.__syncInfo = null;
    }
  }
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      showHideChildren(hidden, this.__instance.templateInfo.childNodes);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
}
class DomIfLegacy extends DomIfBase {
  constructor() {
    super();
    this.__ctor = null;
    this.__instance = null;
    this.__invalidProps = null;
  }
  __hasInstance() {
    return Boolean(this.__instance);
  }
  __getInstanceNodes() {
    return this.__instance.children;
  }
  __createAndInsertInstance(parentNode) {
    if (!this.__ctor) {
      this.__ctor = templatize(
           (this.__template), this, {
            mutableData: true,
            forwardHostProp: function(prop, value) {
              if (this.__instance) {
                if (this.if) {
                  this.__instance.forwardHostProp(prop, value);
                } else {
                  this.__invalidProps =
                      this.__invalidProps || Object.create(null);
                  this.__invalidProps[root$1(prop)] = true;
                }
              }
            }
          });
    }
    this.__instance = new this.__ctor();
    wrap(parentNode).insertBefore(this.__instance.root, this);
  }
  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        let parent = wrap(c$[0]).parentNode;
        if (parent) {
          parent = wrap(parent);
          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
            parent.removeChild(n);
          }
        }
      }
      this.__invalidProps = null;
      this.__instance = null;
    }
  }
  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      this.__invalidProps = null;
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__instance._flushProperties();
    }
  }
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      this.__instance._showHideChildren(hidden);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
}
const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;
customElements.define(DomIf.is, DomIf);

const domRepeatBase = OptionalMutableData(PolymerElement);
class DomRepeat extends domRepeatBase {
  static get is() { return 'dom-repeat'; }
  static get template() { return null; }
  static get properties() {
    return {
      items: {
        type: Array
      },
      as: {
        type: String,
        value: 'item'
      },
      indexAs: {
        type: String,
        value: 'index'
      },
      itemsIndexAs: {
        type: String,
        value: 'itemsIndex'
      },
      sort: {
        type: Function,
        observer: '__sortChanged'
      },
      filter: {
        type: Function,
        observer: '__filterChanged'
      },
      observe: {
        type: String,
        observer: '__observeChanged'
      },
      delay: Number,
      renderedItemCount: {
        type: Number,
        notify: !suppressTemplateNotifications,
        readOnly: true
      },
      initialCount: {
        type: Number
      },
      targetFramerate: {
        type: Number,
        value: 20
      },
      _targetFrameTime: {
        type: Number,
        computed: '__computeFrameTime(targetFramerate)'
      },
      notifyDomChange: {
        type: Boolean
      },
      reuseChunkedInstances: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return [ '__itemsChanged(items.*)' ];
  }
  constructor() {
    super();
    this.__instances = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__renderStartTime = null;
    this.__itemsArrayChanged = false;
    this.__shouldMeasureChunk = false;
    this.__shouldContinueChunking = false;
    this.__chunkingId = 0;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
    this._templateInfo;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i=0; i<this.__instances.length; i++) {
      this.__detachInstance(i);
    }
    if (this.__chunkingId) {
      cancelAnimationFrame(this.__chunkingId);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = 'none';
    }
    if (this.__isDetached) {
      this.__isDetached = false;
      let wrappedParent = wrap(wrap(this).parentNode);
      for (let i=0; i<this.__instances.length; i++) {
        this.__attachInstance(i, wrappedParent);
      }
      if (this.__chunkingId) {
        this.__render();
      }
    }
  }
  __ensureTemplatized() {
    if (!this.__ctor) {
      const thisAsTemplate =  (
           (this));
      let template = this.template = thisAsTemplate._templateInfo ?
          thisAsTemplate :
           (this.querySelector('template'));
      if (!template) {
        let observer = new MutationObserver(() => {
          if (this.querySelector('template')) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error('dom-repeat requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return false;
      }
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = templatize(template, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps: instanceProps,
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
            inst.forwardHostProp(prop, value);
          }
        },
        notifyInstanceProp: function(inst, prop, value) {
          if (matches$2(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }
  __getMethodHost() {
    return this.__dataHost._methodHost || this.__dataHost;
  }
  __functionFromPropertyValue(functionOrMethodName) {
    if (typeof functionOrMethodName === 'string') {
      let methodName = functionOrMethodName;
      let obj = this.__getMethodHost();
      return function() { return obj[methodName].apply(obj, arguments); };
    }
    return functionOrMethodName;
  }
  __sortChanged(sort) {
    this.__sortFn = this.__functionFromPropertyValue(sort);
    if (this.items) { this.__debounceRender(this.__render); }
  }
  __filterChanged(filter) {
    this.__filterFn = this.__functionFromPropertyValue(filter);
    if (this.items) { this.__debounceRender(this.__render); }
  }
  __computeFrameTime(rate) {
    return Math.ceil(1000/rate);
  }
  __observeChanged() {
    this.__observePaths = this.observe &&
      this.observe.replace('.*', '.').split(' ');
  }
  __handleObservedPaths(path) {
    if (this.__sortFn || this.__filterFn) {
      if (!path) {
        this.__debounceRender(this.__render, this.delay);
      } else if (this.__observePaths) {
        let paths = this.__observePaths;
        for (let i=0; i<paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__debounceRender(this.__render, this.delay);
          }
        }
      }
    }
  }
  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn('dom-repeat expected array for `items`, found', this.items);
    }
    if (!this.__handleItemPath(change.path, change.value)) {
      if (change.path === 'items') {
        this.__itemsArrayChanged = true;
      }
      this.__debounceRender(this.__render);
    }
  }
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = Debouncer.debounce(
          this.__renderDebouncer
        , delay > 0 ? timeOut.after(delay) : microTask
        , fn.bind(this));
    enqueueDebouncer(this.__renderDebouncer);
  }
  render() {
    this.__debounceRender(this.__render);
    flush$1();
  }
  __render() {
    if (!this.__ensureTemplatized()) {
      return;
    }
    let items = this.items || [];
    const isntIdxToItemsIdx = this.__sortAndFilterItems(items);
    const limit = this.__calculateLimit(isntIdxToItemsIdx.length);
    this.__updateInstances(items, limit, isntIdxToItemsIdx);
    if (this.initialCount &&
       (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {
      cancelAnimationFrame(this.__chunkingId);
      this.__chunkingId = requestAnimationFrame(() => {
        this.__chunkingId = null;
        this.__continueChunking();
      });
    }
    this._setRenderedItemCount(this.__instances.length);
    if (!suppressTemplateNotifications || this.notifyDomChange) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
    }
  }
  __sortAndFilterItems(items) {
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i=0; i<items.length; i++) {
      isntIdxToItemsIdx[i] = i;
    }
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>
        this.__filterFn(items[i], idx, array));
    }
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
    }
    return isntIdxToItemsIdx;
  }
  __calculateLimit(filteredItemCount) {
    let limit = filteredItemCount;
    const currentCount = this.__instances.length;
    if (this.initialCount) {
      let newCount;
      if (!this.__chunkCount ||
        (this.__itemsArrayChanged && !this.reuseChunkedInstances)) {
        limit = Math.min(filteredItemCount, this.initialCount);
        newCount = Math.max(limit - currentCount, 0);
        this.__chunkCount = newCount || 1;
      } else {
        newCount = Math.min(
          Math.max(filteredItemCount - currentCount, 0),
          this.__chunkCount);
        limit = Math.min(currentCount + newCount, filteredItemCount);
      }
      this.__shouldMeasureChunk = newCount === this.__chunkCount;
      this.__shouldContinueChunking = limit < filteredItemCount;
      this.__renderStartTime = performance.now();
    }
    this.__itemsArrayChanged = false;
    return limit;
  }
  __continueChunking() {
    if (this.__shouldMeasureChunk) {
      const renderTime = performance.now() - this.__renderStartTime;
      const ratio = this._targetFrameTime / renderTime;
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    }
    if (this.__shouldContinueChunking) {
      this.__debounceRender(this.__render);
    }
  }
  __updateInstances(items, limit, isntIdxToItemsIdx) {
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx;
    for (instIdx=0; instIdx<limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst) {
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item, instIdx, itemIdx);
      }
    }
    for (let i=this.__instances.length-1; i>=instIdx; i--) {
      this.__detachAndRemoveInstance(i);
    }
  }
  __detachInstance(idx) {
    let inst = this.__instances[idx];
    const wrappedRoot = wrap(inst.root);
    for (let i=0; i<inst.children.length; i++) {
      let el = inst.children[i];
      wrappedRoot.appendChild(el);
    }
    return inst;
  }
  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    parent.insertBefore(inst.root, this);
  }
  __detachAndRemoveInstance(idx) {
    this.__detachInstance(idx);
    this.__instances.splice(idx, 1);
  }
  __stampInstance(item, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }
  __insertInstance(item, instIdx, itemIdx) {
    const inst = this.__stampInstance(item, instIdx, itemIdx);
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }
  _showHideChildren(hidden) {
    for (let i=0; i<this.__instances.length; i++) {
      this.__instances[i]._showHideChildren(hidden);
    }
  }
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6);
    let dot = itemsPath.indexOf('.');
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);
      this.__handleObservedPaths(itemSubPath);
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }
  modelForElement(el) {
    return modelForElement(this.template, el);
  }
}
customElements.define(DomRepeat.is, DomRepeat);

const nativeShadow = !(
  window['ShadyDOM'] && window['ShadyDOM']['inUse']
);
let nativeCssVariables_;
function calcCssVariables(settings) {
  if (settings && settings.shimcssproperties) {
    nativeCssVariables_ = false;
  } else {
    nativeCssVariables_ =
      nativeShadow ||
      Boolean(
        !navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) &&
          window.CSS &&
          CSS.supports &&
          CSS.supports('box-shadow', '0 0 0 var(--foo)')
      );
  }
}
let cssBuild;
if (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {
  cssBuild = window.ShadyCSS.cssBuild;
}
const disableRuntime = Boolean(
  window.ShadyCSS && window.ShadyCSS.disableRuntime
);
if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables_ = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}
const nativeCssVariables =  (nativeCssVariables_);

class StyleNode {
  constructor() {
    this['start'] = 0;
    this['end'] = 0;
    this['previous'] = null;
    this['parent'] = null;
    this['rules'] = null;
    this['parsedCssText'] = '';
    this['cssText'] = '';
    this['atRule'] = false;
    this['type'] = 0;
    this['keyframesName'] = '';
    this['selector'] = '';
    this['parsedSelector'] = '';
  }
}
function parse(text) {
  text = clean(text);
  return parseCss$1(lex(text), text);
}
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}
function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}
function parseCss$1(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    let ss = node['previous']
      ? node['previous']['end']
      : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    t = t.substring(t.lastIndexOf(';') + 1);
    let s = (node['parsedSelector'] = node['selector'] = t.trim());
    node['atRule'] = s.indexOf(AT_START) === 0;
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node['rules'];
  if (r$) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss$1(r, text);
    }
  }
  return node;
}
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
    let code = arguments[1],
      repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}
function stringify(node, preserveProperties, text = '') {
  let cssText = '';
  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties
        ? node['cssText']
        : removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}
function _hasMixinRules(rules) {
  let r = rules[0];
  return (
    Boolean(r) &&
    Boolean(r['selector']) &&
    r['selector'].indexOf(VAR_START) === 0
  );
}
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}
function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}
function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}
const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000,
};
const OPEN_BRACE = '{';
const CLOSE_BRACE = '}';
const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g,
};
const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';

const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
const MEDIA_MATCH = /@media\s(.*)/;

const styleTextSet = new Set();
const scopingAttribute = 'shady-unscoped';
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = document.createElement('style');
    newStyle.setAttribute('shady-unscoped', '');
    newStyle.textContent = text;
    document.head.appendChild(newStyle);
  }
}
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

function toCssText(rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = parse(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return stringify(rules, nativeCssVariables);
}
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = parse(style.textContent);
  }
  return style['__cssRules'] || null;
}
function forEachRule(
  node,
  styleRuleCallback,
  keyframesRuleCallback,
  onlyActiveRules
) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node['type'];
  if (onlyActiveRules) {
    if (type === types.MEDIA_RULE) {
      let matchMedia = node['selector'].match(MEDIA_MATCH);
      if (matchMedia) {
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === types.MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node['rules'];
  if (r$ && !skipRules) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}
function findMatchingParen(text, start) {
  let level = 0;
  for (let i = start, l = text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}
function processVariableAndFallback(str, callback) {
  let start = str.indexOf('var(');
  if (start === -1) {
    return callback(str, '', '', '');
  }
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(',');
  if (comma === -1) {
    return callback(prefix, inner.trim(), '', suffix);
  }
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}
(window['ShadyDOM'] && window['ShadyDOM']['wrap']) || ((node) => node);
function getIsExtends(element) {
  let localName = element['localName'];
  let is = '',
    typeExtension = '';
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = (element.getAttribute && element.getAttribute('is')) || '';
    }
  } else {
    is =  (element).is;
    typeExtension =  (element).extends;
  }
  return {is, typeExtension};
}
function gatherStyleText(element) {
  const styleTextParts = [];
  const styles =  (element.querySelectorAll(
    'style'
  ));
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (isUnscopedStyle(style)) {
      if (!nativeShadow) {
        processUnscopedStyle(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join('').trim();
}
const CSS_BUILD_ATTR = 'css-build';
function getCssBuild(element) {
  if (cssBuild !== undefined) {
    return  (cssBuild);
  }
  if (element.__cssBuild === undefined) {
    const attrValue = element.getAttribute(CSS_BUILD_ATTR);
    if (attrValue) {
      element.__cssBuild = attrValue;
    } else {
      const buildComment = getBuildComment(element);
      if (buildComment !== '') {
        removeBuildComment(element);
      }
      element.__cssBuild = buildComment;
    }
  }
  return element.__cssBuild || '';
}
function elementHasBuiltCss(element) {
  return getCssBuild(element) !== '';
}
function getBuildComment(element) {
  const buildComment =
    element.localName === 'template'
      ?  (element).content.firstChild
      : element.firstChild;
  if (buildComment instanceof Comment) {
    const commentParts = buildComment.textContent.trim().split(':');
    if (commentParts[0] === CSS_BUILD_ATTR) {
      return commentParts[1];
    }
  }
  return '';
}
function removeBuildComment(element) {
  const buildComment =
    element.localName === 'template'
      ?  (element).content.firstChild
      : element.firstChild;
  buildComment.parentNode.removeChild(buildComment);
}

function updateNativeProperties(element, properties) {
  for (let p in properties) {
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}
function getComputedStyleValue(element, property) {
  const value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}
function detectMixin(cssText) {
  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);
  MIXIN_MATCH.lastIndex = 0;
  VAR_ASSIGN.lastIndex = 0;
  return has;
}

const APPLY_NAME_CLEAN = /;\s*/m;
const INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
const IMPORTANT = /\s*!important/;
const MIXIN_VAR_SEP = '_-_';
class MixinMap {
  constructor() {
    this._map = {};
  }
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {},
    };
  }
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
}
let invalidCallback = null;
class ApplyShim {
  constructor() {
    this._currentElement = null;
    this._measureElement = null;
    this._map = new MixinMap();
  }
  detectMixin(cssText) {
    return detectMixin(cssText);
  }
  gatherStyles(template) {
    const styleText = gatherStyleText(template.content);
    if (styleText) {
      const style =  (document.createElement(
        'style'
      ));
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === undefined) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  transformStyle(style, elementName = '') {
    let ast = rulesForStyle(style);
    this.transformRules(ast, elementName);
    style.textContent = toCssText(ast);
    return ast;
  }
  transformCustomStyle(style) {
    let ast = rulesForStyle(style);
    forEachRule(ast, (rule) => {
      if (rule['selector'] === ':root') {
        rule['selector'] = 'html';
      }
      this.transformRule(rule);
    });
    style.textContent = toCssText(ast);
    return ast;
  }
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    forEachRule(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  transformRule(rule) {
    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);
    if (rule['selector'] === ':root') {
      rule['selector'] = ':host > *';
    }
  }
  transformCssText(cssText, rule) {
    cssText = cssText.replace(
      VAR_ASSIGN,
      (matchText, propertyName, valueProperty, valueMixin) =>
        this._produceCssProperties(
          matchText,
          propertyName,
          valueProperty,
          valueMixin,
          rule
        )
    );
    return this._consumeCssProperties(cssText, rule);
  }
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement =  (document.createElement(
        'meta'
      ));
      this._measureElement.setAttribute('apply-shim-measure', '');
      this._measureElement.style.all = 'initial';
      document.head.appendChild(this._measureElement);
    }
    return window
      .getComputedStyle(this._measureElement)
      .getPropertyValue(property);
  }
  _fallbacksFromPreviousRules(startRule) {
    let topRule = startRule;
    while (topRule['parent']) {
      topRule = topRule['parent'];
    }
    const fallbacks = {};
    let seenStartRule = false;
    forEachRule(topRule, (r) => {
      seenStartRule = seenStartRule || r === startRule;
      if (seenStartRule) {
        return;
      }
      if (r['selector'] === startRule['selector']) {
        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));
      }
    });
    return fallbacks;
  }
  _consumeCssProperties(text, rule) {
    let m = null;
    while ((m = MIXIN_MATCH.exec(text))) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      let applyPos = idx + matchText.indexOf('@apply');
      let afterApplyPos = idx + matchText.length;
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};
      Object.assign(defaults, this._cssTextToMap(textBeforeApply));
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      MIXIN_MATCH.lastIndex = idx + replacement.length;
    }
    return text;
  }
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p, parts, f;
      const properties = mixinEntry.properties;
      for (p in properties) {
        f = fallbacks && fallbacks[p];
        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
        if (f) {
          parts.push(',', f.replace(IMPORTANT, ''));
        }
        parts.push(')');
        if (IMPORTANT.test(properties[p])) {
          parts.push(' !important');
        }
        vars.push(parts.join(''));
      }
    }
    return vars.join('; ');
  }
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        value = this._getInitialValueForProperty(property);
      } else {
        value = 'apply-shim-inherit';
      }
    }
    return value;
  }
  _cssTextToMap(text, replaceInitialOrInherit = false) {
    let props = text.split(';');
    let property, value;
    let out = {};
    for (let i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        if (sp.length > 1) {
          property = sp[0].trim();
          value = sp.slice(1).join(':');
          if (replaceInitialOrInherit) {
            value = this._replaceInitialOrInherit(property, value);
          }
          out[property] = value;
        }
      }
    }
    return out;
  }
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }
  _produceCssProperties(
    matchText,
    propertyName,
    valueProperty,
    valueMixin,
    rule
  ) {
    if (valueProperty) {
      processVariableAndFallback(valueProperty, (prefix, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`;
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);
    let prefix = matchText.slice(0, matchText.indexOf('--'));
    let mixinValues = this._cssTextToMap(mixinAsProperties, true);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p, v;
    let needToInvalidate = false;
    for (p in combinedProps) {
      v = mixinValues[p];
      if (v === undefined) {
        v = 'initial';
      }
      if (oldProps && !(p in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join('; ')};`;
  }
}
ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] =
  ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] =
  ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  get() {
    return invalidCallback;
  },
  set(cb) {
    invalidCallback = cb;
  },
});

const templateMap = {};

const CURRENT_VERSION = '_applyShimCurrentVersion';
const NEXT_VERSION = '_applyShimNextVersion';
const VALIDATING_VERSION = '_applyShimValidatingVersion';
const promise = Promise.resolve();
function invalidate(elementName) {
  let template = templateMap[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}
function invalidateTemplate(template) {
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}
function templateIsValidating(template) {
  return (
    !templateIsValid(template) &&
    template[VALIDATING_VERSION] === template[NEXT_VERSION]
  );
}
function startValidatingTemplate(template) {
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  if (!template._validating) {
    template._validating = true;
    promise.then(function () {
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

let readyPromise = null;
let whenReady =
  (window['HTMLImports'] && window['HTMLImports']['whenReady']) || null;
let resolveFn;
function documentWait(callback) {
  requestAnimationFrame(function () {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise((resolve) => {
          resolveFn = resolve;
        });
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function () {
        callback && callback();
      });
    }
  });
}

const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';
let transformFn = null;
let validateFn = null;
let CustomStyleInterface$1 = class CustomStyleInterface {
  constructor() {
    this['customStyles'] = [];
    this['enqueued'] = false;
    documentWait(() => {
      if (window['ShadyCSS']['flushCustomStyles']) {
        window['ShadyCSS']['flushCustomStyles']();
      }
    });
  }
  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }
    this['enqueued'] = true;
    documentWait(validateFn);
  }
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }
    let style;
    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }
    return style;
  }
  processStyles() {
    const cs = this['customStyles'];
    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];
      if (customStyle[CACHED_STYLE]) {
        continue;
      }
      const style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        const styleToTransform =  (style[
          '__appliedElement'
        ] || style);
        if (transformFn) {
          transformFn(styleToTransform);
        }
        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }
    return cs;
  }
};
CustomStyleInterface$1.prototype['addCustomStyle'] =
  CustomStyleInterface$1.prototype.addCustomStyle;
CustomStyleInterface$1.prototype['getStyleForCustomStyle'] =
  CustomStyleInterface$1.prototype.getStyleForCustomStyle;
CustomStyleInterface$1.prototype['processStyles'] =
  CustomStyleInterface$1.prototype.processStyles;
Object.defineProperties(CustomStyleInterface$1.prototype, {
  'transformCallback': {
    get() {
      return transformFn;
    },
    set(fn) {
      transformFn = fn;
    },
  },
  'validateCallback': {
    get() {
      return validateFn;
    },
    set(fn) {
      let needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    },
  },
});

const applyShim = new ApplyShim();
class ApplyShimInterface {
  constructor() {
    this.customStyleInterface = null;
    applyShim['invalidCallback'] = invalidate;
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    if (window.ShadyCSS.CustomStyleInterface) {
      this.customStyleInterface =  (window
        .ShadyCSS.CustomStyleInterface);
      this.customStyleInterface['transformCallback'] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface['enqueued']) {
            this.flushCustomStyles();
          }
        });
      };
    }
  }
  prepareTemplate(template, elementName) {
    this.ensure();
    if (elementHasBuiltCss(template)) {
      return;
    }
    templateMap[elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    template['_styleAst'] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface['processStyles']();
    if (!this.customStyleInterface['enqueued']) {
      return;
    }
    for (let i = 0; i < styles.length; i++) {
      let cs = styles[i];
      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface['enqueued'] = false;
  }
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      updateNativeProperties(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren =
         (element.shadowRoot).children ||
        element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree( (shadowChildren[i]));
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree( (children[i]));
      }
    }
  }
  styleElement(element) {
    this.ensure();
    let {is} = getIsExtends(element);
    let template = templateMap[is];
    if (template && elementHasBuiltCss(template)) {
      return;
    }
    if (template && !templateIsValid(template)) {
      if (!templateIsValidating(template)) {
        this.prepareTemplate(template, is);
        startValidatingTemplate(template);
      }
      let root = element.shadowRoot;
      if (root) {
        let style =  (root.querySelector(
          'style'
        ));
        if (style) {
          style['__cssRules'] = template['_styleAst'];
          style.textContent = toCssText(template['_styleAst']);
        }
      }
    }
  }
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
}
if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface =
    window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;
  window.ShadyCSS = {
    prepareTemplate(template, elementName, elementExtends) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },
    prepareTemplateStyles(template, elementName, elementExtends) {
      window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);
    },
    prepareTemplateDom(template, elementName) {},
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },
    flushCustomStyles() {
      applyShimInterface.flushCustomStyles();
    },
    nativeCss: nativeCssVariables,
    nativeShadow: nativeShadow,
    cssBuild: cssBuild,
    disableRuntime: disableRuntime,
  };
  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}
window.ShadyCSS.ApplyShim = applyShim;

const HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
const HOST_DIR_REPLACMENT = ':host([dir="$1"])';
const EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
const EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';
const DIR_CHECK = /:dir\((?:ltr|rtl)\)/;
const SHIM_SHADOW = Boolean(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
const DIR_INSTANCES = [];
let observer = null;
let documentDir = '';
function getRTL() {
  documentDir = document.documentElement.getAttribute('dir');
}
function setRTL(instance) {
  if (!instance.__autoDirOptOut) {
    const el = (instance);
    el.setAttribute('dir', documentDir);
  }
}
function updateDirection() {
  getRTL();
  documentDir = document.documentElement.getAttribute('dir');
  for (let i = 0; i < DIR_INSTANCES.length; i++) {
    setRTL(DIR_INSTANCES[i]);
  }
}
function takeRecords() {
  if (observer && observer.takeRecords().length) {
    updateDirection();
  }
}
const DirMixin = dedupingMixin((base) => {
  if (!SHIM_SHADOW) {
    if (!observer) {
      getRTL();
      observer = new MutationObserver(updateDirection);
      observer.observe(document.documentElement, {attributes: true, attributeFilter: ['dir']});
    }
  }
  const elementBase = PropertyAccessors(base);
  class Dir extends elementBase {
    static _processStyleText(cssText, baseURI) {
      cssText = elementBase._processStyleText.call(this, cssText, baseURI);
      if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {
        cssText = this._replaceDirInCssText(cssText);
        this.__activateDir = true;
      }
      return cssText;
    }
    static _replaceDirInCssText(text) {
      let replacedText = text;
      replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
      replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
      return replacedText;
    }
    constructor() {
      super();
      this.__autoDirOptOut = false;
    }
    ready() {
      super.ready();
      this.__autoDirOptOut = (this).hasAttribute('dir');
    }
    connectedCallback() {
      if (elementBase.prototype.connectedCallback) {
        super.connectedCallback();
      }
      if (this.constructor.__activateDir) {
        takeRecords();
        DIR_INSTANCES.push(this);
        setRTL(this);
      }
    }
    disconnectedCallback() {
      if (elementBase.prototype.disconnectedCallback) {
        super.disconnectedCallback();
      }
      if (this.constructor.__activateDir) {
        const idx = DIR_INSTANCES.indexOf(this);
        if (idx > -1) {
          DIR_INSTANCES.splice(idx, 1);
        }
      }
    }
  }
  Dir.__activateDir = false;
  return Dir;
});

let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];
function schedule$1() {
  scheduled = true;
  requestAnimationFrame(function() {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    setTimeout(function() {
      runQueue(afterRenderQueue);
    });
  });
}
function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}
function runQueue(queue) {
  for (let i=0, l=queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}
function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];
  try {
    callback.apply(context, args);
  } catch(e) {
    setTimeout(() => {
      throw e;
    });
  }
}
function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}
function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule$1();
  }
  beforeRenderQueue.push([context, callback, args]);
}
function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule$1();
  }
  afterRenderQueue.push([context, callback, args]);
}

var renderStatus = /*#__PURE__*/Object.freeze({
	__proto__: null,
	afterNextRender: afterNextRender,
	beforeNextRender: beforeNextRender,
	flush: flush
});

function resolve() {
  document.body.removeAttribute('unresolved');
}
if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}
const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;
function calcEditDistances(current, currentStart, currentEnd,
                            old, oldStart, oldEnd) {
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount);
  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }
  for (let j = 0; j < columnCount; j++)
    distances[0][j] = j;
  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))
        distances[i][j] = distances[i - 1][j - 1];
      else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }
  return distances;
}
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];
    let min;
    if (west < north)
      min = west < northWest ? west : northWest;
    else
      min = north < northWest ? north : northWest;
    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }
  edits.reverse();
  return edits;
}
function calcSplices(current, currentStart, currentEnd,
                      old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;
  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0)
    prefixCount = sharedPrefix(current, old, minLength);
  if (currentEnd == current.length && oldEnd == old.length)
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);
  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;
  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
    return [];
  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd)
      splice.removed.push(old[oldStart++]);
    return [ splice ];
  } else if (oldStart == oldEnd)
    return [ newSplice(currentStart, [], currentEnd - currentStart) ];
  let ops = spliceOperationsFromEditDistances(
      calcEditDistances(current, currentStart, currentEnd,
                             old, oldStart, oldEnd));
  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; i++) {
    switch(ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }
        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice)
          splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice)
          splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice)
          splice = newSplice(index, [], 0);
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }
  if (splice) {
    splices.push(splice);
  }
  return splices;
}
function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++)
    if (!equals(current[i], old[i]))
      return i;
  return searchLength;
}
function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2]))
    count++;
  return count;
}
function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0,
                          previous.length);
}
function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

function isSlot(node) {
  return (node.localName === 'slot');
}
let FlattenedNodesObserver = class {
  static getFlattenedNodes(node) {
    const wrapped = wrap(node);
    if (isSlot(node)) {
      node = (node);
      return wrapped.assignedNodes({flatten: true});
    } else {
      return Array.from(wrapped.childNodes).map((node) => {
        if (isSlot(node)) {
          node = (node);
          return wrap(node).assignedNodes({flatten: true});
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }
  constructor(target, callback) {
    this._shadyChildrenObserver = null;
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }
  connect() {
    if (isSlot(this._target)) {
      this._listenSlots([this._target]);
    } else if (wrap(this._target).children) {
      this._listenSlots(
           (wrap(this._target).children));
      if (window.ShadyDOM) {
        this._shadyChildrenObserver =
          window.ShadyDOM.observeChildren(this._target, (mutations) => {
            this._processMutations(mutations);
          });
      } else {
        this._nativeChildrenObserver =
          new MutationObserver((mutations) => {
            this._processMutations(mutations);
          });
        this._nativeChildrenObserver.observe(this._target, {childList: true});
      }
    }
    this._connected = true;
  }
  disconnect() {
    if (isSlot(this._target)) {
      this._unlistenSlots([this._target]);
    } else if (wrap(this._target).children) {
      this._unlistenSlots(
           (wrap(this._target).children));
      if (window.ShadyDOM && this._shadyChildrenObserver) {
        window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
        this._shadyChildrenObserver = null;
      } else if (this._nativeChildrenObserver) {
        this._nativeChildrenObserver.disconnect();
        this._nativeChildrenObserver = null;
      }
    }
    this._connected = false;
  }
  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      microTask.run(() => this.flush());
    }
  }
  _processMutations(mutations) {
    this._processSlotMutations(mutations);
    this.flush();
  }
  _processSlotMutations(mutations) {
    if (mutations) {
      for (let i=0; i < mutations.length; i++) {
        let mutation = mutations[i];
        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }
        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
    }
  }
  flush() {
    if (!this._connected) {
      return false;
    }
    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }
    if (this._nativeChildrenObserver) {
      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
    } else if (this._shadyChildrenObserver) {
      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
    }
    this._scheduled = false;
    let info = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    };
    let newNodes = this.constructor.getFlattenedNodes(this._target);
    let splices = calculateSplices(newNodes,
      this._effectiveNodes);
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    }
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    }
    this._effectiveNodes = newNodes;
    let didFlush = false;
    if (info.addedNodes.length || info.removedNodes.length) {
      didFlush = true;
      this.callback.call(this._target, info);
    }
    return didFlush;
  }
  _listenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }
  _unlistenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }
};

const p$1 = Element.prototype;
const normalizedMatchesSelector = p$1.matches || p$1.matchesSelector ||
  p$1.mozMatchesSelector || p$1.msMatchesSelector ||
  p$1.oMatchesSelector || p$1.webkitMatchesSelector;
const matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};
class DomApiNative {
  constructor(node) {
    if (window['ShadyDOM'] && window['ShadyDOM']['inUse']) {
      window['ShadyDOM']['patch'](node);
    }
    this.node = node;
  }
  observeNodes(callback) {
    return new FlattenedNodesObserver(
        (this.node), callback);
  }
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }
  notifyObserver() {}
  deepContains(node) {
    if (wrap(this.node).contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    while (n && n !== doc && n !== this.node) {
      n = wrap(n).parentNode || wrap(n).host;
    }
    return n === this.node;
  }
  getOwnerRoot() {
    return wrap(this.node).getRootNode();
  }
  getDistributedNodes() {
    return (this.node.localName === 'slot') ?
      wrap(this.node).assignedNodes({flatten: true}) :
      [];
  }
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = wrap(this.node).assignedSlot;
    while (n) {
      ip$.push(n);
      n = wrap(n).assignedSlot;
    }
    return ip$;
  }
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node :
      this.node.ownerDocument;
    return wrap(doc).importNode(node, deep);
  }
  getEffectiveChildNodes() {
    return FlattenedNodesObserver.getFlattenedNodes(
         (this.node));
  }
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
      if ((c.nodeType === Node.ELEMENT_NODE) &&
          matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }
  get activeElement() {
    let node = this.node;
    return node._activeElement !== undefined ? node._activeElement : node.activeElement;
  }
}
function forwardMethods(proto, methods) {
  for (let i=0; i < methods.length; i++) {
    let method = methods[i];
    proto[method] =  function() {
      return this.node[method].apply(this.node, arguments);
    };
  }
}
function forwardReadOnlyProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        const domApi = (this);
        return domApi.node[name];
      },
      configurable: true
    });
  }
}
function forwardProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return this.node[name];
      },
      set: function(value) {
        this.node[name] = value;
      },
      configurable: true
    });
  }
}
class EventApi {
  constructor(event) {
    this.event = event;
  }
  get rootTarget() {
    return this.path[0];
  }
  get localTarget() {
    return this.event.target;
  }
  get path() {
    return this.event.composedPath();
  }
}
DomApiNative.prototype.cloneNode;
DomApiNative.prototype.appendChild;
DomApiNative.prototype.insertBefore;
DomApiNative.prototype.removeChild;
DomApiNative.prototype.replaceChild;
DomApiNative.prototype.setAttribute;
DomApiNative.prototype.removeAttribute;
DomApiNative.prototype.querySelector;
DomApiNative.prototype.querySelectorAll;
DomApiNative.prototype.parentNode;
DomApiNative.prototype.firstChild;
DomApiNative.prototype.lastChild;
DomApiNative.prototype.nextSibling;
DomApiNative.prototype.previousSibling;
DomApiNative.prototype.firstElementChild;
DomApiNative.prototype.lastElementChild;
DomApiNative.prototype.nextElementSibling;
DomApiNative.prototype.previousElementSibling;
DomApiNative.prototype.childNodes;
DomApiNative.prototype.children;
DomApiNative.prototype.classList;
DomApiNative.prototype.textContent;
DomApiNative.prototype.innerHTML;
let DomApiImpl = DomApiNative;
if (window['ShadyDOM'] && window['ShadyDOM']['inUse'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['Wrapper']) {
  class Wrapper extends window['ShadyDOM']['Wrapper'] {}
  Object.getOwnPropertyNames(DomApiNative.prototype).forEach((prop) => {
    if (prop != 'activeElement') {
      Wrapper.prototype[prop] = DomApiNative.prototype[prop];
    }
  });
  forwardReadOnlyProperties(Wrapper.prototype, [
    'classList'
  ]);
  DomApiImpl = Wrapper;
  Object.defineProperties(EventApi.prototype, {
    localTarget: {
      get() {
        const current = this.event.currentTarget;
        const currentRoot = current && dom(current).getOwnerRoot();
        const p$ = this.path;
        for (let i = 0; i < p$.length; i++) {
          const e = p$[i];
          if (dom(e).getOwnerRoot() === currentRoot) {
            return e;
          }
        }
      },
      configurable: true
    },
    path: {
      get() {
        return window['ShadyDOM']['composedPath'](this.event);
      },
      configurable: true
    }
  });
} else {
  forwardMethods(DomApiNative.prototype, [
    'cloneNode', 'appendChild', 'insertBefore', 'removeChild',
    'replaceChild', 'setAttribute', 'removeAttribute',
    'querySelector', 'querySelectorAll', 'attachShadow'
  ]);
  forwardReadOnlyProperties(DomApiNative.prototype, [
    'parentNode', 'firstChild', 'lastChild',
    'nextSibling', 'previousSibling', 'firstElementChild',
    'lastElementChild', 'nextElementSibling', 'previousElementSibling',
    'childNodes', 'children', 'classList', 'shadowRoot'
  ]);
  forwardProperties(DomApiNative.prototype, [
    'textContent', 'innerHTML', 'className'
  ]);
}
const dom = function(obj) {
  obj = obj || document;
  if (obj instanceof DomApiImpl) {
    return (obj);
  }
  if (obj instanceof EventApi) {
    return (obj);
  }
  let helper = obj['__domApi'];
  if (!helper) {
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApiImpl((obj));
    }
    obj['__domApi'] = helper;
  }
  return helper;
};

const ShadyDOM$1 = window.ShadyDOM;
const ShadyCSS = window.ShadyCSS;
function sameScope(node, scope) {
  return wrap(node).getRootNode() === scope;
}
function scopeSubtree(container, shouldObserve = false) {
  if (!ShadyDOM$1 || !ShadyCSS) {
    return null;
  }
  if (!ShadyDOM$1['handlesDynamicScoping']) {
    return null;
  }
  const ScopingShim = ShadyCSS['ScopingShim'];
  if (!ScopingShim) {
    return null;
  }
  const containerScope = ScopingShim['scopeForNode'](container);
  const root = wrap(container).getRootNode();
  const scopify = (node) => {
    if (!sameScope(node, root)) {
      return;
    }
    const elements = Array.from(ShadyDOM$1['nativeMethods']['querySelectorAll'].call(node, '*'));
    elements.push(node);
    for (let i = 0; i < elements.length; i++) {
      const el = elements[i];
      if (!sameScope(el, root)) {
        continue;
      }
      const currentScope = ScopingShim['currentScopeForNode'](el);
      if (currentScope !== containerScope) {
        if (currentScope !== '') {
          ScopingShim['unscopeNode'](el, currentScope);
        }
        ScopingShim['scopeNode'](el, containerScope);
      }
    }
  };
  scopify(container);
  if (shouldObserve) {
    const mo = new MutationObserver((mxns) => {
      for (let i = 0; i < mxns.length; i++) {
        const mxn = mxns[i];
        for (let j = 0; j < mxn.addedNodes.length; j++) {
          const addedNode = mxn.addedNodes[j];
          if (addedNode.nodeType === Node.ELEMENT_NODE) {
            scopify(addedNode);
          }
        }
      }
    });
    mo.observe(container, {childList: true, subtree: true});
    return mo;
  } else {
    return null;
  }
}

const DISABLED_ATTR$1 = 'disable-upgrade';
const findObservedAttributesGetter = (ctor) => {
  while (ctor) {
    const desc = Object.getOwnPropertyDescriptor(ctor, 'observedAttributes');
    if (desc) {
      return desc.get;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return () => [];
};
dedupingMixin((base) => {
  const superClass = ElementMixin(base);
  let observedAttributesGetter = findObservedAttributesGetter(superClass);
  class DisableUpgradeClass extends superClass {
    constructor() {
      super();
      this.__isUpgradeDisabled;
    }
    static get observedAttributes() {
      return observedAttributesGetter.call(this).concat(DISABLED_ATTR$1);
    }
    _initializeProperties() {
      if (this.hasAttribute(DISABLED_ATTR$1)) {
        this.__isUpgradeDisabled = true;
      } else {
        super._initializeProperties();
      }
    }
    _enableProperties() {
      if (!this.__isUpgradeDisabled) {
        super._enableProperties();
      }
    }
    _canApplyPropertyDefault(property) {
      return super._canApplyPropertyDefault(property) &&
        !(this.__isUpgradeDisabled && this._isPropertyPending(property));
    }
    attributeChangedCallback(name, old, value, namespace) {
      if (name == DISABLED_ATTR$1) {
        if (this.__isUpgradeDisabled && value == null) {
          super._initializeProperties();
          this.__isUpgradeDisabled = false;
          if (wrap(this).isConnected) {
            super.connectedCallback();
          }
        }
      } else {
        super.attributeChangedCallback(
            name, old, value,  (namespace));
      }
    }
    connectedCallback() {
      if (!this.__isUpgradeDisabled) {
        super.connectedCallback();
      }
    }
    disconnectedCallback() {
      if (!this.__isUpgradeDisabled) {
        super.disconnectedCallback();
      }
    }
  }
  return DisableUpgradeClass;
});

const DISABLED_ATTR = 'disable-upgrade';
let styleInterface = window.ShadyCSS;
const LegacyElementMixin = dedupingMixin((base) => {
  const GesturesElement = GestureEventListeners(ElementMixin(base));
  const legacyElementBase = builtCSS ? GesturesElement :
    DirMixin(GesturesElement);
  const observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);
  const DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };
  class LegacyElement extends legacyElementBase {
    constructor() {
      super();
      this.isAttached;
      this.__boundListeners;
      this._debouncers;
      this.__isUpgradeDisabled;
      this.__needsAttributesAtConnected;
      this._legacyForceObservedAttributes;
    }
    static get importMeta() {
      return this.prototype.importMeta;
    }
    created() {}
    __attributeReaction(name, old, value) {
      if ((this.__dataAttributes && this.__dataAttributes[name]) || name === DISABLED_ATTR) {
        this.attributeChangedCallback(name, old, value, null);
      }
    }
    setAttribute(name, value) {
      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
        const oldValue = this.getAttribute(name);
        super.setAttribute(name, value);
        this.__attributeReaction(name, oldValue, String(value));
      } else {
        super.setAttribute(name, value);
      }
    }
    removeAttribute(name) {
      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
        const oldValue = this.getAttribute(name);
        super.removeAttribute(name);
        this.__attributeReaction(name, oldValue, null);
      } else {
        super.removeAttribute(name);
      }
    }
    static get observedAttributes() {
      if (legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
          this.__observedAttributes = [];
          register$1(this.prototype);
        }
        return this.__observedAttributes;
      } else {
        return observedAttributesGetter.call(this).concat(DISABLED_ATTR);
      }
    }
    _enableProperties() {
      if (!this.__isUpgradeDisabled) {
        super._enableProperties();
      }
    }
    _canApplyPropertyDefault(property) {
      return super._canApplyPropertyDefault(property) &&
        !(this.__isUpgradeDisabled && this._isPropertyPending(property));
    }
    connectedCallback() {
      if (this.__needsAttributesAtConnected) {
        this._takeAttributes();
      }
      if (!this.__isUpgradeDisabled) {
        super.connectedCallback();
        this.isAttached = true;
        this.attached();
      }
    }
    attached() {}
    disconnectedCallback() {
      if (!this.__isUpgradeDisabled) {
        super.disconnectedCallback();
        this.isAttached = false;
        this.detached();
      }
    }
    detached() {}
    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        if (name == DISABLED_ATTR) {
          if (this.__isUpgradeDisabled && value == null) {
            this._initializeProperties();
            this.__isUpgradeDisabled = false;
            if (wrap(this).isConnected) {
              this.connectedCallback();
            }
          }
        } else {
          super.attributeChangedCallback(name, old, value, namespace);
          this.attributeChanged(name, old, value);
        }
      }
    }
    attributeChanged(name, old, value) {}
    _initializeProperties() {
      if (legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {
        this.__isUpgradeDisabled = true;
      } else {
        let proto = Object.getPrototypeOf(this);
        if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {
          this._registered();
          proto.__hasRegisterFinished = true;
        }
        super._initializeProperties();
        this.root = (this);
        this.created();
        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
          if (this.hasAttributes()) {
            this._takeAttributes();
          } else if (!this.parentNode) {
            this.__needsAttributesAtConnected = true;
          }
        }
        this._applyListeners();
      }
    }
    _takeAttributes() {
      const a = this.attributes;
      for (let i=0, l=a.length; i < l; i++) {
        const attr = a[i];
        this.__attributeReaction(attr.name, null, attr.value);
      }
    }
    _registered() {}
    ready() {
      this._ensureAttributes();
      super.ready();
    }
    _ensureAttributes() {}
    _applyListeners() {}
    serialize(value) {
      return this._serializeValue(value);
    }
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute( (node || this), value, attribute);
    }
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom =
        (document.importNode(content, true));
      return dom;
    }
    fire(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === undefined ? true: options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      wrap(node).dispatchEvent(event);
      return event;
    }
    listen(node, eventName, methodName) {
      node =  (node || this);
      let hbl = this.__boundListeners ||
        (this.__boundListeners = new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(
             (node), eventName, methodName, this);
      }
    }
    unlisten(node, eventName, methodName) {
      node =  (node || this);
      let bl = this.__boundListeners &&
          this.__boundListeners.get( (node));
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(
             (node), eventName, handler);
        bl[key] =  (null);
      }
    }
    setScrollDirection(direction, node) {
      setTouchAction(
           (node || this),
          DIRECTION_MAP[direction] || 'auto');
    }
    $$(slctr) {
      return this.root.querySelector(slctr);
    }
    get domHost() {
      let root = wrap(this).getRootNode();
      return (root instanceof DocumentFragment) ?  (root).host : root;
    }
    distributeContent() {
      const thisEl =  (this);
      const domApi = (dom(thisEl));
      if (window.ShadyDOM && domApi.shadowRoot) {
        ShadyDOM.flush();
      }
    }
    getEffectiveChildNodes() {
      const thisEl =  (this);
      const domApi =  (dom(thisEl));
      return domApi.getEffectiveChildNodes();
    }
    queryDistributedElements(selector) {
      const thisEl =  (this);
      const domApi =  (dom(thisEl));
      return domApi.queryDistributedElements(selector);
    }
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function( n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      });
    }
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i=0, c; (c = cn[i]); i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join('');
    }
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }
    getContentChildNodes(slctr) {
      let content = this.root.querySelector(slctr || 'slot');
      return content ?
           (dom(content)).getDistributedNodes() :
          [];
    }
    getContentChildren(slctr) {
      let children = (this.getContentChildNodes(slctr).filter(function(n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      }));
      return children;
    }
    isLightDescendant(node) {
      const thisNode =  (this);
      return thisNode !== node && wrap(thisNode).contains(node) &&
        wrap(thisNode).getRootNode() === wrap(node).getRootNode();
    }
    isLocalDescendant(node) {
      return this.root === wrap(node).getRootNode();
    }
    scopeSubtree(container, shouldObserve = false) {
      return scopeSubtree(container, shouldObserve);
    }
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue((this), property);
    }
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = Debouncer.debounce(
            this._debouncers[jobName]
          , wait > 0 ? timeOut.after(wait) : microTask
          , callback.bind(this));
    }
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }
    async(callback, waitTime) {
      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) :
          ~microTask.run(callback.bind(this));
    }
    cancelAsync(handle) {
      handle < 0 ? microTask.cancel(~handle) :
          timeOut.cancel(handle);
    }
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }
    elementMatches(selector, node) {
      return matchesSelector( (node || this), selector);
    }
    toggleAttribute(name, bool) {
      let node = (this);
      if (arguments.length === 3) {
        node = (arguments[2]);
      }
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        wrap(node).setAttribute(name, '');
        return true;
      } else {
        wrap(node).removeAttribute(name);
        return false;
      }
    }
    toggleClass(name, bool, node) {
      node =  (node || this);
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }
    transform(transformText, node) {
      node =  (node || this);
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }
    translate3d(x, y, z, node) {
      node =  (node || this);
      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
    }
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = get$2(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }
    _logger(level, args) {
      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      switch(level) {
        case 'log':
        case 'warn':
        case 'error':
          console[level](...args);
      }
    }
    _log(...args) {
      this._logger('log', args);
    }
    _warn(...args) {
      this._logger('warn', args);
    }
    _error(...args) {
      this._logger('error', args);
    }
    _logf(methodName, ...args) {
      return ['[%s::%s]', this.is, methodName, ...args];
    }
  }
  LegacyElement.prototype.is = '';
  return LegacyElement;
});

const lifecycleProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  listeners: true,
  hostAttributes: true
};
const excludeOnInfo = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  behaviors: true,
  _noAccessors: true
};
const excludeOnBehaviors = Object.assign({
  listeners: true,
  hostAttributes: true,
  properties: true,
  observers: true,
}, excludeOnInfo);
function copyProperties(source, target, excludeProps) {
  const noAccessors = source._noAccessors;
  const propertyNames = Object.getOwnPropertyNames(source);
  for (let i = 0; i < propertyNames.length; i++) {
    let p = propertyNames[i];
    if (p in excludeProps) {
      continue;
    }
    if (noAccessors) {
      target[p] = source[p];
    } else {
      let pd = Object.getOwnPropertyDescriptor(source, p);
      if (pd) {
        pd.configurable = true;
        Object.defineProperty(target, p, pd);
      }
    }
  }
}
function mixinBehaviors(behaviors, klass) {
  return GenerateClassFromInfo({}, LegacyElementMixin(klass), behaviors);
}
function applyBehaviors(proto, behaviors, lifecycle) {
  for (let i=0; i<behaviors.length; i++) {
    applyInfo(proto, behaviors[i], lifecycle, excludeOnBehaviors);
  }
}
function applyInfo(proto, info, lifecycle, excludeProps) {
  copyProperties(info, proto, excludeProps);
  for (let p in lifecycleProps) {
    if (info[p]) {
      lifecycle[p] = lifecycle[p] || [];
      lifecycle[p].push(info[p]);
    }
  }
}
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i=behaviors.length-1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}
function mergeProperties(target, source) {
  for (const p in source) {
    const targetInfo = target[p];
    const sourceInfo = source[p];
    if (!('value' in sourceInfo) && targetInfo && ('value' in targetInfo)) {
      target[p] = Object.assign({value: targetInfo.value}, sourceInfo);
    } else {
      target[p] = sourceInfo;
    }
  }
}
const LegacyElement = LegacyElementMixin(HTMLElement);
function GenerateClassFromInfo(info, Base, behaviors) {
  let behaviorList;
  const lifecycle = {};
  class PolymerGenerated extends Base {
    static _finalizeClass() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('generatedFrom', this))) {
        Base._finalizeClass.call(this);
      } else {
        if (behaviorList) {
          for (let i=0, b; i < behaviorList.length; i++) {
            b = behaviorList[i];
            if (b.properties) {
              this.createProperties(b.properties);
            }
            if (b.observers) {
              this.createObservers(b.observers, b.properties);
            }
          }
        }
        if (info.properties) {
          this.createProperties(info.properties);
        }
        if (info.observers) {
          this.createObservers(info.observers, info.properties);
        }
        this._prepareTemplate();
      }
    }
    static get properties() {
      const properties = {};
      if (behaviorList) {
        for (let i=0; i < behaviorList.length; i++) {
          mergeProperties(properties, behaviorList[i].properties);
        }
      }
      mergeProperties(properties, info.properties);
      return properties;
    }
    static get observers() {
      let observers = [];
      if (behaviorList) {
        for (let i=0, b; i < behaviorList.length; i++) {
          b = behaviorList[i];
          if (b.observers) {
            observers = observers.concat(b.observers);
          }
        }
      }
      if (info.observers) {
        observers = observers.concat(info.observers);
      }
      return observers;
    }
    created() {
      super.created();
      const list = lifecycle.created;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    _registered() {
      const generatedProto = PolymerGenerated.prototype;
      if (!generatedProto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', generatedProto))) {
        generatedProto.__hasRegisterFinished = true;
        super._registered();
        if (legacyOptimizations) {
          copyPropertiesToProto(generatedProto);
        }
        const proto = Object.getPrototypeOf(this);
        let list = lifecycle.beforeRegister;
        if (list) {
          for (let i=0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
        list = lifecycle.registered;
        if (list) {
          for (let i=0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
      }
    }
    _applyListeners() {
      super._applyListeners();
      const list = lifecycle.listeners;
      if (list) {
        for (let i=0; i < list.length; i++) {
          const listeners = list[i];
          if (listeners) {
            for (let l in listeners) {
              this._addMethodEventListenerToNode(this, l, listeners[l]);
            }
          }
        }
      }
    }
    _ensureAttributes() {
      const list = lifecycle.hostAttributes;
      if (list) {
        for (let i=list.length-1; i >= 0; i--) {
          const hostAttributes = list[i];
          for (let a in hostAttributes) {
              this._ensureAttribute(a, hostAttributes[a]);
            }
        }
      }
      super._ensureAttributes();
    }
    ready() {
      super.ready();
      let list = lifecycle.ready;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    attached() {
      super.attached();
      let list = lifecycle.attached;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    detached() {
      super.detached();
      let list = lifecycle.detached;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    attributeChanged(name, old, value) {
      super.attributeChanged();
      let list = lifecycle.attributeChanged;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this, name, old, value);
        }
      }
    }
  }
  if (behaviors) {
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    let superBehaviors = Base.prototype.behaviors;
    behaviorList = flattenBehaviors(behaviors, null, superBehaviors);
    PolymerGenerated.prototype.behaviors = superBehaviors ?
      superBehaviors.concat(behaviors) : behaviorList;
  }
  const copyPropertiesToProto = (proto) => {
    if (behaviorList) {
      applyBehaviors(proto, behaviorList, lifecycle);
    }
    applyInfo(proto, info, lifecycle, excludeOnInfo);
  };
  if (!legacyOptimizations) {
    copyPropertiesToProto(PolymerGenerated.prototype);
  }
  PolymerGenerated.generatedFrom = info;
  return PolymerGenerated;
}
const Class = function(info, mixin) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  let klass = mixin ? mixin(LegacyElement) :
      LegacyElement;
  klass = GenerateClassFromInfo(info, klass, info.behaviors);
  klass.is = klass.prototype.is = info.is;
  return klass;
};

const Polymer = function(info) {
  let klass;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = Polymer.Class(info);
  }
  if (info._legacyForceObservedAttributes) {
    klass.prototype._legacyForceObservedAttributes = info._legacyForceObservedAttributes;
  }
  customElements.define(klass.is, (klass));
  return klass;
};
Polymer.Class = Class;

const Templatizer = {
  templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor =
        templatize(template,  (this), {
          mutableData: Boolean(mutableData),
          parentModel: this._parentModel,
          instanceProps: this._instanceProps,
          forwardHostProp: this._forwardHostPropV2,
          notifyInstanceProp: this._notifyInstancePropV2
        });
  },
  stamp(model) {
    return new this.ctor(model);
  },
  modelForElement(el) {
    return modelForElement(this._templatizerTemplate, el);
  }
};

let ArraySelectorMixin = dedupingMixin(superClass => {
  let elementBase = ElementMixin(superClass);
  class ArraySelectorMixin extends elementBase {
    static get properties() {
      return {
        items: {
          type: Array,
        },
        multi: {
          type: Boolean,
          value: false,
        },
        selected: {type: Object, notify: true},
        selectedItem: {type: Object, notify: true},
        toggle: {type: Boolean, value: false}
      };
    }
    static get observers() {
      return ['__updateSelection(multi, items.*)'];
    }
    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }
    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == JSCompiler_renameProperty('items', this)) {
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = calculateSplices(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == `${JSCompiler_renameProperty('items', this)}.splices`) {
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        let part = path.slice(`${JSCompiler_renameProperty('items', this)}.`.length);
        let idx = parseInt(part, 10);
        if ((part.indexOf('.') < 0) && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }
    __applySplices(splices) {
      let selected = this.__selectedMap;
      for (let i=0; i<splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) ; else if (idx >= s.index + s.removed.length) {
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            selected.set(item, -1);
          }
        });
        for (let j=0; j<s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      this.__updateLinks();
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }
    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach(idx => {
          if (idx >= 0) {
            this.linkPaths(
                `${JSCompiler_renameProperty('items', this)}.${idx}`,
                `${JSCompiler_renameProperty('selected', this)}.${sidx++}`);
          }
        });
      } else {
        this.__selectedMap.forEach(idx => {
          this.linkPaths(
              JSCompiler_renameProperty('selected', this),
              `${JSCompiler_renameProperty('items', this)}.${idx}`);
          this.linkPaths(
              JSCompiler_renameProperty('selectedItem', this),
              `${JSCompiler_renameProperty('items', this)}.${idx}`);
        });
      }
    }
    clearSelection() {
      this.__dataLinkedPaths = {};
      this.__selectedMap = new Map();
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }
    isSelected(item) {
      return this.__selectedMap.has(item);
    }
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }
    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }
    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths[`${JSCompiler_renameProperty('items', this)}.${idx}`];
      if (selected) {
        return parseInt(selected.slice(`${JSCompiler_renameProperty('selected', this)}.`.length), 10);
      }
    }
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push(JSCompiler_renameProperty('selected', this), item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }
  }
  return ArraySelectorMixin;
});
let baseArraySelector = ArraySelectorMixin(PolymerElement);
class ArraySelector extends baseArraySelector {
  static get is() { return 'array-selector'; }
  static get template() { return null; }
}
customElements.define(ArraySelector.is, ArraySelector);

const customStyleInterface = new CustomStyleInterface$1();
if (!window.ShadyCSS) {
  window.ShadyCSS = {
    prepareTemplate(template, elementName, elementExtends) {},
    prepareTemplateDom(template, elementName) {},
    prepareTemplateStyles(template, elementName, elementExtends) {},
    styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      updateNativeProperties(element, properties);
    },
    styleElement(element) {
      customStyleInterface.processStyles();
    },
    styleDocument(properties) {
      customStyleInterface.processStyles();
      updateNativeProperties(document.body, properties);
    },
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },
    flushCustomStyles() {},
    nativeCss: nativeCssVariables,
    nativeShadow: nativeShadow,
    cssBuild: cssBuild,
    disableRuntime: disableRuntime,
  };
}
window.ShadyCSS.CustomStyleInterface = customStyleInterface;

const attr = 'include';
const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;
class CustomStyle extends HTMLElement {
  constructor() {
    super();
    this._style = null;
    CustomStyleInterface.addCustomStyle(this);
  }
  getStyle() {
    if (this._style) {
      return this._style;
    }
    const style = (this.querySelector('style'));
    if (!style) {
      return null;
    }
    this._style = style;
    const include = style.getAttribute(attr);
    if (include) {
      style.removeAttribute(attr);
      style.textContent = cssFromModules(include) + style.textContent;
    }
    if (this.ownerDocument !== window.document) {
      window.document.head.appendChild(this);
    }
    return this._style;
  }
}
window.customElements.define('custom-style', CustomStyle);

let mutablePropertyChange;
(() => {
  mutablePropertyChange = MutableData._mutablePropertyChange;
})();
const OptionalMutableDataBehavior = {
  properties: {
    mutableData: Boolean
  },
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};

const Base = LegacyElementMixin(HTMLElement).prototype;

let verticalScrollbarMaxWidthBugOffset = undefined;
const getVerticalScrollbarMaxWidthBugOffset = () => {
  if (verticalScrollbarMaxWidthBugOffset !== undefined) {
    return verticalScrollbarMaxWidthBugOffset;
  }
  const container = document.createElement('div');
  Object.assign(container.style, {
    overflow: 'auto',
    position: 'fixed',
    left: '0px',
    top: '0px',
    maxWidth: '100px',
    maxHeight: '100px',
  });
  const content = document.createElement('div');
  content.style.width = '200px';
  content.style.height = '200px';
  container.appendChild(content);
  document.body.appendChild(container);
  verticalScrollbarMaxWidthBugOffset =
      Math.abs(container.offsetWidth - 100) > 1 ?
      container.offsetWidth - container.clientWidth :
      0;
  document.body.removeChild(container);
  return verticalScrollbarMaxWidthBugOffset;
};
const IronFitBehavior = {
  properties: {
    sizingTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },
    fitInto: {type: Object, value: window},
    noOverlap: {type: Boolean},
    positionTarget: {type: Element},
    horizontalAlign: {type: String},
    verticalAlign: {type: String},
    dynamicAlign: {type: Boolean},
    horizontalOffset: {type: Number, value: 0, notify: true},
    verticalOffset: {type: Number, value: 0, notify: true},
    autoFitOnAttach: {type: Boolean, value: false},
    expandSizingTargetForScrollbars: {type: Boolean, value: false},
    _fitInfo: {type: Object}
  },
  get _fitWidth() {
    var fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  },
  get _fitHeight() {
    var fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  },
  get _fitLeft() {
    var fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  },
  get _fitTop() {
    var fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  },
  get _defaultPositionTarget() {
    var parent = dom(this).parentNode;
    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }
    return parent;
  },
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  },
  get __shouldPosition() {
    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;
  },
  get _isRTL() {
    if (typeof this._memoizedIsRTL === 'undefined') {
      this._memoizedIsRTL = window.getComputedStyle(this).direction == 'rtl';
    }
    return this._memoizedIsRTL;
  },
  attached: function() {
    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      if (window.getComputedStyle(this).display === 'none') {
        setTimeout(function() {
          this.fit();
        }.bind(this));
      } else {
        window.ShadyDOM && ShadyDOM.flush();
        this.fit();
      }
    }
  },
  detached: function() {
    if (this.__deferredFit) {
      clearTimeout(this.__deferredFit);
      this.__deferredFit = null;
    }
  },
  fit: function() {
    this.position();
    this.constrain();
    this.center();
  },
  _discoverInfo: function() {
    if (this._fitInfo) {
      return;
    }
    var target = window.getComputedStyle(this);
    var sizer = window.getComputedStyle(this.sizingTarget);
    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ?
            'top' :
            (target.bottom !== 'auto' ? 'bottom' : null),
        horizontally: target.left !== 'auto' ?
            'left' :
            (target.right !== 'auto' ? 'right' : null)
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  },
  resetFit: function() {
    var info = this._fitInfo || {};
    for (var property in info.sizerInlineStyle) {
      this.sizingTarget.style[property] = info.sizerInlineStyle[property];
    }
    for (var property in info.inlineStyle) {
      this.style[property] = info.inlineStyle[property];
    }
    this._fitInfo = null;
  },
  refit: function() {
    var scrollLeft = this.sizingTarget.scrollLeft;
    var scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  },
  position: function() {
    if (!this.__shouldPosition) {
      return;
    }
    this._discoverInfo();
    window.ShadyDOM && window.ShadyDOM.flush();
    this.style.position = 'fixed';
    this.sizingTarget.style.boxSizing = 'border-box';
    this.style.left = '0px';
    this.style.top = '0px';
    var rect = this.getBoundingClientRect();
    var positionRect = this.__getNormalizedRect(this.positionTarget);
    var fitRect = this.__getNormalizedRect(this.fitInto);
    let unpositionedOffsetWidth;
    let unpositionedOffsetHeight;
    let unpositionedClientWidth;
    let unpositionedClientHeight;
    if (this.expandSizingTargetForScrollbars) {
      unpositionedOffsetWidth = this.sizingTarget.offsetWidth;
      unpositionedOffsetHeight = this.sizingTarget.offsetHeight;
      unpositionedClientWidth = this.sizingTarget.clientWidth;
      unpositionedClientHeight = this.sizingTarget.clientHeight;
    }
    var margin = this._fitInfo.margin;
    var size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };
    var position = this.__getPosition(
        this._localeHorizontalAlign,
        this.verticalAlign,
        size,
        rect,
        positionRect,
        fitRect);
    var left = position.left + margin.left;
    var top = position.top + margin.top;
    var right = Math.min(fitRect.right - margin.right, left + rect.width);
    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);
    left = Math.max(
        fitRect.left + margin.left,
        Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(
        fitRect.top + margin.top,
        Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));
    const maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth);
    const maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight);
    this.sizingTarget.style.maxWidth = maxWidth + 'px';
    this.sizingTarget.style.maxHeight = maxHeight + 'px';
    const leftPosition = left - rect.left;
    const topPosition = top - rect.top;
    this.style.left = `${leftPosition}px`;
    this.style.top = `${topPosition}px`;
    if (this.expandSizingTargetForScrollbars) {
      const positionedOffsetHeight = this.sizingTarget.offsetHeight;
      const positionedClientHeight = this.sizingTarget.clientHeight;
      const unpositionedHeightDelta =
          unpositionedOffsetHeight - unpositionedClientHeight;
      const positionedHeightDelta =
          positionedOffsetHeight - positionedClientHeight;
      const sizingTargetScrollbarHeight =
          positionedHeightDelta - unpositionedHeightDelta;
      if (sizingTargetScrollbarHeight > 0) {
        const fitRectMaxHeight = fitRect.height - margin.top - margin.bottom;
        const newMaxHeight =
            Math.min(fitRectMaxHeight, maxHeight + sizingTargetScrollbarHeight);
        this.sizingTarget.style.maxHeight = `${newMaxHeight}px`;
        const offsetHeight = this.sizingTarget.offsetHeight;
        const addedHeight = offsetHeight - positionedOffsetHeight;
        let newTopPosition;
        if (position.verticalAlign === 'top') {
          newTopPosition = topPosition;
        } else if (position.verticalAlign === 'middle') {
          newTopPosition = topPosition - addedHeight / 2;
        } else if (position.verticalAlign === 'bottom') {
          newTopPosition = topPosition - addedHeight;
        }
        newTopPosition = Math.max(
            fitRect.top + margin.top,
            Math.min(
                newTopPosition, fitRect.bottom - margin.bottom - offsetHeight));
        this.style.top = `${newTopPosition}px`;
      }
      const positionedOffsetWidth = this.sizingTarget.offsetWidth;
      const positionedClientWidth = this.sizingTarget.clientWidth;
      const unpositionedWidthDelta =
          unpositionedOffsetWidth - unpositionedClientWidth;
      const positionedWidthDelta =
          positionedOffsetWidth - positionedClientWidth;
      const sizingTargetScrollbarWidth =
          positionedWidthDelta - unpositionedWidthDelta;
      if (sizingTargetScrollbarWidth > 0) {
        const maxWidthBugOffset = getVerticalScrollbarMaxWidthBugOffset();
        const fitRectMaxWidth = fitRect.width - margin.left - margin.right;
        const newMaxWidth = Math.min(
            fitRectMaxWidth,
            maxWidth + sizingTargetScrollbarWidth - maxWidthBugOffset);
        this.sizingTarget.style.maxWidth = `${newMaxWidth}px`;
        const offsetWidth = this.sizingTarget.offsetWidth + maxWidthBugOffset;
        const addedWidth = offsetWidth - positionedOffsetWidth;
        let newLeftPosition;
        if (position.horizontalAlign === 'left') {
          newLeftPosition = leftPosition;
        } else if (position.horizontalAlign === 'center') {
          newLeftPosition = leftPosition - addedWidth / 2;
        } else if (position.horizontalAlign === 'right') {
          newLeftPosition = leftPosition - addedWidth;
        }
        newLeftPosition = Math.max(
            fitRect.left + margin.left,
            Math.min(
                newLeftPosition, fitRect.right - margin.right - offsetWidth));
        this.style.left = `${newLeftPosition}px`;
      }
    }
  },
  constrain: function() {
    if (this.__shouldPosition) {
      return;
    }
    this._discoverInfo();
    var info = this._fitInfo;
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }
    this.sizingTarget.style.boxSizing = 'border-box';
    var rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(
          rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(
          rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  },
  _sizeDimension: function(rect, positionedBy, start, end, extent) {
    this.__sizeDimension(rect, positionedBy, start, end, extent);
  },
  __sizeDimension: function(rect, positionedBy, start, end, extent) {
    var info = this._fitInfo;
    var fitRect = this.__getNormalizedRect(this.fitInto);
    var max = extent === 'Width' ? fitRect.width : fitRect.height;
    var flip = (positionedBy === end);
    var offset = flip ? max - rect[end] : rect[start];
    var margin = info.margin[flip ? start : end];
    var offsetExtent = 'offset' + extent;
    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] =
        (max - margin - offset - sizingOffset) + 'px';
  },
  center: function() {
    if (this.__shouldPosition) {
      return;
    }
    this._discoverInfo();
    var positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      return;
    }
    this.style.position = 'fixed';
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    var rect = this.getBoundingClientRect();
    var fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  },
  __getNormalizedRect: function(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  },
  __getOffscreenArea: function(position, size, fitRect) {
    var verticalCrop = Math.min(0, position.top) +
        Math.min(0, fitRect.bottom - (position.top + size.height));
    var horizontalCrop = Math.min(0, position.left) +
        Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width +
        Math.abs(horizontalCrop) * size.height;
  },
  __getPosition: function(
      hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {
    var positions = [
      {
        verticalAlign: 'top',
        horizontalAlign: 'left',
        top: positionRect.top + this.verticalOffset,
        left: positionRect.left + this.horizontalOffset
      },
      {
        verticalAlign: 'top',
        horizontalAlign: 'right',
        top: positionRect.top + this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset
      },
      {
        verticalAlign: 'bottom',
        horizontalAlign: 'left',
        top: positionRect.bottom - size.height - this.verticalOffset,
        left: positionRect.left + this.horizontalOffset
      },
      {
        verticalAlign: 'bottom',
        horizontalAlign: 'right',
        top: positionRect.bottom - size.height - this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset
      }
    ];
    if (this.noOverlap) {
      for (var i = 0, l = positions.length; i < l; i++) {
        var copy = {};
        for (var key in positions[i]) {
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;
    if (!hAlign || hAlign === 'center') {
      positions.push({
        verticalAlign: 'top',
        horizontalAlign: 'center',
        top: positionRect.top + this.verticalOffset +
            (this.noOverlap ? positionRect.height : 0),
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
      positions.push({
        verticalAlign: 'bottom',
        horizontalAlign: 'center',
        top: positionRect.bottom - size.height - this.verticalOffset -
            (this.noOverlap ? positionRect.height : 0),
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
    }
    if (!vAlign || vAlign === 'middle') {
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'left',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.left + this.horizontalOffset +
            (this.noOverlap ? positionRect.width : 0)
      });
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'right',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset -
            (this.noOverlap ? positionRect.width : 0)
      });
    }
    if (vAlign === 'middle' && hAlign === 'center') {
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'center',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
    }
    var position;
    for (var i = 0; i < positions.length; i++) {
      var candidate = positions[i];
      var vAlignOk = candidate.verticalAlign === vAlign;
      var hAlignOk = candidate.horizontalAlign === hAlign;
      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {
        position = candidate;
        break;
      }
      var alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }
      candidate.offscreenArea =
          this.__getOffscreenArea(candidate, size, fitRect);
      if (candidate.offscreenArea === 0 && alignOk) {
        position = candidate;
        break;
      }
      position = position || candidate;
      var diff = candidate.offscreenArea - position.offscreenArea;
      if (diff < 0 || (diff === 0 && (vAlignOk || hAlignOk))) {
        position = candidate;
      }
    }
    return position;
  }
};

var ORPHANS = new Set();
const IronResizableBehavior = {
  properties: {
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged',
    },
    _notifyingDescendant: {
      type: Boolean,
      value: false,
    }
  },
  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },
  created: function() {
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
    this._boundOnDescendantIronResize = this._onDescendantIronResize.bind(this);
  },
  attached: function() {
    this._requestResizeNotifications();
  },
  detached: function() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      ORPHANS.delete(this);
      window.removeEventListener('resize', this._boundNotifyResize);
    }
    this._parentResizable = null;
  },
  notifyResize: function() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach(function(resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
    this._fireResize();
  },
  assignParentResizable: function(parentResizable) {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    }
    this._parentResizable = parentResizable;
    if (parentResizable &&
        parentResizable._interestedResizables.indexOf(this) === -1) {
      parentResizable._interestedResizables.push(this);
      parentResizable._subscribeIronResize(this);
    }
  },
  stopResizeNotificationsFor: function(target) {
    var index = this._interestedResizables.indexOf(target);
    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this._unsubscribeIronResize(target);
    }
  },
  _subscribeIronResize: function(target) {
    target.addEventListener('iron-resize', this._boundOnDescendantIronResize);
  },
  _unsubscribeIronResize: function(target) {
    target.removeEventListener(
        'iron-resize', this._boundOnDescendantIronResize);
  },
  resizerShouldNotify: function(element) {
    return true;
  },
  _onDescendantIronResize: function(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }
    if (!useShadow) {
      this._fireResize();
    }
  },
  _fireResize: function() {
    this.fire('iron-resize', null, {node: this, bubbles: false});
  },
  _onIronRequestResizeNotifications: function(event) {
    var target =  (dom(event).rootTarget);
    if (target === this) {
      return;
    }
    target.assignParentResizable(this);
    this._notifyDescendant(target);
    event.stopPropagation();
  },
  _parentResizableChanged: function(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },
  _notifyDescendant: function(descendant) {
    if (!this.isAttached) {
      return;
    }
    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },
  _requestResizeNotifications: function() {
    if (!this.isAttached) {
      return;
    }
    if (document.readyState === 'loading') {
      var _requestResizeNotifications =
          this._requestResizeNotifications.bind(this);
      document.addEventListener(
          'readystatechange', function readystatechanged() {
            document.removeEventListener('readystatechange', readystatechanged);
            _requestResizeNotifications();
          });
    } else {
      this._findParent();
      if (!this._parentResizable) {
        ORPHANS.forEach(function(orphan) {
          if (orphan !== this) {
            orphan._findParent();
          }
        }, this);
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      } else {
        this._parentResizable._interestedResizables
            .forEach(function(resizable) {
              if (resizable !== this) {
                resizable._findParent();
              }
            }, this);
      }
    }
  },
  _findParent: function() {
    this.assignParentResizable(null);
    this.fire(
        'iron-request-resize-notifications',
        null,
        {node: this, bubbles: true, cancelable: true});
    if (!this._parentResizable) {
      ORPHANS.add(this);
    } else {
      ORPHANS.delete(this);
    }
  }
};

var p = Element.prototype;
var matches$1 = p.matches || p.matchesSelector || p.mozMatchesSelector ||
    p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
class IronFocusablesHelperClass {
  getTabbableNodes(node) {
    var result = [];
    var needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  }
  isFocusable(element) {
    if (matches$1.call(element, 'input, select, textarea, button, object')) {
      return matches$1.call(element, ':not([disabled])');
    }
    return matches$1.call(
        element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');
  }
  isTabbable(element) {
    return this.isFocusable(element) &&
        matches$1.call(element, ':not([tabindex="-1"])') &&
        this._isVisible(element);
  }
  _normalizedTabIndex(element) {
    if (this.isFocusable(element)) {
      var tabIndex = element.getAttribute('tabindex') || 0;
      return Number(tabIndex);
    }
    return -1;
  }
  _collectTabbableNodes(node, result) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    var element =  (node);
    if (!this._isVisible(element)) {
      return false;
    }
    var tabIndex = this._normalizedTabIndex(element);
    var needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }
    var children;
    if (element.localName === 'content' || element.localName === 'slot') {
      children = dom(element).getDistributedNodes();
    } else {
      children = dom(element.root || element).children;
    }
    for (var i = 0; i < children.length; i++) {
      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
    }
    return needsSort;
  }
  _isVisible(element) {
    var style = element.style;
    if (style.visibility !== 'hidden' && style.display !== 'none') {
      style = window.getComputedStyle(element);
      return (style.visibility !== 'hidden' && style.display !== 'none');
    }
    return false;
  }
  _sortByTabIndex(tabbables) {
    var len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    var pivot = Math.ceil(len / 2);
    var left = this._sortByTabIndex(tabbables.slice(0, pivot));
    var right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  }
  _mergeSortByTabIndex(left, right) {
    var result = [];
    while ((left.length > 0) && (right.length > 0)) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }
    return result.concat(left, right);
  }
  _hasLowerTabOrder(a, b) {
    var ati = Math.max(a.tabIndex, 0);
    var bti = Math.max(b.tabIndex, 0);
    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;
  }
}
const IronFocusablesHelper = new IronFocusablesHelperClass();

Polymer({
  _template: html$3`
    <style>
      :host {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--iron-overlay-backdrop-background-color, #000);
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        @apply --iron-overlay-backdrop;
      }

      :host(.opened) {
        opacity: var(--iron-overlay-backdrop-opacity, 0.6);
        pointer-events: auto;
        @apply --iron-overlay-backdrop-opened;
      }
    </style>

    <slot></slot>
`,
  is: 'iron-overlay-backdrop',
  properties: {
    opened: {
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_openedChanged',
    }
  },
  listeners: {
    'transitionend': '_onTransitionend',
  },
  created: function() {
    this.__openedRaf = null;
  },
  attached: function() {
    this.opened && this._openedChanged(this.opened);
  },
  prepare: function() {
    if (this.opened && !this.parentNode) {
      dom(document.body).appendChild(this);
    }
  },
  open: function() {
    this.opened = true;
  },
  close: function() {
    this.opened = false;
  },
  complete: function() {
    if (!this.opened && this.parentNode === document.body) {
      dom(this.parentNode).removeChild(this);
    }
  },
  _onTransitionend: function(event) {
    if (event && event.target === this) {
      this.complete();
    }
  },
  _openedChanged: function(opened) {
    if (opened) {
      this.prepare();
    } else {
      var cs = window.getComputedStyle(this);
      if (cs.transitionDuration === '0s' || cs.opacity == 0) {
        this.complete();
      }
    }
    if (!this.isAttached) {
      return;
    }
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(function() {
      this.__openedRaf = null;
      this.toggleClass('opened', this.opened);
    }.bind(this));
  }
});

var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};
var KEY_CHAR = /[a-z0-9*]/;
var IDENT_CHAR = /U\+/;
var ARROW_KEY = /^arrow/;
var SPACE_KEY = /^space(bar)?/;
var ESC_KEY = /^escape$/;
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}
function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}
function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) ||
      transformKeyCode(keyEvent.keyCode) || '';
}
function keyComboMatchesEvent(keyCombo, event) {
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key &&
      (!keyCombo.hasModifiers ||
       (!!event.shiftKey === !!keyCombo.shiftKey &&
        !!event.ctrlKey === !!keyCombo.ctrlKey &&
        !!event.altKey === !!keyCombo.altKey &&
        !!event.metaKey === !!keyCombo.metaKey));
}
function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {combo: keyComboString, key: keyComboString, event: 'keydown'};
  }
  return keyComboString.split('+')
      .reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];
        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
          parsedKeyCombo.hasModifiers = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }
        return parsedKeyCombo;
      }, {combo: keyComboString.split(':').shift()});
}
function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function(keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}
const IronA11yKeysBehavior = {
  properties: {
    keyEventTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },
    stopKeyboardEventPropagation: {type: Boolean, value: false},
    _boundKeyHandlers: {
      type: Array,
      value: function() {
        return [];
      }
    },
    _imperativeKeyBindings: {
      type: Object,
      value: function() {
        return {};
      }
    }
  },
  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],
  keyBindings: {},
  registered: function() {
    this._prepKeyBindings();
  },
  attached: function() {
    this._listenKeyEventListeners();
  },
  detached: function() {
    this._unlistenKeyEventListeners();
  },
  addOwnKeyBinding: function(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },
  removeOwnKeyBindings: function() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },
  keyboardEventMatchesKeys: function(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },
  _collectKeyBindings: function() {
    var keyBindings = this.behaviors.map(function(behavior) {
      return behavior.keyBindings;
    });
    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }
    return keyBindings;
  },
  _prepKeyBindings: function() {
    this._keyBindings = {};
    this._collectKeyBindings().forEach(function(keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);
    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(
          eventString, this._imperativeKeyBindings[eventString]);
    }
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function(kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return (b1 === b2) ? 0 : b1 ? -1 : 1;
      });
    }
  },
  _addKeyBinding: function(eventString, handlerName) {
    parseEventString(eventString).forEach(function(keyCombo) {
      this._keyBindings[keyCombo.event] =
          this._keyBindings[keyCombo.event] || [];
      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
    }, this);
  },
  _resetKeyEventListeners: function() {
    this._unlistenKeyEventListeners();
    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },
  _listenKeyEventListeners: function() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function(eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);
      this._boundKeyHandlers.push(
          [this.keyEventTarget, eventName, boundKeyHandler]);
      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },
  _unlistenKeyEventListeners: function() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;
    while (this._boundKeyHandlers.length) {
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];
      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },
  _onKeyBindingEvent: function(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }
    if (event.defaultPrevented) {
      return;
    }
    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },
  _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event =
        new CustomEvent(keyCombo.event, {detail: detail, cancelable: true});
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};

class IronOverlayManagerClass {
  constructor() {
    this._overlays = [];
    this._minimumZ = 101;
    this._backdropElement = null;
    addListener(document.documentElement, 'tap', function() {});
    document.addEventListener('tap', this._onCaptureClick.bind(this), true);
    document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
    document.addEventListener(
        'keydown', this._onCaptureKeyDown.bind(this), true);
  }
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('iron-overlay-backdrop');
    }
    return this._backdropElement;
  }
  get deepActiveElement() {
    var active = document.activeElement;
    if (!active || active instanceof Element === false) {
      active = document.body;
    }
    while (active.root && dom(active.root).activeElement) {
      active = dom(active.root).activeElement;
    }
    return active;
  }
  _bringOverlayAtIndexToFront(i) {
    var overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    var lastI = this._overlays.length - 1;
    var currentOverlay = this._overlays[lastI];
    if (currentOverlay &&
        this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    if (i >= lastI) {
      return;
    }
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  }
  addOrRemoveOverlay(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  }
  addOverlay(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    var insertionIndex = this._overlays.length;
    var currentOverlay = this._overlays[insertionIndex - 1];
    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    var newZ = this._getZ(overlay);
    if (currentOverlay &&
        this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      var previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);
    this.trackBackdrop();
  }
  removeOverlay(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);
    this.trackBackdrop();
  }
  currentOverlay() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  }
  currentOverlayZ() {
    return this._getZ(this.currentOverlay());
  }
  ensureMinimumZ(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  }
  focusOverlay() {
    var current =  (this.currentOverlay());
    if (current) {
      current._applyFocus();
    }
  }
  trackBackdrop() {
    var overlay = this._overlayWithBackdrop();
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
    this.backdropElement.prepare();
  }
  getBackdrops() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  }
  backdropZ() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  }
  _overlayWithBackdrop() {
    for (var i = this._overlays.length - 1; i >= 0; i--) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  }
  _getZ(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(
          overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  }
  _setZ(element, z) {
    element.style.zIndex = z;
  }
  _applyOverlayZ(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  }
  _overlayInPath(path) {
    path = path || [];
    for (var i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  }
  _onCaptureClick(event) {
    var i = this._overlays.length - 1;
    if (i === -1)
      return;
    var path =  (dom(event).path);
    var overlay;
    while ((overlay =  (this._overlays[i])) &&
           this._overlayInPath(path) !== overlay) {
      overlay._onCaptureClick(event);
      if (overlay.allowClickThrough) {
        i--;
      } else {
        break;
      }
    }
  }
  _onCaptureFocus(event) {
    var overlay =  (this.currentOverlay());
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  }
  _onCaptureKeyDown(event) {
    var overlay =  (this.currentOverlay());
    if (overlay) {
      if (IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {
        overlay._onCaptureEsc(event);
      } else if (IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
        overlay._onCaptureTab(event);
      }
    }
  }
  _shouldBeBehindOverlay(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
}const IronOverlayManager = new IronOverlayManagerClass();

var lastTouchPosition = {pageX: 0, pageY: 0};
var lastRootTarget = null;
var lastScrollableNodes = [];
var scrollEvents = [
  'wheel',
  'mousewheel',
  'DOMMouseScroll',
  'touchstart',
  'touchmove'
];
var _boundScrollHandler;
var currentLockingElement;
function pushScrollLock(element) {
  if (_lockingElements.indexOf(element) >= 0) {
    return;
  }
  if (_lockingElements.length === 0) {
    _lockScrollInteractions();
  }
  _lockingElements.push(element);
  currentLockingElement = _lockingElements[_lockingElements.length - 1];
}
function removeScrollLock(element) {
  var index = _lockingElements.indexOf(element);
  if (index === -1) {
    return;
  }
  _lockingElements.splice(index, 1);
  currentLockingElement = _lockingElements[_lockingElements.length - 1];
  if (_lockingElements.length === 0) {
    _unlockScrollInteractions();
  }
}
const _lockingElements = [];
function _scrollInteractionHandler(event) {
  if (event.cancelable && _shouldPreventScrolling(event)) {
    event.preventDefault();
  }
  if (event.targetTouches) {
    var touch = event.targetTouches[0];
    lastTouchPosition.pageX = touch.pageX;
    lastTouchPosition.pageY = touch.pageY;
  }
}
function _lockScrollInteractions() {
  _boundScrollHandler =
      _boundScrollHandler || _scrollInteractionHandler.bind(undefined);
  for (var i = 0, l = scrollEvents.length; i < l; i++) {
    document.addEventListener(
        scrollEvents[i], _boundScrollHandler, {capture: true, passive: false});
  }
}
function _unlockScrollInteractions() {
  for (var i = 0, l = scrollEvents.length; i < l; i++) {
    document.removeEventListener(
        scrollEvents[i], _boundScrollHandler, {capture: true, passive: false});
  }
}
function _shouldPreventScrolling(event) {
  var target = dom(event).rootTarget;
  if (event.type !== 'touchmove' && lastRootTarget !== target) {
    lastRootTarget = target;
    lastScrollableNodes = _getScrollableNodes(dom(event).path);
  }
  if (!lastScrollableNodes.length) {
    return true;
  }
  if (event.type === 'touchstart') {
    return false;
  }
  var info = _getScrollInfo(event);
  return !_getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);
}
function _getScrollableNodes(nodes) {
  var scrollables = [];
  var lockingIndex =
      nodes.indexOf( (currentLockingElement));
  for (var i = 0; i <= lockingIndex; i++) {
    if (nodes[i].nodeType !== Node.ELEMENT_NODE) {
      continue;
    }
    var node =  (nodes[i]);
    var style = node.style;
    if (style.overflow !== 'scroll' && style.overflow !== 'auto') {
      style = window.getComputedStyle(node);
    }
    if (style.overflow === 'scroll' || style.overflow === 'auto') {
      scrollables.push(node);
    }
  }
  return scrollables;
}
function _getScrollingNode(nodes, deltaX, deltaY) {
  if (!deltaX && !deltaY) {
    return;
  }
  var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var canScroll = false;
    if (verticalScroll) {
      canScroll = deltaY < 0 ?
          node.scrollTop > 0 :
          node.scrollTop < node.scrollHeight - node.clientHeight;
    } else {
      canScroll = deltaX < 0 ?
          node.scrollLeft > 0 :
          node.scrollLeft < node.scrollWidth - node.clientWidth;
    }
    if (canScroll) {
      return node;
    }
  }
}
function _getScrollInfo(event) {
  var info = {deltaX: event.deltaX, deltaY: event.deltaY};
  if ('deltaX' in event) ;
  else if ('wheelDeltaX' in event && 'wheelDeltaY' in event) {
    info.deltaX = -event.wheelDeltaX;
    info.deltaY = -event.wheelDeltaY;
  }
  else if ('wheelDelta' in event) {
    info.deltaX = 0;
    info.deltaY = -event.wheelDelta;
  }
  else if ('axis' in event) {
    info.deltaX = event.axis === 1 ? event.detail : 0;
    info.deltaY = event.axis === 2 ? event.detail : 0;
  }
  else if (event.targetTouches) {
    var touch = event.targetTouches[0];
    info.deltaX = lastTouchPosition.pageX - touch.pageX;
    info.deltaY = lastTouchPosition.pageY - touch.pageY;
  }
  return info;
}

const IronOverlayBehaviorImpl = {
  properties: {
    opened:
        {observer: '_openedChanged', type: Boolean, value: false, notify: true},
    canceled: {
      observer: '_canceledChanged',
      readOnly: true,
      type: Boolean,
      value: false
    },
    withBackdrop: {
      observer: '_withBackdropChanged',
      type: Boolean,
    },
    noAutoFocus: {
      type: Boolean,
      value: false,
    },
    noCancelOnEscKey: {
      type: Boolean,
      value: false,
    },
    noCancelOnOutsideClick: {
      type: Boolean,
      value: false,
    },
    closingReason: {
      type: Object,
    },
    restoreFocusOnClose: {
      type: Boolean,
      value: false,
    },
    allowClickThrough: {
      type: Boolean,
    },
    alwaysOnTop: {
      type: Boolean,
    },
    scrollAction: {
      type: String,
    },
    _manager: {
      type: Object,
      value: IronOverlayManager,
    },
    _focusedChild: {
      type: Object,
    }
  },
  listeners: {'iron-resize': '_onIronResize'},
  observers: ['__updateScrollObservers(isAttached, opened, scrollAction)'],
  get backdropElement() {
    return this._manager.backdropElement;
  },
  get _focusNode() {
    return this._focusedChild || dom(this).querySelector('[autofocus]') || this;
  },
  get _focusableNodes() {
    return IronFocusablesHelper.getTabbableNodes(this);
  },
  ready: function() {
    this.__isAnimating = false;
    this.__shouldRemoveTabIndex = false;
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    this.__rafs = {};
    this.__restoreFocusNode = null;
    this.__scrollTop = this.__scrollLeft = null;
    this.__onCaptureScroll = this.__onCaptureScroll.bind(this);
    this.__rootNodes = null;
    this._ensureSetup();
  },
  attached: function() {
    if (this.opened) {
      this._openedChanged(this.opened);
    }
    this._observer = dom(this).observeNodes(this._onNodesChange);
  },
  detached: function() {
    if (this._observer) {
      dom(this).unobserveNodes(this._observer);
    }
    this._observer = null;
    for (var cb in this.__rafs) {
      if (this.__rafs[cb] !== null) {
        cancelAnimationFrame(this.__rafs[cb]);
      }
    }
    this.__rafs = {};
    this._manager.removeOverlay(this);
    if (this.__isAnimating) {
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        this._applyFocus();
        this._finishRenderClosed();
      }
    }
  },
  toggle: function() {
    this._setCanceled(false);
    this.opened = !this.opened;
  },
  open: function() {
    this._setCanceled(false);
    this.opened = true;
  },
  close: function() {
    this._setCanceled(false);
    this.opened = false;
  },
  cancel: function(event) {
    var cancelEvent =
        this.fire('iron-overlay-canceled', event, {cancelable: true});
    if (cancelEvent.defaultPrevented) {
      return;
    }
    this._setCanceled(true);
    this.opened = false;
  },
  invalidateTabbables: function() {
    this.__firstFocusableNode = this.__lastFocusableNode = null;
  },
  _ensureSetup: function() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = 'none';
    this.style.display = 'none';
  },
  _openedChanged: function(opened) {
    if (opened) {
      this.removeAttribute('aria-hidden');
    } else {
      this.setAttribute('aria-hidden', 'true');
    }
    if (!this.isAttached) {
      return;
    }
    this.__isAnimating = true;
    this.__deraf('__openedChanged', this.__openedChanged);
  },
  _canceledChanged: function() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  },
  _withBackdropChanged: function() {
    if (this.withBackdrop && !this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '-1');
      this.__shouldRemoveTabIndex = true;
    } else if (this.__shouldRemoveTabIndex) {
      this.removeAttribute('tabindex');
      this.__shouldRemoveTabIndex = false;
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  },
  _prepareRenderOpened: function() {
    this.__restoreFocusNode = this._manager.deepActiveElement;
    this._preparePositioning();
    this.refit();
    this._finishPositioning();
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
      this.__restoreFocusNode.focus();
    }
  },
  _renderOpened: function() {
    this._finishRenderOpened();
  },
  _renderClosed: function() {
    this._finishRenderClosed();
  },
  _finishRenderOpened: function() {
    this.notifyResize();
    this.__isAnimating = false;
    this.fire('iron-overlay-opened');
  },
  _finishRenderClosed: function() {
    this.style.display = 'none';
    this.style.zIndex = '';
    this.notifyResize();
    this.__isAnimating = false;
    this.fire('iron-overlay-closed', this.closingReason);
  },
  _preparePositioning: function() {
    this.style.transition = this.style.webkitTransition = 'none';
    this.style.transform = this.style.webkitTransform = 'none';
    this.style.display = '';
  },
  _finishPositioning: function() {
    this.style.display = 'none';
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = '';
    this.style.transform = this.style.webkitTransform = '';
    this.style.display = '';
    this.scrollTop = this.scrollTop;
  },
  _applyFocus: function() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    } else {
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        var activeElement = this._manager.deepActiveElement;
        if (activeElement === document.body ||
            composedContains(this, activeElement)) {
          this.__restoreFocusNode.focus();
        }
      }
      this.__restoreFocusNode = null;
      this._focusNode.blur();
      this._focusedChild = null;
    }
  },
  _onCaptureClick: function(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  },
  _onCaptureFocus: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    var path = dom(event).path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild =  (path[0]);
    }
  },
  _onCaptureEsc: function(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  },
  _onCaptureTab: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    this.__ensureFirstLastFocusables();
    var shift = event.shiftKey;
    var nodeToCheck =
        shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    var nodeToSet =
        shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    var shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      shouldWrap = true;
    } else {
      var focusedNode = this._manager.deepActiveElement;
      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);
    }
    if (shouldWrap) {
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  },
  _onIronResize: function() {
    if (this.opened && !this.__isAnimating) {
      this.__deraf('refit', this.refit);
    }
  },
  _onNodesChange: function() {
    if (this.opened && !this.__isAnimating) {
      this.invalidateTabbables();
      this.notifyResize();
    }
  },
  __ensureFirstLastFocusables: function() {
    var focusableNodes = this._focusableNodes;
    this.__firstFocusableNode = focusableNodes[0];
    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
  },
  __openedChanged: function() {
    if (this.opened) {
      this._prepareRenderOpened();
      this._manager.addOverlay(this);
      this._applyFocus();
      this._renderOpened();
    } else {
      this._manager.removeOverlay(this);
      this._applyFocus();
      this._renderClosed();
    }
  },
  __deraf: function(jobname, callback) {
    var rafs = this.__rafs;
    if (rafs[jobname] !== null) {
      cancelAnimationFrame(rafs[jobname]);
    }
    rafs[jobname] = requestAnimationFrame(function nextAnimationFrame() {
      rafs[jobname] = null;
      callback.call(this);
    }.bind(this));
  },
  __updateScrollObservers: function(isAttached, opened, scrollAction) {
    if (!isAttached || !opened || !this.__isValidScrollAction(scrollAction)) {
      removeScrollLock(this);
      this.__removeScrollListeners();
    } else {
      if (scrollAction === 'lock') {
        this.__saveScrollPosition();
        pushScrollLock(this);
      }
      this.__addScrollListeners();
    }
  },
  __addScrollListeners: function() {
    if (!this.__rootNodes) {
      this.__rootNodes = [];
      if (useShadow) {
        var node = this;
        while (node) {
          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {
            this.__rootNodes.push(node);
          }
          node = node.host || node.assignedSlot || node.parentNode;
        }
      }
      this.__rootNodes.push(document);
    }
    this.__rootNodes.forEach(function(el) {
      el.addEventListener('scroll', this.__onCaptureScroll, {
        capture: true,
        passive: true,
      });
    }, this);
  },
  __removeScrollListeners: function() {
    if (this.__rootNodes) {
      this.__rootNodes.forEach(function(el) {
        el.removeEventListener('scroll', this.__onCaptureScroll, {
          capture: true,
          passive: true,
        });
      }, this);
    }
    if (!this.isAttached) {
      this.__rootNodes = null;
    }
  },
  __isValidScrollAction: function(scrollAction) {
    return scrollAction === 'lock' || scrollAction === 'refit' ||
        scrollAction === 'cancel';
  },
  __onCaptureScroll: function(event) {
    if (this.__isAnimating) {
      return;
    }
    if (dom(event).path.indexOf(this) >= 0) {
      return;
    }
    switch (this.scrollAction) {
      case 'lock':
        this.__restoreScrollPosition();
        break;
      case 'refit':
        this.__deraf('refit', this.refit);
        break;
      case 'cancel':
        this.cancel(event);
        break;
    }
  },
  __saveScrollPosition: function() {
    if (document.scrollingElement) {
      this.__scrollTop = document.scrollingElement.scrollTop;
      this.__scrollLeft = document.scrollingElement.scrollLeft;
    } else {
      this.__scrollTop =
          Math.max(document.documentElement.scrollTop, document.body.scrollTop);
      this.__scrollLeft = Math.max(
          document.documentElement.scrollLeft, document.body.scrollLeft);
    }
  },
  __restoreScrollPosition: function() {
    if (document.scrollingElement) {
      document.scrollingElement.scrollTop = this.__scrollTop;
      document.scrollingElement.scrollLeft = this.__scrollLeft;
    } else {
      document.documentElement.scrollTop = document.body.scrollTop =
          this.__scrollTop;
      document.documentElement.scrollLeft = document.body.scrollLeft =
          this.__scrollLeft;
    }
  },
};
const composedParent = node =>
    node.assignedSlot || node.parentNode || node.host;
const composedContains = (ancestor, descendant) => {
  for (let element = descendant; element; element = composedParent(element)) {
    if (element === ancestor) {
      return true;
    }
  }
  return false;
};
const IronOverlayBehavior =
    [IronFitBehavior, IronResizableBehavior, IronOverlayBehaviorImpl];

Polymer({
  is: 'iron-media-query',
  properties: {
    queryMatches: {type: Boolean, value: false, readOnly: true, notify: true},
    query: {type: String, observer: 'queryChanged'},
    full: {type: Boolean, value: false},
    _boundMQHandler: {
      value: function() {
        return this.queryHandler.bind(this);
      }
    },
    _mq: {value: null}
  },
  attached: function() {
    this.style.display = 'none';
    this.queryChanged();
  },
  detached: function() {
    this._remove();
  },
  _add: function() {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },
  _remove: function() {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }
    this._mq = null;
  },
  queryChanged: function() {
    this._remove();
    var query = this.query;
    if (!query) {
      return;
    }
    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }
    this._mq = window.matchMedia(query);
    this._add();
    this.queryHandler(this._mq);
  },
  queryHandler: function(mq) {
    this._setQueryMatches(mq.matches);
  }
});

var polymer = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Async: async,
	CaseMap: caseMap$1,
	Debounce: debounce,
	DomBind: DomBind,
	DomIf: DomIf,
	DomModule: DomModule,
	DomRepeat: DomRepeat,
	FlattenedNodesObserver: FlattenedNodesObserver,
	GestureEventListeners: GestureEventListeners,
	Gestures: gestures$1,
	IronFocusablesHelper: IronFocusablesHelper,
	IronOverlayBehavior: IronOverlayBehavior,
	IronOverlayBehaviorImpl: IronOverlayBehaviorImpl,
	PolymerElement: PolymerElement,
	Render: renderStatus,
	Settings: settings,
	Templatize: templatize$1,
	Url: resolveUrl$1,
	dedupingMixin: dedupingMixin,
	enqueueDebouncer: enqueueDebouncer,
	flush: flush$1,
	html: html$3,
	mixinBehaviors: mixinBehaviors,
	version: version$1
});

const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create: create$1
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone$1(object) {
  const newObject = create$1(null);
  for (const [property, value] of entries(object)) {
    if (getOwnPropertyDescriptor(object, property) !== undefined) {
      newObject[property] = value;
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text = freeze(['#text']);
const html$2 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
);
const DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  ERB_EXPR: ERB_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR,
  DATA_ATTR: DATA_ATTR,
  ARIA_ATTR: ARIA_ATTR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  DOCTYPE_NAME: DOCTYPE_NAME
});
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);
  DOMPurify.version = '3.0.6';
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = {};
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html$2, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create$1(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }
    cfg = clone$1(cfg);
    PARSER_MEDIA_TYPE =
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone$1(DEFAULT_URI_SAFE_ATTRIBUTES),
    cfg.ADD_URI_SAFE_ATTR,
    transformCaseFunc
    )
    : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone$1(DEFAULT_DATA_URI_TAGS),
    cfg.ADD_DATA_URI_TAGS,
    transformCaseFunc
    )
    : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [...text]);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html$2);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone$1(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  const HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  const ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  const ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      node.remove();
    }
  };
  const _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  const _initDocument = function _initDocument(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null);
  };
  const _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
  };
  const _isNode = function _isNode(object) {
    return typeof Node === 'function' && object instanceof Node;
  };
  const _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;
    _executeHook('beforeSanitizeElements', currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook('uponSanitizeElement', currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook('afterSanitizeElements', currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName.indexOf('-') > 0;
  };
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    _executeHook('beforeSanitizeAttributes', currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    let l = attributes.length;
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      let value = name === 'value' ? attrValue : stringTrim(attrValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined;
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHook('beforeSanitizeShadowDOM', fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook('uponSanitizeShadowNode', shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();

const icons = {};
function load(name) {
    return icons[name] || icons[Object.keys(icons).find(key => !!icons[key].aliases && icons[key].aliases.some(a => a === name))];
}
function exists(name) {
    return !!load(name);
}
function add(arg, maybeInnerHTML) {
    if (typeof arg === "string" && typeof maybeInnerHTML === "string") {
        const icon = document.createElement("vi-icon");
        icon.name = arg;
        icon.innerHTML = purify.sanitize(maybeInnerHTML);
        icons[icon.name] = icon;
        return;
    }
    if (arg instanceof Element && arg.tagName === "VI-ICON") {
        const icon = arg;
        icons[icon.name] = icon;
        return;
    }
    if (Array.isArray(arg))
        arg = html$3(arg);
    Array.from(arg.content.querySelectorAll("vi-icon")).forEach((icon) => {
        document.body.appendChild(icon);
        icons[icon.name] = icon;
        document.body.removeChild(icon);
    });
}
function all() {
    return Object.keys(icons);
}

var iconRegister = /*#__PURE__*/Object.freeze({
	__proto__: null,
	add: add,
	all: all,
	exists: exists,
	load: load
});

setLegacyUndefined(true);
setOrderedComputed(true);
setPassiveTouchGestures(true);
setRemoveNestedTemplates(true);
setSuppressTemplateNotifications(true);
class Operations {
    areSame(value1, value2) {
        return value1 === value2;
    }
    areNotSame(value1, value2) {
        return value1 !== value2;
    }
    areEqual(value1, value2) {
        return value1 == value2;
    }
    areNotEqual(value1, value2) {
        return value1 != value2;
    }
    some(...args) {
        return args.some(a => !!a && (!Array.isArray(a) || a.length > 0));
    }
    every(...args) {
        return args.every(a => !!a && (!Array.isArray(a) || a.length > 0));
    }
    none(...args) {
        return args.every(a => !a && (!Array.isArray(a) || a.length === 0));
    }
    isNull(value) {
        return value == null;
    }
    isNotNull(value) {
        return value != null;
    }
    isEmpty(value) {
        return !value;
    }
    isNotEmpty(value) {
        return !!value;
    }
}
class WebComponent extends GestureEventListeners(PolymerElement) {
    connectedCallback() {
        this._setApp(window["app"]);
        if (!this.app)
            this._listenForApp();
        else if (!this.app.service)
            this._listenForService(this.app);
        super.connectedCallback();
        this._setIsConnected(true);
        if (this._updateListeners)
            this._updateListeners(true);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._setIsConnected(false);
        if (this._updateListeners)
            this._updateListeners(false);
        if (!!this._appChangedListener)
            window.removeEventListener("app-changed", this._appChangedListener);
        if (!!this._serviceChangedListener)
            this.app.removeEventListener("service-changed", this._serviceChangedListener);
    }
    _listenForApp() {
        window.addEventListener("app-changed", this._appChangedListener = (e) => {
            window.removeEventListener("app-changed", this._appChangedListener);
            this._appChangedListener = null;
            this._setApp(window["app"]);
            if (!this.app.service)
                this._listenForService(this.app);
        });
    }
    _listenForService(app) {
        app.addEventListener("service-changed", this._serviceChangedListener = (e) => {
            app.removeEventListener("service-changed", this._serviceChangedListener);
            this._serviceChangedListener = null;
            this.notifyPath("app.service", e.detail.value);
        });
    }
    todo_checkEventTarget(target) {
        console.assert(false, "Check event target", target);
        return target;
    }
    ensureArgumentValues(args) {
        return !Array.from(args).some(a => a === undefined);
    }
    computePath(relativePath) {
        return Path.routes.rootPath + relativePath;
    }
    empty(parent = this, condition) {
        let children = Array.from(parent.childNodes);
        if (condition)
            children = children.filter(c => condition(c));
        children.forEach(c => parent.removeChild(c));
    }
    findParent(condition = e => !!e, parent) {
        if (!parent) {
            parent = this.parentElement ||
                (this.parentNode instanceof ShadowRoot ? this.parentNode.host : null);
        }
        while (!!parent && !condition(parent)) {
            parent = parent.parentElement ||
                (parent.parentNode instanceof ShadowRoot ? parent.parentNode.host : null);
        }
        return parent;
    }
    fire(type, detail, options) {
        options = options || {};
        detail = (detail === null || detail === undefined) ? {} : detail;
        let event = new CustomEvent(type, {
            detail: detail,
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
        });
        const node = options.node || this;
        node.dispatchEvent(event);
        return event;
    }
    sleep(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
    translateMessage(key, ...params) {
        if (!key || !this.app || !this.service || !this.service.language)
            return key;
        return this.service.getTranslatedMessage.apply(this.service, [key].concat(params));
    }
    _focusElement(element, maxAttempts, interval, attempt = 0) {
        const target = typeof element === "string" ? this.shadowRoot.querySelector(`#${element}`) : element;
        if (target) {
            const oldActiveElementPath = this.app.activeElementPath;
            if (oldActiveElementPath.some(e => e === target))
                return;
            target.focus();
            const currentActiveElementPath = this.app.activeElementPath;
            if (oldActiveElementPath.length !== currentActiveElementPath.length)
                return;
            if (oldActiveElementPath.some((e, i) => currentActiveElementPath[i] !== e))
                return;
        }
        if (attempt < (maxAttempts || 10))
            setTimeout(() => this._focusElement(target || element, maxAttempts, interval, attempt + 1), interval || 100);
    }
    _escapeHTML(val) {
        const span = document.createElement("span");
        span.innerText = val;
        return span.innerHTML;
    }
    _forwardObservable(source, path, pathPrefix, callback) {
        const paths = path.splitWithTail(".", 2);
        const pathToNotify = pathPrefix ? pathPrefix + "." + paths[0] : paths[0];
        const disposers = [];
        let subDispose = null;
        if (Array.isArray(source) && paths[0] === "*") {
            source.forEach((item, idx) => {
                disposers.push(this._forwardObservable(item, paths[1], pathPrefix + "." + idx, callback));
            });
        }
        else if (source.propertyChanged) {
            const dispose = source.propertyChanged.attach((sender, detail) => {
                if (detail.propertyName === paths[0]) {
                    if (subDispose) {
                        subDispose();
                        disposers.remove(subDispose);
                    }
                    const newValue = detail.newValue;
                    if (newValue && paths.length === 2 && paths[1] !== "*") {
                        subDispose = this._forwardObservable(newValue, paths[1], pathToNotify, callback);
                        disposers.push(subDispose);
                    }
                    this.notifyPath(pathToNotify, newValue);
                    if (callback)
                        callback(pathToNotify);
                }
            });
            disposers.push(dispose);
            if (paths.length === 2) {
                if (paths[1] !== "*") {
                    const subSource = source[paths[0]];
                    if (subSource) {
                        subDispose = this._forwardObservable(subSource, paths[1], pathToNotify, callback);
                        disposers.push(subDispose);
                    }
                }
                else if (!!source.arrayChanged) {
                    const dispose = source.arrayChanged.attach((sender, detail) => {
                        if (detail.arrayPropertyName === paths[0]) {
                            this.notifySplices(`${pathPrefix}.${paths[0]}`, [{
                                    index: detail.index,
                                    removed: detail.removedItems,
                                    addedCount: detail.addedItemCount,
                                    object: source,
                                    type: "splice"
                                }]);
                            if (callback)
                                callback(pathToNotify);
                        }
                    });
                    disposers.push(dispose);
                }
            }
            else if (paths.length === 1 && source[paths[0]] !== undefined && this.get(`${pathPrefix}.${paths[0]}`) !== source[paths[0]])
                this.notifyPath(`${pathPrefix}.${paths[0]}`, source[paths[0]]);
        }
        else if (paths.length === 2) {
            const subSource = source[paths[0]];
            if (subSource) {
                subDispose = this._forwardObservable(subSource, paths[1], pathToNotify, callback);
                disposers.push(subDispose);
            }
        }
        return () => {
            disposers.forEach(d => d());
            disposers.splice(0, disposers.length);
        };
    }
    _computeTranslations(messages) {
        return messages;
    }
    _forwardComputed(value) {
        return value;
    }
    _forwardNegate(value) {
        return !value;
    }
    _forwardTruthy(value) {
        return !!value;
    }
    static _scanTemplateForLayoutClasses(template) {
        if (template.content.querySelectorAll(".layout, .flex").length > 0)
            return true;
        return Array.from(template.content.querySelectorAll("template")).some(t => WebComponent._scanTemplateForLayoutClasses(t));
    }
    static _updateTemplateProperty(element, elementName) {
        const baseTemplate = element["template"];
        if (!baseTemplate)
            return;
        Object.defineProperty(element, "template", {
            get: () => {
                const template = DomModule.import(`${elementName}-template-module`, "template") || baseTemplate;
                const resetStyle = document.createElement("style");
                resetStyle.setAttribute("include", "vi-reset-css-style-module");
                template.content.insertBefore(resetStyle, template.content.firstChild);
                if (WebComponent._scanTemplateForLayoutClasses(template)) {
                    const flexStyle = document.createElement("style");
                    flexStyle.setAttribute("include", "vi-flex-layout-style-module");
                    template.content.insertBefore(flexStyle, resetStyle.nextSibling);
                }
                const userStyleModule = DomModule.import(`${elementName}-style-module`);
                if (userStyleModule != null) {
                    const style = document.createElement("style");
                    style.setAttribute("include", `${elementName}-style-module`);
                    const lastStyle = Array.from(template.content.children).filter(c => c instanceof HTMLStyleElement).pop();
                    if (lastStyle != null)
                        template.content.insertBefore(style, lastStyle.nextSibling);
                    else
                        template.content.insertBefore(style, template.content.firstChild);
                }
                const icons = template.content.querySelectorAll("vi-icon[name]");
                icons.forEach(icon => {
                    const iconTemplate = document.createElement("template");
                    iconTemplate.innerHTML = icon.outerHTML;
                    add(html$3 `${iconTemplate}`);
                    icon.parentNode.removeChild(icon);
                });
                return template;
            },
            enumerable: false
        });
    }
    static _register(element, info = {}, prefix = "vi") {
        const elementName = `${prefix}-${element.name.toKebabCase()}`;
        WebComponent._updateTemplateProperty(element, elementName);
        let baseProperties = {};
        let baseType = Object.getPrototypeOf(element);
        while (baseType !== WebComponent) {
            const basePropertyInfo = baseType["properties"];
            if (!!basePropertyInfo)
                Object.assign(baseProperties, basePropertyInfo || {});
            baseType = Object.getPrototypeOf(baseType);
        }
        info.properties = info.properties || {};
        element["properties"] = info.properties;
        for (const p in info.properties) {
            const prop = info.properties[p];
            if (typeof prop === "object") {
                if (prop.computed && !/\)$/.test(prop.computed)) {
                    if (prop.computed[0] !== "!")
                        prop.computed = "_forwardComputed(" + prop.computed + ")";
                    else {
                        if (prop.computed[1] !== "!")
                            prop.computed = "_forwardNegate(" + prop.computed.substring(1) + ")";
                        else
                            prop.computed = "_forwardTruthy(" + prop.computed.substring(2) + ")";
                    }
                }
            }
        }
        if (!baseProperties.isConnected && !info.properties.isConnected) {
            info.properties.isConnected = {
                type: Boolean,
                readOnly: true
            };
        }
        if (!baseProperties.app && !info.properties.app) {
            info.properties.app = {
                type: Object,
                readOnly: true
            };
        }
        if (!baseProperties.service && !info.properties.service) {
            info.properties.service = {
                type: Object,
                computed: "_forwardComputed(app.service)"
            };
        }
        if (!baseProperties.translations && !info.properties.translations) {
            info.properties.translations = {
                type: Object,
                computed: "_computeTranslations(service.language.messages)"
            };
        }
        if (info.listeners) {
            element.prototype._updateListeners = function (isConnected) {
                if (isConnected) {
                    for (const l in info.listeners) {
                        if (this[info.listeners[l]])
                            this._addEventListenerToNode(this, l, this[info.listeners[l]].bound = this[info.listeners[l]].bind(this));
                        else
                            console.warn(`listener method '${info.listeners[l]}' not defined`);
                    }
                }
                else {
                    for (const l in info.listeners) {
                        if (!this[info.listeners[l]])
                            continue;
                        this._removeEventListenerFromNode(this, l, this[info.listeners[l]].bound);
                        this[info.listeners[l]].bound = undefined;
                    }
                }
            };
        }
        element["observers"] = info.observers || (info.observers = []);
        info.forwardObservers = info.forwardObservers || [];
        info.forwardObservers.push("service.language");
        info.forwardObservers.push("service.language.messages");
        info.forwardObservers.groupBy(path => {
            const functionIndex = path.indexOf("(");
            return (functionIndex > 0 ? path.substr(functionIndex + 1) : path).split(".", 2)[0];
        }).forEach(source => {
            const methodName = `_observablePropertyObserver_${source.key}`;
            const methodValues = `${methodName}_values`;
            if (!!element.prototype[methodName]) {
                const values = Array.from(element.prototype[methodValues]);
                source.value.forEach(v => {
                    if (values.indexOf(v) >= 0)
                        return;
                    values.push(v);
                });
                return;
            }
            element.prototype[methodValues] = source.value.slice(0);
            info.observers.push(`${methodName}(${source.key}, isConnected)`);
            element.prototype[methodName] = function (sourceObj, isConnected) {
                if (sourceObj == null)
                    return;
                const forwardObserversCollectionName = `_forwardObservers_${source.key}`;
                const forwardObservers = this[forwardObserversCollectionName] || (this[forwardObserversCollectionName] = []) || [];
                while (forwardObservers.length > 0)
                    forwardObservers.pop()();
                if (!isConnected)
                    return;
                element.prototype[methodValues].forEach((p) => {
                    const functionIndex = p.indexOf("(");
                    const path = functionIndex > 0 ? p.substr(functionIndex + source.key.length + 2, p.length - (functionIndex + source.key.length + 2) - 1) : p.substr(source.key.length + 1);
                    let observer = functionIndex > 0 ? this[p.substr(0, functionIndex)] : null;
                    if (observer)
                        observer = observer.bind(this);
                    forwardObservers.push(this._forwardObservable(sourceObj, path, source.key, observer));
                    if (observer && sourceObj && isConnected) {
                        const valuePath = path.slice().split(".").reverse();
                        let value = sourceObj;
                        do {
                            value = value[valuePath.pop()];
                        } while (value != null && valuePath.length > 0);
                        observer(value);
                    }
                });
            };
        });
        if (info.keybindings) {
            (info.observers = info.observers || []).push("_keybindingsObserver(isConnected)");
            element.prototype._keybindingsObserver = function (isConnected) {
                if (isConnected) {
                    if (!this._keybindingRegistrations)
                        this._keybindingRegistrations = [];
                    const registerKeybinding = (keys) => {
                        let keybinding = info.keybindings[keys];
                        if (typeof keybinding === "string")
                            keybinding = { listener: keybinding };
                        const listener = this[keybinding.listener];
                        if (!listener) {
                            console.warn("Keybindings listener '" + keybinding.listener + "' not found on element " + this.is);
                            return;
                        }
                        const eventListener = (e) => {
                            let combo = e.detail.combo;
                            if (e.detail.keyboardEvent.ctrlKey && combo.indexOf("ctrl") < 0)
                                combo = "ctrl+" + combo;
                            if (e.detail.keyboardEvent.shiftKey && combo.indexOf("shift") < 0)
                                combo = "shift+" + combo;
                            if (e.detail.keyboardEvent.altKey && combo.indexOf("alt") < 0)
                                combo = "alt+" + combo;
                            const registrations = this._keybindingRegistrations.find(r => r.keys.some(k => k === combo));
                            if (!registrations)
                                return;
                            if (listener.call(this, e.detail.keyboardEvent) === true)
                                return;
                            e.stopPropagation();
                            e.detail.keyboardEvent.stopPropagation();
                            e.detail.keyboardEvent.preventDefault();
                        };
                        const element = document.createElement("iron-a11y-keys");
                        element.target = this;
                        element.keys = keys;
                        element.style.display = "none";
                        element.addEventListener("keys-pressed", eventListener);
                        const registration = {
                            keys: keys.split(" "),
                            element: element,
                            listener: eventListener,
                            priority: keybinding.priority || 0,
                            nonExclusive: keybinding.nonExclusive
                        };
                        this._keybindingRegistrations.push(registration);
                        this.shadowRoot.appendChild(element);
                        this.app._registerKeybindings(registration);
                    };
                    for (const keys in info.keybindings) {
                        registerKeybinding(keys);
                    }
                }
                else {
                    if (this._keybindingRegistrations) {
                        while (this._keybindingRegistrations.length > 0) {
                            const reg = this._keybindingRegistrations.splice(0, 1)[0];
                            this.app._unregisterKeybindings(reg);
                            reg.element.removeEventListener("keys-pressed", reg.listener);
                            this.shadowRoot.removeChild(reg.element);
                        }
                    }
                }
            };
        }
        if (info.mediaQueryAttributes) {
            info.properties.isDesktop = {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            };
            info.properties.isTablet = {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            };
            info.properties.isPhone = {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            };
            info.observers.push("_mediaQueryObserver(app)");
            element.prototype._mediaQueryObserver = function (app) {
                if (this._mediaQueryObserverInfo) {
                    this._mediaQueryObserverInfo.app.removeEventListener("media-query-changed", this._mediaQueryObserverInfo.listener);
                    this._mediaQueryObserverInfo = null;
                }
                if (app) {
                    this._mediaQueryObserverInfo = {
                        app: app,
                        listener: (e) => {
                            this["_setIsDesktop"](e["detail"] === "desktop");
                            this["_setIsTablet"](e["detail"] === "tablet");
                            this["_setIsPhone"](e["detail"] === "phone");
                        }
                    };
                    this["_setIsDesktop"](app["isDesktop"]);
                    this["_setIsTablet"](app["isTablet"]);
                    this["_setIsPhone"](app["isPhone"]);
                    app.addEventListener("media-query-changed", this._mediaQueryObserverInfo.listener);
                }
            };
        }
        if (info.sensitive) {
            info.properties.isAppSensitive = {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                value: false
            };
            info.serviceBusObservers = info.serviceBusObservers || {};
            info.serviceBusObservers["vi-app:sensitive-changed"] = "_appSensitiveChangedObserver";
            element.prototype._appSensitiveChangedObserver = function (sender, message, detail) {
                this["_setIsAppSensitive"](detail);
            };
        }
        if (info.serviceBusObservers) {
            (info.observers = info.observers || []).push("_serviceBusObserver(isConnected)");
            element.prototype["_serviceBusObserver"] = function (isConnected) {
                if (!this._serviceBusRegistrations)
                    this._serviceBusRegistrations = [];
                if (isConnected) {
                    for (const message in info.serviceBusObservers) {
                        const callback = this[info.serviceBusObservers[message]];
                        if (callback)
                            this._serviceBusRegistrations.push(ServiceBus.subscribe(message, callback.bind(this), true));
                        else
                            console.warn("ServiceBus listener callback '" + message + "' not found on element " + this.is);
                    }
                }
                else {
                    this._serviceBusRegistrations.forEach(disposer => disposer());
                    this._serviceBusRegistrations = [];
                }
            };
        }
        for (let p in info.properties) {
            if (typeof info.properties[p] === "object") {
                const prop = info.properties[p];
                if (prop.computed && !prop.computed.startsWith("_forwardComputed(") && !prop.computed.startsWith("_forwardNegate(")) {
                    if (elementName.startsWith("vi-") && (!prop.computed.startsWith("_compute") && !prop.computed.startsWith("op_")))
                        console.warn(`Naming convention violation for computed property "${p}" on element "${elementName}"`);
                }
            }
        }
        for (let fn of Object.getOwnPropertyNames(Operations.prototype)) {
            if (fn === "constructor")
                continue;
            element.prototype[`op_${fn}`] = Operations.prototype[fn];
        }
        window.customElements.define(elementName, element);
        return element;
    }
    static register(infoOrTarget, prefix) {
        return (target) => {
            let currentProto = Object.getPrototypeOf(target);
            let info = {};
            while (currentProto && currentProto !== WebComponent) {
                const baseInfo = WebComponent.abstractRegistrations[currentProto.name];
                if (baseInfo)
                    info = WebComponent._clone(extend$2(info, WebComponent._clone(baseInfo)));
                currentProto = Object.getPrototypeOf(currentProto);
            }
            const targetInfo = infoOrTarget;
            if (targetInfo) {
                if (targetInfo.properties)
                    info.properties = info.properties ? extend$2(info.properties, targetInfo.properties) : targetInfo.properties;
                if (targetInfo.listeners)
                    info.listeners = info.listeners ? extend$2(info.listeners, targetInfo.listeners) : targetInfo.listeners;
                if (targetInfo.keybindings)
                    info.keybindings = info.keybindings ? extend$2(info.keybindings, targetInfo.keybindings) : targetInfo.keybindings;
                if (targetInfo.observers)
                    info.observers ? info.observers.push(...targetInfo.observers) : (info.observers = targetInfo.observers);
                if (targetInfo.forwardObservers)
                    info.forwardObservers ? info.forwardObservers.push(...targetInfo.forwardObservers) : (info.forwardObservers = targetInfo.forwardObservers);
                if (typeof targetInfo.mediaQueryAttributes !== "undefined")
                    info.mediaQueryAttributes = targetInfo.mediaQueryAttributes;
                if (typeof targetInfo.sensitive !== "undefined")
                    info.sensitive = targetInfo.sensitive;
                if (targetInfo.serviceBusObservers)
                    info.serviceBusObservers = info.serviceBusObservers ? extend$2(info.serviceBusObservers, targetInfo.serviceBusObservers) : targetInfo.serviceBusObservers;
            }
            return WebComponent._register(target, WebComponent._clone(info), prefix);
        };
    }
    static registerAbstract(info) {
        return (target) => {
            WebComponent.abstractRegistrations[Object(target).name] = info;
        };
    }
    static _clone(source, depth = 0) {
        const output = Array.isArray(source) ? [] : {};
        for (let key in source) {
            if (key === "behaviors" && depth === 0) {
                output[key] = source[key];
                continue;
            }
            const value = source[key];
            output[key] = (value != null && typeof value === "object") ? WebComponent._clone(value, depth + 1) : value;
        }
        return output;
    }
}
WebComponent.abstractRegistrations = {};

let resizeObserver$2;
resizeObserver$2 = new ResizeObserver(entries => {
    entries.forEach(e => {
        let tracker = [...Array.from(e.target.shadowRoot?.children || []), ...Array.from(e.target.children || [])].find(e => e instanceof SizeTracker);
        if (tracker)
            tracker["_triggerSizeChanged"](e.contentRect);
    });
});
let SizeTracker = class SizeTracker extends WebComponent {
    connectedCallback() {
        super.connectedCallback();
        this.style.display = "none";
        if (this.deferred)
            return;
        this.measure();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        resizeObserver$2.unobserve(this._parentElement);
    }
    measure() {
        if (!this._isActive) {
            this.deferred = false;
            resizeObserver$2.observe(this._parentElement);
            this._isActive = true;
        }
        if (this._resizeLast) {
            this._setSize(this._resizeLast);
            this.fire("sizechanged", this._resizeLast, { node: this, bubbles: !!this.bubbles });
        }
    }
    get _parentElement() {
        return this.parentElement || this.getRootNode()?.host;
    }
    _triggerSizeChanged(cr) {
        if (!this._resizeLast || cr.width !== this._resizeLast.width || cr.height !== this._resizeLast.height) {
            this._resizeLast = {
                width: cr.width,
                height: cr.height
            };
            if ((this._resizeLast.width === 0 || this._resizeLast.height === 0) && !this.triggerZero)
                return;
            this._setSize(this._resizeLast);
            this.fire("sizechanged", this._resizeLast, { node: this, bubbles: !!this.bubbles });
        }
    }
};
SizeTracker = __decorate([
    WebComponent.register({
        properties: {
            deferred: {
                type: Boolean,
                reflectToAttribute: true
            },
            size: {
                type: Object,
                readOnly: true,
                notify: true
            },
            triggerZero: {
                type: Boolean,
                reflectToAttribute: true
            },
            bubbles: {
                type: Boolean,
                reflectToAttribute: true
            },
            noResizeObserver: {
                type: Boolean,
                readOnly: true
            }
        }
    })
], SizeTracker);

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element);
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  node.assignedSlot ||
  node.parentNode ||
  isShadowRoot(node) && node.host ||
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window = getWindow(element);
  if (!isHTMLElement(element)) {
    return window;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}
const getElementRects = async function (_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...(await getDimensionsFn(floating))
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === 'rtl';
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => {
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

var Scroller_1;
let Scroller = Scroller_1 = class Scroller extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  position: relative;
  --vi-scroller-thumb-color: #888;
  --vi-scroller-thumb-hover-color: #777;
  --vi-scroller-thumb-size: var(--theme-h5);
  --vi-scroller-thumb-hover-size: calc(var(--theme-h5) + 2px);
  --vi-scroller-thumb-capture-size: calc(var(--theme-h4) + 2px);
  --vi-scroller-thumb-parent-hover-size: calc(var(--theme-h5) + 6px);
}
:host .scroll-host {
  overflow: hidden;
  display: flex;
  flex-direction: row;
  position: relative;
}
:host .wrapper {
  flex: 1;
  min-height: 0;
  min-width: 0;
  position: relative;
  overflow: auto;
  outline: none !important;
  -ms-overflow-style: none;
  scrollbar-width: none;
  -webkit-overflow-scrolling: touch;
  line-height: 0;
}
:host .wrapper::-webkit-scrollbar {
  display: none;
}
:host .wrapper .content {
  line-height: normal;
}
:host([no-horizontal]:not([no-vertical])) .wrapper {
  display: flex;
  flex-direction: column;
}
:host([no-horizontal]:not([no-vertical])) .wrapper .content {
  min-height: auto;
}
:host([no-vertical]:not([no-horizontal])) .wrapper {
  display: flex;
  flex-direction: row;
  margin-right: 0;
  overflow-y: hidden;
}
:host([no-vertical][no-horizontal]) .wrapper {
  display: flex;
  flex-direction: row;
  overflow: hidden;
  margin: 0 !important;
}
:host([no-vertical][no-horizontal]) .wrapper .content {
  flex: 1;
  min-height: 0;
  min-width: 0;
  display: flex;
  flex-direction: row;
  min-height: initial;
  min-width: initial;
}
:host([no-vertical][no-horizontal]) .wrapper .content > :not(vi-size-tracker) {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host(:not([no-vertical]):not([no-horizontal])) .wrapper > .content {
  display: inline-block;
  min-width: 100%;
}
:host(:not([force-scrollbars]):not([hovering]):not([scrolling])) .scrollbar-parent .scrollbar {
  opacity: 0;
}
:host .scrollbar-parent {
  position: absolute;
  background-color: transparent;
  display: none;
  z-index: 1;
}
:host .scrollbar-parent:before {
  position: absolute;
  content: " ";
  background-color: transparent;
  transition: all 0.2s ease-in-out;
}
:host .scrollbar-parent.vertical:before {
  top: 0;
  right: 0;
  bottom: 0;
  width: var(--vi-scroller-thumb-parent-hover-size);
}
:host .scrollbar-parent.horizontal:before {
  left: 0;
  right: 0;
  bottom: 0;
  height: var(--vi-scroller-thumb-parent-hover-size);
}
:host .scrollbar-parent .scrollbar {
  position: absolute;
  opacity: 1;
  transition: opacity 0.2s ease-in-out;
}
:host .scrollbar-parent .scrollbar:after {
  content: " ";
  position: absolute;
  background-color: var(--vi-scroller-thumb-color);
  border-radius: var(--theme-h5);
}
:host .scrollbar-parent .scrollbar#vertical {
  top: 0;
  right: 0;
  width: var(--vi-scroller-thumb-capture-size);
}
:host .scrollbar-parent .scrollbar#vertical:after {
  right: 2px;
  top: 0;
  bottom: 0;
  width: var(--vi-scroller-thumb-size);
  transition: width 0.2s ease-in-out;
}
:host .scrollbar-parent .scrollbar#horizontal {
  left: 0;
  bottom: 0;
  height: var(--vi-scroller-thumb-capture-size);
}
:host .scrollbar-parent .scrollbar#horizontal:after {
  bottom: 2px;
  left: 0;
  right: 0;
  height: var(--vi-scroller-thumb-size);
  transition: height 0.2s ease-in-out;
}
:host .scrollbar-parent.horizontal {
  height: var(--vi-scroller-thumb-capture-size);
  left: 0;
  right: 0;
  bottom: 0;
}
:host .scrollbar-parent.vertical {
  width: var(--vi-scroller-thumb-capture-size);
  top: 0;
  bottom: 0;
  right: var(--vi-scroller-vertical-scrollbar-right, 0);
  left: var(--vi-scroller-vertical-scrollbar-left, initial);
}
:host([horizontal]) .scrollbar-parent.horizontal, :host([vertical]) .scrollbar-parent.vertical {
  display: block;
}
:host([align-vertical-scrollbar=left]) .vertical {
  right: auto;
  left: 0;
}
:host([scrolling]) .wrapper {
  pointer-events: none;
}
:host([vertical][scrolling=vertical]) .scrollbar-parent.vertical:before, :host .scrollbar-parent.vertical:hover:before, :host([horizontal][scrolling=horizontal]) .scrollbar-parent.horizontal:before, :host .scrollbar-parent.horizontal:hover:before {
  background-color: rgba(0, 0, 0, 0.1);
}
:host([vertical][scrolling=vertical]) .scrollbar-parent.vertical .scrollbar:after, :host .scrollbar-parent.vertical:hover .scrollbar:after, :host([horizontal][scrolling=horizontal]) .scrollbar-parent.horizontal .scrollbar:after, :host .scrollbar-parent.horizontal:hover .scrollbar:after {
  background-color: var(--vi-scroller-thumb-hover-color);
}
:host([vertical][scrolling=vertical]) .scrollbar-parent.vertical .scrollbar#vertical:after, :host .scrollbar-parent.vertical:hover .scrollbar#vertical:after, :host([horizontal][scrolling=horizontal]) .scrollbar-parent.horizontal .scrollbar#vertical:after, :host .scrollbar-parent.horizontal:hover .scrollbar#vertical:after {
  width: var(--vi-scroller-thumb-hover-size);
}
:host([vertical][scrolling=vertical]) .scrollbar-parent.vertical .scrollbar#horizontal:after, :host .scrollbar-parent.vertical:hover .scrollbar#horizontal:after, :host([horizontal][scrolling=horizontal]) .scrollbar-parent.horizontal .scrollbar#horizontal:after, :host .scrollbar-parent.horizontal:hover .scrollbar#horizontal:after {
  height: var(--vi-scroller-thumb-hover-size);
}
:host([horizontal]) .wrapper .content > div {
  padding-bottom: var(--vi-scroller-thumb-capture-size);
}
:host .scroll-shadow-parent {
  position: absolute;
  left: 0;
  right: 0;
  height: var(--theme-h2);
  overflow: hidden;
  pointer-events: none;
  z-index: 0;
}
:host .scroll-shadow-parent > .scroll-shadow {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  box-shadow: 0 0 calc(var(--theme-h2) / 2) rgba(0, 0, 0, 0.3);
  bottom: 0;
  border-radius: 100%;
  left: calc(var(--theme-h2) * -1);
  right: calc(var(--theme-h2) * -1);
  pointer-events: none;
  will-change: transform;
  transition: transform 0.3s ease-out;
  z-index: 1;
}
:host .scroll-shadow-parent > .scroll-shadow.top {
  transform: translateY(calc(var(--vi-scroller--scroll-shadow-top-offset, var(--theme-h2)) * -1.5));
}
:host .scroll-shadow-parent > .scroll-shadow.bottom {
  transform: translateY(calc(var(--vi-scroller--scroll-shadow-top-offset, var(--theme-h2)) * 1.5));
}
:host .scroll-shadow-parent.top {
  top: var(--vi-scroller--scroll-shadow-top-offset, 0);
}
:host .scroll-shadow-parent.bottom {
  bottom: var(--vi-scroller--scroll-shadow-bottom-offset, 0);
}
:host([scroll-top-shadow]) .scroll-shadow-parent > .scroll-shadow.top {
  transform: translateY(calc(var(--theme-h2) * -1));
}
:host([scroll-bottom-shadow]) .scroll-shadow-parent > .scroll-shadow.bottom {
  transform: translateY(var(--theme-h2));
}
:host([hide-scrollbars]) .scrollbar-parent {
  visibility: hidden;
}
:host([hide-native-scrollbar]:not([allow-native])[vertical]) .wrapper {
  margin-right: calc(var(--theme-scrollbar-width) * -1);
}
:host([hide-native-scrollbar]:not([allow-native])[horizontal]) .wrapper {
  margin-bottom: calc(var(--theme-scrollbar-width) * -1);
}
:host([hide-native-scrollbar][allow-native]) .scrollbar-parent {
  display: none !important;
}</style>

<main class="layout horizontal flex relative">
    <div id="wrapper" class="flex wrapper" tabindex="-1">
        <vi-size-tracker class="fit" on-sizechanged="_outerSizeChanged"></vi-size-tracker>
        <div id="content" class="relative content">
            <vi-size-tracker on-sizechanged="_innerSizeChanged" trigger-zero></vi-size-tracker>
            <slot></slot>
        </div>
    </div>
    
    <div class="top scroll-shadow-parent">
        <div class="top scroll-shadow"></div>
    </div>
    <div class="bottom scroll-shadow-parent">
        <div class="bottom scroll-shadow"></div>
    </div>
</main>

<div class="horizontal scrollbar-parent" on-tap="_horizontalScrollbarParentTap">
    <div id="horizontal" class="scrollbar" on-track="_trackHorizontal" on-mousedown="_trapEvent"></div>
</div>
<div class="vertical scrollbar-parent" on-tap="_verticalScrollbarParentTap">
    <div id="vertical" class="scrollbar" on-track="_trackVertical" on-mousedown="_trapEvent"></div>
</div>`; }
    connectedCallback() {
        super.connectedCallback();
        this.scroller.addEventListener("scroll", this._scrollEventListener = this._scroll.bind(this), { capture: true, passive: true });
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.scroller.removeEventListener("scroll", this._scrollEventListener);
    }
    get scroller() {
        return this.$.wrapper;
    }
    async scrollToTop(offsetTop = 0, animated) {
        if (animated) {
            this.scroller.scrollTo({
                top: offsetTop,
                behavior: "smooth"
            });
        }
        else
            this.scroller.scrollTop = offsetTop;
    }
    scrollToBottom(animated) {
        if (animated) {
            this.scroller.scrollTo({
                top: this.innerHeight,
                behavior: "smooth"
            });
        }
        else
            this.scroller.scrollTop = this.innerHeight;
    }
    _outerSizeChanged(e, detail) {
        this._setOuterWidth(detail.width);
        this._setOuterHeight(detail.height);
        this._updateScrollOffsets();
        e.stopPropagation();
    }
    _innerSizeChanged(e, detail) {
        this._setInnerWidth(detail.width);
        this._setInnerHeight(detail.height);
        this._updateScrollOffsets();
        e.stopPropagation();
    }
    _updateVerticalScrollbar(outerHeight, innerHeight, verticalScrollOffset, noVertical) {
        let height = outerHeight < innerHeight ? outerHeight / innerHeight * outerHeight : 0;
        if (height !== this._verticalScrollHeight) {
            if (height > 0 && height < Scroller_1._minBarSize)
                height = Scroller_1._minBarSize;
            else
                height = Math.floor(height);
            this._verticalScrollSpace = outerHeight - height;
            if (height !== this._verticalScrollHeight) {
                this._verticalScrollHeight = height;
                this.$.vertical.style.height = `${height}px`;
            }
        }
        this._setVertical(!noVertical && height > 0);
        const verticalScrollTop = verticalScrollOffset === 0 || innerHeight - outerHeight === 0 ? 0 : Math.round((1 / ((innerHeight - outerHeight) / verticalScrollOffset)) * this._verticalScrollSpace);
        if (verticalScrollTop !== this._verticalScrollTop)
            this.$.vertical.style.transform = `translateY(${this._verticalScrollTop = verticalScrollTop}px)`;
        this._setScrollTopShadow(!this.noScrollShadow && verticalScrollTop > 0);
        this._setScrollBottomShadow(!this.noScrollShadow && Math.floor(innerHeight - verticalScrollOffset - outerHeight) > 0);
    }
    _updateHorizontalScrollbar(outerWidth, innerWidth, horizontalScrollOffset, noHorizontal) {
        let width = outerWidth < innerWidth ? outerWidth / innerWidth * outerWidth : 0;
        if (width !== this._horizontalScrollWidth) {
            if (width > 0 && width < Scroller_1._minBarSize)
                width = Scroller_1._minBarSize;
            else
                width = Math.floor(width);
            this._horizontalScrollSpace = outerWidth - width;
            if (width !== this._horizontalScrollWidth) {
                this._horizontalScrollWidth = width;
                this.$.horizontal.style.width = `${width}px`;
            }
        }
        this._setHorizontal(!noHorizontal && width > 0);
        const horizontalScrollLeft = horizontalScrollOffset === 0 ? 0 : Math.round((1 / ((innerWidth - outerWidth) / horizontalScrollOffset)) * this._horizontalScrollSpace);
        if (horizontalScrollLeft !== this._horizontalScrollLeft)
            this.$.horizontal.style.transform = `translate3d(${this._horizontalScrollLeft = horizontalScrollLeft}px, 0, 0)`;
    }
    _trackVertical(e) {
        if (e.detail.state === "start") {
            this._setScrolling("vertical");
            this._trackStart = this._verticalScrollTop;
        }
        else if (e.detail.state === "track") {
            const newVerticalScrollTop = this._trackStart + e.detail.dy;
            this.scroller.scrollTop = newVerticalScrollTop === 0 ? 0 : (this.innerHeight - this.outerHeight) * ((1 / this._verticalScrollSpace) * newVerticalScrollTop);
        }
        else if (e.detail.state === "end") {
            this._setScrolling(null);
            this._trackStart = undefined;
        }
        e.preventDefault();
        if (e.sourceEvent)
            e.sourceEvent.preventDefault();
    }
    _trackHorizontal(e) {
        if (e.detail.state === "start") {
            this._setScrolling("horizontal");
            this._trackStart = this._horizontalScrollLeft;
        }
        else if (e.detail.state === "track") {
            const newHorizontalScrollLeft = this._trackStart + e.detail.dx;
            this.scroller.scrollLeft = newHorizontalScrollLeft === 0 ? 0 : (this.innerWidth - this.outerWidth) * ((1 / this._horizontalScrollSpace) * newHorizontalScrollLeft);
        }
        else if (e.detail.state === "end") {
            this._setScrolling(null);
            this._trackStart = undefined;
        }
        e.preventDefault();
        if (e.sourceEvent)
            e.sourceEvent.preventDefault();
    }
    _trapEvent(e) {
        this.scrollTop = this.scrollLeft = 0;
        e.preventDefault();
        e.stopPropagation();
    }
    _scroll(e) {
        this._updateScrollOffsets();
    }
    _updateScrollOffsets() {
        if (this.vertical) {
            this._setAtTop((this.verticalScrollOffset = this.scroller.scrollTop) === 0);
            this._setAtBottom(Math.abs(Math.round(this.scroller.scrollTop + this.scroller.offsetHeight) - this.scroller.scrollHeight) <= 1);
        }
        if (this.horizontal) {
            this._setAtStart((this.horizontalScrollOffset = this.scroller.scrollLeft) === 0);
            this._setAtEnd(Math.abs(Math.round(this.scroller.scrollLeft + this.scroller.offsetWidth) - this.scroller.scrollWidth) <= 1);
        }
    }
    _verticalScrollOffsetChanged(newVerticalScrollOffset) {
        if (this.scroller.scrollTop === newVerticalScrollOffset)
            return;
        this.scroller.scrollTop = newVerticalScrollOffset;
    }
    _horizontalScrollOffsetChanged(newHorizontalScrollOffset) {
        if (this.scroller.scrollLeft === newHorizontalScrollOffset)
            return;
        this.scroller.scrollLeft = newHorizontalScrollOffset;
    }
    _mouseenter() {
        this._setHovering(true);
    }
    _mouseleave() {
        this._setHovering(false);
    }
    _verticalScrollbarParentTap(e) {
        const event = e.detail.sourceEvent;
        if (event.offsetY) {
            if (event.offsetY > this._verticalScrollTop + this._verticalScrollHeight)
                this.scroller.scrollTop += this.scroller.scrollHeight * 0.1;
            else if (event.offsetY < this._verticalScrollTop)
                this.scroller.scrollTop -= this.scroller.scrollHeight * 0.1;
            e.stopPropagation();
        }
    }
    _horizontalScrollbarParentTap(e) {
        const event = e.detail.sourceEvent;
        if (event.offsetX) {
            if (event.offsetX > this._horizontalScrollLeft + this._horizontalScrollLeft)
                this.scroller.scrollLeft += this.scroller.scrollWidth * 0.1;
            else if (event.offsetX < this._horizontalScrollLeft)
                this.scroller.scrollLeft -= this.scroller.scrollWidth * 0.1;
            e.stopPropagation();
        }
    }
};
Scroller._minBarSize = 40;
Scroller = Scroller_1 = __decorate([
    WebComponent.register({
        properties: {
            hovering: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            scrolling: {
                type: String,
                readOnly: true,
                reflectToAttribute: true
            },
            atTop: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                value: true
            },
            atBottom: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            atStart: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                value: true
            },
            atEnd: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            outerWidth: {
                type: Number,
                notify: true,
                readOnly: true
            },
            outerHeight: {
                type: Number,
                notify: true,
                readOnly: true
            },
            innerWidth: {
                type: Number,
                readOnly: true
            },
            innerHeight: {
                type: Number,
                readOnly: true
            },
            horizontal: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            alignVerticalScrollbar: {
                type: String,
                reflectToAttribute: true
            },
            noHorizontal: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            vertical: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            noVertical: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            scrollbars: {
                type: String,
                reflectToAttribute: true
            },
            verticalScrollOffset: {
                type: Number,
                value: 0,
                notify: true,
                observer: "_verticalScrollOffsetChanged"
            },
            horizontalScrollOffset: {
                type: Number,
                value: 0,
                notify: true,
                observer: "_horizontalScrollOffsetChanged"
            },
            noScrollShadow: {
                type: Boolean,
                reflectToAttribute: true
            },
            scrollTopShadow: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
            },
            scrollBottomShadow: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            forceScrollbars: {
                type: Boolean,
                reflectToAttribute: true
            },
            hideScrollbars: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        forwardObservers: [
            "attribute.objects"
        ],
        observers: [
            "_updateVerticalScrollbar(outerHeight, innerHeight, verticalScrollOffset, noVertical)",
            "_updateHorizontalScrollbar(outerWidth, innerWidth, horizontalScrollOffset, noHorizontal)"
        ],
        listeners: {
            "mouseenter": "_mouseenter",
            "mouseleave": "_mouseleave",
            "scroll": "_trapEvent"
        }
    })
], Scroller);

var _Popup_cleanup;
var Popup_1;
let _documentClosePopupListener;
document.addEventListener("mousedown", _documentClosePopupListener = e => {
    const path = e.composedPath().slice();
    do {
        const el = path.shift();
        if (!el || el === document) {
            Popup.closeAll();
            break;
        }
        else if (el.__Vidyano_WebComponents_PopupCore__Instance__ && el.open)
            break;
        else if (el.popup && el.popup.__Vidyano_WebComponents_PopupCore__Instance__ && el.popup.open)
            break;
    } while (true);
});
document.addEventListener("touchstart", _documentClosePopupListener);
const openPopups = [];
let Popup = Popup_1 = class Popup extends WebComponent {
    constructor() {
        super(...arguments);
        _Popup_cleanup.set(this, void 0);
        this.__Vidyano_WebComponents_PopupCore__Instance__ = true;
    }
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
}
:host #popup {
  position: fixed;
  background-color: white;
  transition: opacity 0.1s ease-out;
  overflow: visible;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}
:host #popup[popover] {
  border: none;
  margin: 0;
  outline: none;
  padding: 0;
}
:host #popup:not([popover]) {
  visibility: hidden;
  opacity: 0;
}
:host([open]) #popup:not([popover]) {
  visibility: visible;
  opacity: 1;
  z-index: 11;
}

#anchor {
  width: 100%;
  box-sizing: border-box;
  cursor: pointer;
}</style>

<vi-size-tracker on-sizechanged="_toggleSizeChanged"></vi-size-tracker>
<div id="anchor" class="layout horizontal" part="anchor">
    <slot name="header"></slot>
</div>

<div id="popup" part="popup" class="relative" on-tap="_catchContentClick" on-mouseenter="_contentMouseEnter" on-mouseleave="_contentMouseLeave" popover="[[_getPopover(supportsPopover)]]">
    <vi-size-tracker on-sizechanged="refit"></vi-size-tracker>
    <slot></slot>
</div>`; }
    connectedCallback() {
        super.connectedCallback();
        this.addEventListener("popupparent", this._onPopupparent);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("popupparent", this._onPopupparent);
        __classPrivateFieldGet(this, _Popup_cleanup, "f")?.call(this);
    }
    popup() {
        if (this.open)
            return Promise.resolve();
        return new Promise(resolve => {
            this._resolver = resolve;
            this._open();
        });
    }
    _open() {
        if (!this.renderPopupCoreFit) {
            this._setRenderPopupCoreFit(true);
            flush$1();
        }
        const parentPopup = this._findParentPopup();
        if (this.open || this.hasAttribute("disabled") || this.fire("popup-opening", null, { bubbles: false, cancelable: true }).defaultPrevented)
            return;
        const firstOpenNonParentChild = openPopups[parentPopup == null ? 0 : openPopups.indexOf(parentPopup) + 1];
        if (firstOpenNonParentChild != null)
            firstOpenNonParentChild.close();
        __classPrivateFieldSet(this, _Popup_cleanup, autoUpdate(this.$.anchor, this.$.popup, this.refit.bind(this)), "f");
        this._setOpen(true);
        openPopups.push(this);
        this.fire("popup-opened", null, { bubbles: false, cancelable: false });
    }
    _sizeChanged(e) {
        if (!this.open)
            return;
        this.refit();
    }
    async refit() {
        let { x, y } = await computePosition(this.$.anchor, this.$.popup, {
            placement: this.placement,
            strategy: "fixed",
            middleware: [
                flip(),
                shift({
                    boundary: this.supportsPopover ? undefined : this.findParent(e => e instanceof Scroller)?.scroller,
                    rootBoundary: this.supportsPopover ? "viewport" : undefined
                }),
                size({
                    apply({ availableWidth, availableHeight, elements }) {
                        const slottedElements = elements.floating.querySelector("slot").assignedElements();
                        if (slottedElements.length === 1 && slottedElements[0] instanceof Scroller) {
                            Object.assign(slottedElements[0].style, {
                                maxWidth: `${availableWidth - 5}px`,
                                maxHeight: `${availableHeight - 5}px`,
                            });
                        }
                    },
                }),
                topLayerOverTransforms()
            ]
        });
        Object.assign(this.$.popup.style, {
            left: `${x}px`,
            top: `${y}px`,
            minWidth: this.autoWidth && this._toggleSize?.width ? `${this._toggleSize.width}px` : undefined
        });
    }
    close() {
        if (!this.open || this.fire("popup-closing", null, { bubbles: false, cancelable: true }).defaultPrevented)
            return;
        if (!this.open && this._closeOnMoveoutTimer) {
            clearTimeout(this._closeOnMoveoutTimer);
            this._closeOnMoveoutTimer = undefined;
        }
        const openChild = openPopups[openPopups.indexOf(this) + 1];
        if (openChild != null)
            openChild.close();
        this._currentTarget = null;
        this._setOpen(false);
        this._setHover(false);
        if (this._resolver)
            this._resolver();
        __classPrivateFieldGet(this, _Popup_cleanup, "f")?.call(this);
        openPopups.remove(this);
        this.fire("popup-closed", null, { bubbles: false, cancelable: false });
    }
    _hookTapAndHoverEvents() {
        this._header = this.$.anchor || this.parentElement;
        if (this._header === this.parentElement)
            this._header.popup = this;
        if (this.isConnected) {
            if (this.openOnHover) {
                this._header.addEventListener("mouseenter", this._enterHandler = () => this.popup());
                this.addEventListener("mouseleave", this._leaveHandler = this.close.bind(this));
            }
            else
                this._header.addEventListener("tap", this._tapHandler = this._tap.bind(this));
        }
        else {
            if (this._enterHandler) {
                this._header.removeEventListener("mouseenter", this._enterHandler);
                this._enterHandler = undefined;
            }
            if (this._leaveHandler) {
                this.removeEventListener("mouseleave", this._leaveHandler);
                this._leaveHandler = undefined;
            }
            if (this._tapHandler) {
                this._header.removeEventListener("tap", this._tapHandler);
                this._tapHandler = undefined;
            }
        }
    }
    _tap(e) {
        if (this.disabled)
            return;
        if (this.open) {
            if (!this.sticky)
                this.close();
            return;
        }
        const path = e.composedPath().slice();
        do {
            if (this._header !== path.shift())
                continue;
            this.popup();
            e.stopPropagation();
            break;
        } while (path.length);
    }
    _onPopupparent(e) {
        e.detail.popup = this;
        e.stopPropagation();
    }
    _findParentPopup() {
        const e = this.fire("popupparent", { popup: null }, {
            bubbles: true,
            composed: true,
            node: this.parentElement || this.parentNode?.host
        });
        return !e.defaultPrevented ? e.detail.popup : null;
    }
    _catchContentClick(e) {
        if (this.sticky)
            e.stopPropagation();
    }
    _contentMouseEnter(e) {
        if (this._setHover)
            this._setHover(true);
        if (this._closeOnMoveoutTimer) {
            clearTimeout(this._closeOnMoveoutTimer);
            this._closeOnMoveoutTimer = undefined;
        }
    }
    _contentMouseLeave(e) {
        if (this.openOnHover)
            return;
        if (e.relatedTarget == null) {
            e.stopPropagation();
            return;
        }
        if (!this.sticky) {
            this._closeOnMoveoutTimer = setTimeout(() => {
                this.close();
            }, this.closeDelay);
        }
    }
    _openChanged(open) {
        if (!this.supportsPopover)
            return;
        if (open)
            this.$.popup.showPopover();
        else
            this.$.popup.hidePopover();
    }
    _hoverChanged(hover) {
        if (!this._currentTarget)
            return;
        if (hover)
            this._currentTarget.setAttribute("hover", "");
        else
            this._currentTarget.removeAttribute("hover");
    }
    _toggleSizeChanged(e, detail) {
        this._toggleSize = detail;
        if (!this.open)
            return;
        this.refit();
        e.stopPropagation();
    }
    _getPopover(supportsPopover) {
        return supportsPopover ? "" : null;
    }
    static closeAll(parent) {
        const rootPopup = openPopups[0];
        if (rootPopup && (!parent || Popup_1._isDescendant(parent, rootPopup)))
            rootPopup.close();
    }
    static _isDescendant(parent, child) {
        let node = child.parentNode;
        while (node != null) {
            if (node === parent)
                return true;
            node = node.parentNode;
        }
        return false;
    }
};
_Popup_cleanup = new WeakMap();
Popup = Popup_1 = __decorate([
    WebComponent.register({
        properties: {
            closeDelay: {
                type: Number,
                value: 500
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            },
            hover: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                observer: "_hoverChanged"
            },
            open: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                notify: true,
                observer: "_openChanged"
            },
            openOnHover: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            placement: {
                type: String,
                reflectToAttribute: true,
                value: "bottom-start"
            },
            sticky: {
                type: Boolean,
                reflectToAttribute: true
            },
            autoWidth: {
                type: Boolean,
                reflectToAttribute: true
            },
            renderPopupCoreFit: {
                type: Boolean,
                readOnly: true
            },
            supportsPopover: {
                type: Boolean,
                readOnly: true,
                value: () => HTMLElement.prototype.hasOwnProperty("popover")
            },
        },
        observers: [
            "_hookTapAndHoverEvents(isConnected, openOnHover)"
        ],
        listeners: {
            "tap": "_tap"
        }
    })
], Popup);
const topLayerOverTransforms = () => ({
    name: 'topLayer',
    async fn(middlewareArguments) {
        const { x, y, elements: { reference, floating }, } = middlewareArguments;
        let onTopLayer = false;
        let topLayerIsFloating = false;
        let withinReference = false;
        const diffCoords = {
            x: 0,
            y: 0,
        };
        try {
            onTopLayer = onTopLayer || floating.matches(':popover-open');
        }
        catch (error) { }
        try {
            onTopLayer = onTopLayer || floating.matches(':open');
        }
        catch (error) { }
        try {
            onTopLayer = onTopLayer || floating.matches(':modal');
        }
        catch (error) { }
        topLayerIsFloating = onTopLayer;
        const dialogAncestorQueryEvent = new Event('floating-ui-dialog-test', {
            composed: true,
            bubbles: true,
        });
        floating.addEventListener('floating-ui-dialog-test', (event) => {
            event.composedPath().forEach((el) => {
                withinReference = withinReference || el === reference;
                if (el === floating || el.localName !== 'dialog')
                    return;
                try {
                    onTopLayer = onTopLayer || el.matches(':modal');
                }
                catch (error) { }
            });
        }, { once: true });
        floating.dispatchEvent(dialogAncestorQueryEvent);
        let overTransforms = false;
        const root = (withinReference ? reference : floating);
        const containingBlock = isContainingBlock(root)
            ? root
            : getContainingBlock(root);
        let css = {};
        if (containingBlock !== null &&
            getWindow(containingBlock) !==
                containingBlock) {
            css = getComputedStyle(containingBlock);
            overTransforms =
                css.transform !== 'none' ||
                    css.translate !== 'none' ||
                    (css.containerType
                        ?
                            css.containerType !== 'none'
                        : false) ||
                    (css.backdropFilter
                        ?
                            css.backdropFilter !== 'none'
                        : false) ||
                    (css.filter ? css.filter !== 'none' : false) ||
                    css.willChange.search('transform') > -1 ||
                    css.willChange.search('translate') > -1 ||
                    ['paint', 'layout', 'strict', 'content'].some((value) => (css.contain || '').includes(value));
        }
        if (onTopLayer && overTransforms && containingBlock) {
            const rect = containingBlock.getBoundingClientRect();
            const { marginInlineStart = '0', marginBlockStart = '0' } = css;
            diffCoords.x = rect.x + parseFloat(marginInlineStart);
            diffCoords.y = rect.y + parseFloat(marginBlockStart);
        }
        if (onTopLayer && topLayerIsFloating) {
            return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: diffCoords,
            };
        }
        if (onTopLayer) {
            return {
                x,
                y,
                data: diffCoords,
            };
        }
        return {
            x: x - diffCoords.x,
            y: y - diffCoords.y,
            data: diffCoords,
        };
    },
});

let PopupMenuItemSplit = class PopupMenuItemSplit extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  cursor: pointer;
  color: var(--color);
  fill: var(--color);
}
:host vi-button {
  position: relative;
  flex: 1 0 auto;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
  padding: 0;
  text-align: left;
  white-space: nowrap;
}
:host vi-button > * {
  display: inline-block;
  vertical-align: top;
}
:host vi-button span {
  padding: 0 var(--theme-h5) !important;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
}
:host vi-icon {
  position: relative;
  display: inline-block;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
}
:host vi-icon#icon:before {
  content: " ";
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}
:host(:not([icon-space])) .icon-space {
  display: none !important;
}

.icon-space {
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}

:host {
  display: flex;
  flex-direction: row;
}
:host #split {
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  border-left: 1px solid var(--theme-light-border);
}
:host(:not([icon-space])) .icon-space {
  display: none !important;
}

.icon-space {
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}</style>

<vi-button inverse$="[[!checked]]">
    <vi-icon id="icon" source="[[icon]]"></vi-icon>
    <div class="icon-space"></div>
    <span class="flex">[[label]]</span>
</vi-button>
<vi-popup open-on-hover hidden$="[[!hasChildren]]" placement="right-start">
    <vi-button id="split" class="flex" slot="header" icon="Forward" on-tap="_splitTap" inverse>
        <vi-icon source="Forward"></vi-icon>
    </vi-button>
    <div>
        <slot id="subItems" on-slotchange="_popupMenuIconSpaceHandler"></slot>
    </div>
</vi-popup>`; }
    constructor(label, icon, _action) {
        super();
        this.label = label;
        this.icon = icon;
        this._action = _action;
    }
    connectedCallback() {
        super.connectedCallback();
        const subItems = this.$.subItems;
        this._observer = new FlattenedNodesObserver(this.$.subItems, info => {
            this._setHasChildren(subItems.assignedNodes({ flatten: true }).length > 0);
        });
    }
    disconnectedCallback() {
        this._observer.disconnect();
        super.disconnectedCallback();
    }
    _popupMenuIconSpaceHandler(e) {
        const elements = e.target.assignedElements();
        const iconSpace = elements.some(e => e.icon && exists(e.icon));
        elements.forEach(e => e.iconSpace = iconSpace && (!e.icon || !exists(e.icon)));
    }
    _onTap(e) {
        if (this._action) {
            this._action();
            Popup.closeAll();
            e.stopPropagation();
            e.preventDefault();
        }
    }
    _splitTap(e) {
        e.stopPropagation();
    }
};
PopupMenuItemSplit = __decorate([
    WebComponent.register({
        properties: {
            label: String,
            icon: String,
            iconSpace: {
                type: Boolean,
                reflectToAttribute: true
            },
            checked: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            hasChildren: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
                readOnly: true
            }
        },
        listeners: {
            "tap": "_onTap"
        }
    })
], PopupMenuItemSplit);

let PopupMenuItem = class PopupMenuItem extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  cursor: pointer;
  color: var(--color);
  fill: var(--color);
}
:host vi-button {
  position: relative;
  flex: 1 0 auto;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
  padding: 0;
  text-align: left;
  white-space: nowrap;
}
:host vi-button > * {
  display: inline-block;
  vertical-align: top;
}
:host vi-button span {
  padding: 0 var(--theme-h5) !important;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
}
:host vi-icon {
  position: relative;
  display: inline-block;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
}
:host vi-icon#icon:before {
  content: " ";
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}
:host(:not([icon-space])) .icon-space {
  display: none !important;
}

.icon-space {
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}</style>

<vi-popup open-on-hover class="flex" id="popup" placement="right-start">
    <vi-button slot="header" inverse$="[[!checked]]" class="layout horizontal" on-tap="_catchTap">
        <vi-icon id="icon" source="[[icon]]"></vi-icon>
        <div class="icon-space"></div>
        <span class="flex">[[label]]</span>
        <vi-icon source="Forward" hidden$="[[!hasChildren]]"></vi-icon>
    </vi-button>
    <div>
        <slot id="subItems" on-slotchange="_popupMenuIconSpaceHandler"></slot>
    </div>
</vi-popup>`; }
    constructor(label, icon, _action) {
        super();
        this.label = label;
        this.icon = icon;
        this._action = _action;
    }
    connectedCallback() {
        super.connectedCallback();
        const subItems = this.$.subItems;
        this._observer = new FlattenedNodesObserver(this.$.subItems, info => {
            this._setHasChildren(subItems.assignedNodes({ flatten: true }).length > 0);
        });
    }
    disconnectedCallback() {
        this._observer.disconnect();
        super.disconnectedCallback();
    }
    _popupMenuIconSpaceHandler(e) {
        const elements = e.target.assignedElements();
        const iconSpace = elements.some(e => e.icon && exists(e.icon));
        elements.forEach(e => e.iconSpace = iconSpace && (!e.icon || !exists(e.icon)));
    }
    _onTap(e) {
        if (this._action) {
            this._action();
            Popup.closeAll();
            e.stopPropagation();
            e.preventDefault();
        }
    }
    _catchTap(e) {
        if (!this.hasChildren)
            return;
        if (this.$.popup.open) {
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
        }
    }
};
PopupMenuItem = __decorate([
    WebComponent.register({
        properties: {
            label: String,
            icon: String,
            iconSpace: {
                type: Boolean,
                reflectToAttribute: true
            },
            checked: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            hasChildren: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
                readOnly: true
            }
        },
        listeners: {
            "tap": "_onTap"
        }
    })
], PopupMenuItem);

var _ConfigurableWebComponent__onContextmenu;
class ConfigurableWebComponent extends WebComponent {
    constructor() {
        super(...arguments);
        _ConfigurableWebComponent__onContextmenu.set(this, void 0);
    }
    async connectedCallback() {
        super.connectedCallback();
        this._addEventListenerToNode(this, "contextmenu", __classPrivateFieldSet(this, _ConfigurableWebComponent__onContextmenu, (e) => {
            if (!e.ctrlKey || e.defaultPrevented)
                return;
            if (e["vi:configure"])
                return;
            const actions = [];
            this.dispatchEvent(new CustomEvent("vi:configure", {
                bubbles: true,
                detail: actions,
                composed: true
            }));
            if (actions.length === 0)
                return;
            const configureItems = [];
            actions.forEach(action => {
                let item;
                if (!action.subActions)
                    item = new PopupMenuItem(action.label, action.icon, action.action);
                else {
                    item = new PopupMenuItemSplit(action.label, action.icon, action.action);
                    action.subActions.forEach(subA => item.appendChild(new PopupMenuItem(subA.label, subA.icon, subA.action)));
                }
                configureItems.push(item);
            });
            e["vi:configure"] = configureItems;
        }, "f"));
    }
    disconnectedCallback() {
        this._removeEventListenerFromNode(this, "contextmenu", __classPrivateFieldGet(this, _ConfigurableWebComponent__onContextmenu, "f"));
        super.disconnectedCallback();
    }
}
_ConfigurableWebComponent__onContextmenu = new WeakMap();

const styleElement$3 = document.createElement("dom-module");
styleElement$3.innerHTML = `<template>
    <style>
        .layout.horizontal,
        .layout.horizontal-reverse,
        .layout.vertical,
        .layout.vertical-reverse {
            display: flex;
        }

        .layout.inline {
            display: inline-flex;
        }

        .layout.horizontal {
            flex-direction: row;
        }

        .layout.horizontal-reverse {
            flex-direction: row-reverse;
        }

        .layout.vertical {
            flex-direction: column;
        }

        .layout.vertical-reverse {
            flex-direction: column-reverse;
        }

        .layout.wrap {
            flex-wrap: wrap;
        }

        .layout.wrap-reverse {
            flex-wrap: wrap-reverse;
        }

        .flex {
            flex: 1;
            min-height: 0;
            min-width: 0;
        }

        /* alignment in cross axis */
        .layout.start {
            align-items: flex-start;
        }

        .layout.center,
        .layout.center-center {
            align-items: center;
        }

        .layout.end {
            align-items: flex-end;
        }

        /* alignment in main axis */
        .layout.start-justified {
            justify-content: flex-start;
        }

        .layout.center-justified,
        .layout.center-center {
            justify-content: center;
        }

        .layout.end-justified {
            justify-content: flex-end;
        }

        .layout.around-justified {
            justify-content: space-around;
        }

        .layout.justified {
            justify-content: space-between;
        }

        /* self alignment */
        .self-start {
            align-self: flex-start;
        }

        .self-center {
            align-self: center;
        }

        .self-end {
            align-self: flex-end;
        }

        .self-stretch {
            align-self: stretch;
        }
    </style>
</template>`;
styleElement$3.register("vi-flex-layout-style-module");

const styleElement$2 = document.createElement("dom-module");
styleElement$2.innerHTML = `<template>
    <style>
        .relative {
            position: relative;
        }

        .fit {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        [hidden], :host([hidden]) {
            display: none !important;
        }

        button,
        input,
        optgroup,
        select,
        textarea {
          margin: 0;
                font-family: inherit;
        }

        pre {
                border: none;
                font-size: 1em;
                display: block;
                height: auto;
                box-sizing: border-box;
                margin: 0;
                padding: 0;
                font-family: inherit;
        }

        button {
                border: none;
                outline: none;
        }

        a:focus, a:active, input {
            border: 0;
            outline: 0;
        }

        button::-moz-focus-inner,
        input[type="reset"]::-moz-focus-inner,
        input[type="button"]::-moz-focus-inner,
        input[type="submit"]::-moz-focus-inner,
        select::-moz-focus-inner,
        input[type="file"] > input[type="button"]::-moz-focus-inner {
            border: 0;
            outline: 0;
        }

        :host {
            font-family: var(--theme-font-family);
        }
    </style>
</template>`;
styleElement$2.register("vi-reset-css-style-module");

const styleElement$1 = document.createElement("dom-module");
styleElement$1.innerHTML = `<template>
    <style>
        :host([is-phone]) [hide-phone],
        :host([is-tablet]) [hide-tablet],
        :host([is-desktop]) [hide-desktop] {
            display: none !important;
        }
    </style>
</template>`;
styleElement$1.register("vi-responsive-style-module");

class AppCacheEntry {
    constructor(id) {
        this.id = id;
    }
    isMatch(entry) {
        return entry.id === this.id;
    }
}

class AppCacheEntryPersistentObject extends AppCacheEntry {
    constructor(idOrPo, objectId) {
        super(typeof idOrPo === "string" ? idOrPo : (idOrPo instanceof PersistentObject$1 ? idOrPo.id : null));
        this.objectId = objectId;
        if (idOrPo instanceof PersistentObject$1) {
            this.persistentObject = idOrPo;
            this.objectId = this.persistentObject.objectId;
        }
    }
    get persistentObject() {
        return this._persistentObject;
    }
    set persistentObject(po) {
        if (po === this._persistentObject)
            return;
        this._persistentObject = po;
        this.selectedMasterTab = this.selectedDetailTab = null;
    }
    isMatch(entry) {
        if (!(entry instanceof AppCacheEntryPersistentObject))
            return false;
        if (entry.persistentObject != null && entry.persistentObject === this.persistentObject)
            return true;
        return (super.isMatch(entry) || (entry.persistentObject && this.id === entry.persistentObject.fullTypeName)) && (entry.objectId === this.objectId || String.isNullOrEmpty(entry.objectId) && String.isNullOrEmpty(this.objectId));
    }
}

class AppCacheEntryPersistentObjectFromAction extends AppCacheEntryPersistentObject {
    constructor(po, fromActionId, fromActionIdReturnPath) {
        super(po);
        this.fromActionId = fromActionId;
        this.fromActionIdReturnPath = fromActionIdReturnPath;
    }
    isMatch(entry) {
        if (!(entry instanceof AppCacheEntryPersistentObjectFromAction))
            return false;
        return this.fromActionId === entry.fromActionId || entry.persistentObject === this.persistentObject;
    }
}

class AppCacheEntryQuery extends AppCacheEntry {
    constructor(idOrQuery) {
        super(typeof idOrQuery === "string" ? idOrQuery : null);
        if (idOrQuery instanceof Query$1)
            this.query = idOrQuery;
    }
    isMatch(entry) {
        if (!(entry instanceof AppCacheEntryQuery))
            return false;
        if (entry.query === this.query)
            return true;
        return entry instanceof AppCacheEntryQuery && super.isMatch(entry);
    }
}

class AppColor {
    constructor(_base) {
        this._base = _base;
        this._rgb = this._hexToRgb(_base);
        this._faint = this._calculateVariant(this._rgb, 0.07);
        this._semiFaint = this._calculateVariant(this._rgb, 0.15);
        this._lighter = this._calculateVariant(this._rgb, 0.31);
        this._light = this._calculateVariant(this._rgb, 0.7);
        this._dark = this._calculateVariant(this._rgb, 0.81, true);
        this._darker = this._calculateVariant(this._rgb, 0.52, true);
    }
    get rgb() {
        return `${this._rgb.r}, ${this._rgb.g}, ${this._rgb.b}`;
    }
    get faint() {
        return this._faint;
    }
    get semiFaint() {
        return this._semiFaint;
    }
    get lighter() {
        return this._lighter;
    }
    get light() {
        return this._light;
    }
    get base() {
        return this._base;
    }
    get dark() {
        return this._dark;
    }
    get darker() {
        return this._darker;
    }
    _calculateVariant(rgb, a, dark) {
        const base = dark ? 0 : 255;
        return this._rgbToHex({
            r: Math.round((1 - a) * base + a * rgb.r),
            g: Math.round((1 - a) * base + a * rgb.g),
            b: Math.round((1 - a) * base + a * rgb.b),
        });
    }
    _hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }
    _rgbToHex(rgb) {
        return "#" + rgb.r.toString(16).padLeft(2, "0") + rgb.g.toString(16).padLeft(2, "0") + rgb.b.toString(16).padLeft(2, "0");
    }
}

let Config = class Config extends WebComponent {
};
Config = __decorate([
    WebComponent.register({
        properties: {
            key: {
                type: String,
                reflectToAttribute: true
            },
            value: {
                type: String,
                reflectToAttribute: true
            }
        }
    })
], Config);

var _TemplateConfig_configs, _TemplateConfig_configObserver;
let TemplateConfig = class TemplateConfig extends WebComponent {
    constructor() {
        super();
        _TemplateConfig_configs.set(this, {});
        _TemplateConfig_configObserver.set(this, void 0);
        this.setAttribute("slot", "vi-app-config");
    }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("slot", "vi-app-config");
        this._setHasTemplate(!!(this.__template = this.querySelector("template")));
        __classPrivateFieldSet(this, _TemplateConfig_configs, Array.from(this.querySelectorAll("vi-config")).reduce((configs, config) => {
            configs[config.key] = config.value;
            return configs;
        }, {}), "f");
        __classPrivateFieldSet(this, _TemplateConfig_configObserver, new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                if (mutation.type === "attributes") {
                    const config = mutation.target;
                    this.configs[config.key] = config.value;
                }
            });
        }), "f");
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        __classPrivateFieldGet(this, _TemplateConfig_configObserver, "f").disconnect();
    }
    get configs() {
        return __classPrivateFieldGet(this, _TemplateConfig_configs, "f");
    }
    get template() {
        return this.__template;
    }
    stamp(obj, as = this.as, asModel = this.asModel) {
        if (!this.hasTemplate)
            return document.createDocumentFragment();
        const model = {};
        model[as] = !!asModel ? asModel(obj) : obj;
        const templateClass = templatize(this.__template);
        return new templateClass(model).root;
    }
};
_TemplateConfig_configs = new WeakMap();
_TemplateConfig_configObserver = new WeakMap();
TemplateConfig = __decorate([
    WebComponent.register({
        properties: {
            hasTemplate: {
                type: Boolean,
                readOnly: true
            },
            as: {
                type: String,
                reflectToAttribute: true
            }
        }
    })
], TemplateConfig);

let PersistentObjectAttributeConfig = class PersistentObjectAttributeConfig extends TemplateConfig {
    calculateHeight(attr) {
        if (!this._calculateHeight) {
            if (/^\d+$/.test(this.height)) {
                const height = parseInt(this.height);
                this._calculateHeight = () => height;
            }
            else
                this._calculateHeight = new Function("attr", "return " + this.height);
        }
        const height = this._calculateHeight(attr);
        return typeof height !== "string" ? height : parseInt(height);
    }
    calculateWidth(attr) {
        if (!this._calculateWidth) {
            if (/d+/.test(this.width)) {
                const width = parseInt(this.width);
                this._calculateWidth = () => width;
            }
            else
                this._calculateWidth = new Function("attr", "return " + this.width);
        }
        return Math.max(this._calculateWidth(attr), 1);
    }
};
PersistentObjectAttributeConfig = __decorate([
    WebComponent.register({
        properties: {
            type: String,
            name: String,
            noLabel: Boolean,
            parentId: String,
            parentObjectId: String,
            height: {
                type: String,
                value: "1"
            },
            width: {
                type: String,
                value: "attr.columnSpan"
            }
        }
    })
], PersistentObjectAttributeConfig);

let AppConfig = class AppConfig extends WebComponent {
    constructor() {
        super(...arguments);
        this._persistentObjectConfigs = [];
        this._attributeConfigs = [];
        this._tabConfigs = [];
        this._programUnitConfigs = [];
        this._queryConfigs = [];
        this._queryChartConfigs = [];
    }
    ready() {
        super.ready();
        Array.from(this.children).forEach(element => this._handleNode(element, true));
        this._nodeObserver = new FlattenedNodesObserver(this, this._nodesChanged.bind(this));
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        if (!!this._nodeObserver)
            this._nodeObserver.disconnect();
    }
    _nodesChanged(info) {
        info.addedNodes.forEach(node => this._handleNode(node, true));
        info.removedNodes.forEach(node => this._handleNode(node, false));
    }
    _handleNode(node, added) {
        if (node.nodeType !== Node.ELEMENT_NODE)
            return;
        let arr;
        switch (node.tagName.toUpperCase()) {
            case "VI-PERSISTENT-OBJECT-ATTRIBUTE-CONFIG":
                arr = this._attributeConfigs;
                break;
            case "VI-PERSISTENT-OBJECT-CONFIG":
                arr = this._persistentObjectConfigs;
                break;
            case "VI-PERSISTENT-OBJECT-TAB-CONFIG":
                arr = this._tabConfigs;
                break;
            case "VI-PROGRAM-UNIT-CONFIG":
                arr = this._programUnitConfigs;
                break;
            case "VI-QUERY-CONFIG":
                arr = this._queryConfigs;
                break;
            case "VI-QUERY-CHART-CONFIG":
                arr = this._queryChartConfigs;
                break;
            default:
                return;
        }
        if (added) {
            if (arr.indexOf(node) < 0)
                arr.push(node);
        }
        else
            arr.remove(node);
    }
    getSetting(key, defaultValue) {
        const setting = this.querySelector(`vi-app-setting[key="${key}"]`);
        return setting ? setting.getAttribute("value") : defaultValue;
    }
    getPersistentObjectConfig(persistentObject) {
        return this.service.hooks.getPersistentObjectConfig(persistentObject, this._persistentObjectConfigs);
    }
    getAttributeConfig(attribute) {
        let config = this.service.hooks.getAttributeConfig(attribute, this._attributeConfigs);
        if (!config) {
            if (!this._defaultAttributeConfig)
                this._defaultAttributeConfig = this.appendChild(new PersistentObjectAttributeConfig());
            config = this._defaultAttributeConfig;
        }
        return config;
    }
    getTabConfig(tab) {
        return this.service.hooks.getTabConfig(tab, this._tabConfigs);
    }
    getProgramUnitConfig(name) {
        return this.service.hooks.getProgramUnitConfig(name, this._programUnitConfigs);
    }
    getQueryConfig(query) {
        return this.service.hooks.getQueryConfig(query, this._queryConfigs);
    }
    getQueryChartConfig(type) {
        return this.service.hooks.getQueryChartConfig(type, this._queryChartConfigs);
    }
    _getConfigs(type) {
        return [].concat(...Array.from(this.children).filter(c => c.tagName !== "TEMPLATE").map(element => {
            if (element.tagName === "SLOT") {
                const slot = element;
                return Array.from(slot.assignedNodes({ flatten: true })).filter(c => c.tagName !== "TEMPLATE");
            }
            return [element];
        })).filter(child => child instanceof type).map(child => child);
    }
};
AppConfig = __decorate([
    WebComponent.register()
], AppConfig);

let AppSetting = class AppSetting extends WebComponent {
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("slot", "vi-app-config");
    }
};
AppSetting = __decorate([
    WebComponent.register({
        properties: {
            key: String,
            value: String
        }
    })
], AppSetting);

let PersistentObjectConfig = class PersistentObjectConfig extends TemplateConfig {
};
PersistentObjectConfig = __decorate([
    WebComponent.register({
        properties: {
            id: {
                type: String,
                reflectToAttribute: true
            },
            type: {
                type: String,
                reflectToAttribute: true
            },
            objectId: {
                type: String,
                reflectToAttribute: true
            }
        }
    })
], PersistentObjectConfig);

let PersistentObjectTabConfig = class PersistentObjectTabConfig extends TemplateConfig {
};
PersistentObjectTabConfig = __decorate([
    WebComponent.register({
        properties: {
            id: String,
            name: String,
            type: String,
            objectId: String,
            hideActionBar: {
                type: Boolean,
                reflectToAttribute: true
            }
        }
    })
], PersistentObjectTabConfig);

let ProgramUnitConfig = class ProgramUnitConfig extends TemplateConfig {
};
ProgramUnitConfig = __decorate([
    WebComponent.register({
        properties: {
            name: String
        }
    })
], ProgramUnitConfig);

let QueryChartConfig = class QueryChartConfig extends TemplateConfig {
};
QueryChartConfig = __decorate([
    WebComponent.register({
        properties: {
            type: String
        }
    })
], QueryChartConfig);

let QueryConfig = class QueryConfig extends TemplateConfig {
};
QueryConfig = __decorate([
    WebComponent.register({
        properties: {
            name: {
                type: String,
                reflectToAttribute: true
            },
            id: {
                type: String,
                reflectToAttribute: true
            },
            type: {
                type: String,
                reflectToAttribute: true
            },
            defaultChart: {
                type: String,
                reflectToAttribute: true
            },
            fileDropAttribute: {
                type: String,
                reflectToAttribute: true
            },
            fileDropAction: {
                type: String,
                reflectToAttribute: true,
                value: "New"
            },
            hideHeader: {
                type: Boolean,
                reflectToAttribute: true
            },
            selectAll: {
                type: Boolean,
                reflectToAttribute: true
            },
            rowHeight: {
                type: Number,
                reflectToAttribute: true
            }
        }
    })
], QueryConfig);

let AppRoute = class AppRoute extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  position: relative;
}
:host ::slotted(*) {
  flex: 1;
  min-width: 0;
}
:host(:not(.active)) {
  display: none !important;
}</style>

<slot></slot>`; }
    constructor(route) {
        super();
        this.route = route;
        this._parameters = {};
    }
    matchesParameters(parameters = {}) {
        return this._parameters && JSON.stringify(this._parameters) === JSON.stringify(parameters);
    }
    async activate(parameters = {}) {
        if (this.active && this.matchesParameters(parameters))
            return;
        this._parameters = parameters;
        if (this.preserveContent && this._hasChildren)
            this.shadowRoot.querySelector("slot").assignedElements().forEach(this._fireActivate.bind(this));
        else {
            this._clearChildren();
            const template = this.querySelector("template");
            if (!template) {
                console.error(`Missing template on route "${this.path}"`);
                return;
            }
            template.setAttribute("slot", "none");
            const templateClass = templatize(template);
            const templateInstance = new templateClass({ app: this.app });
            this.appendChild(templateInstance.root);
            this.shadowRoot.querySelector("slot").assignedElements().forEach(this._fireActivate.bind(this));
            this._hasChildren = true;
        }
        this._setActive(true);
        this._setPath(this.app.path);
        if (this._documentTitle)
            document.title = this._documentTitle;
        this.service.hooks.trackPageView(this.app.path);
    }
    _fireActivate(target) {
        if (target.fire)
            target.fire("app-route-activate", { route: this, parameters: this._parameters }, { bubbles: true });
    }
    _clearChildren() {
        if (!this._hasChildren)
            return;
        this.shadowRoot.querySelector("slot").assignedElements().forEach(c => this.removeChild(c));
        this._hasChildren = false;
    }
    deactivate(nextRoute) {
        const component = this.shadowRoot.querySelector("slot").assignedElements()[0];
        return new Promise(resolve => {
            const deactivate = { route: this, cancel: false };
            ServiceBus.send(this, "app-route:deactivate", deactivate);
            if (deactivate.cancel)
                resolve(false);
            this.deactivator = resolve;
            if (!component || !component.fire || !component.fire("app-route-deactivate", null, { bubbles: false, cancelable: true }).defaultPrevented)
                resolve(true);
        }).then(result => {
            if (result && (!this.preserveContent || nextRoute !== this))
                this._setActive(false);
            return result;
        });
    }
    get parameters() {
        return this._parameters;
    }
    _activeChanged() {
        this.classList.toggle("active", this.active);
        if (this.activate)
            this.fire("app-route-activated", { route: this, parameters: this._parameters }, { bubbles: true });
        else
            this.fire("app-route-deactivated", { route: this }, { bubbles: true });
    }
    _titleChanged(e) {
        const { title } = e.detail;
        this._documentTitle = title;
        if (!this.active || e.defaultPrevented || e.target.parentNode !== this)
            return;
        document.title = this._documentTitle;
        e.stopPropagation();
    }
};
AppRoute = __decorate([
    WebComponent.register({
        properties: {
            route: {
                type: String,
                reflectToAttribute: true
            },
            routeAlt: {
                type: String,
                reflectToAttribute: true
            },
            active: {
                type: Boolean,
                readOnly: true,
                observer: "_activeChanged"
            },
            path: {
                type: String,
                readOnly: true
            },
            allowSignedOut: Boolean,
            preserveContent: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        listeners: {
            "title-changed": "_titleChanged"
        }
    })
], AppRoute);

let Alert = class Alert extends WebComponent {
    static get template() { return html$3 `<style>:host {
  position: fixed;
  z-index: 5000;
  bottom: 10px;
  right: 10px;
  width: 300px;
}
:host article {
  display: block;
  margin-top: 10px;
  position: relative;
  right: -300px;
  opacity: 0;
  padding: var(--theme-h3, 22px);
  color: white;
  box-shadow: 0 0 6px 1px rgba(0, 0, 0, 0.25);
}
:host article.log-error {
  background-color: var(--theme-color-error, #a80511);
}
:host article.log-warning {
  background-color: var(--theme-color-warning, #e5a300);
}
:host article.log-notice {
  background-color: var(--theme-color-notice, #48545e);
}
:host article.log-ok {
  background-color: var(--theme-color-ok, #339f7b);
}</style>`; }
    async log(message, type, wait) {
        const log = document.createElement("article");
        log.className = `log-${type.toLowerCase()}`;
        log.innerText = message;
        this.shadowRoot.appendChild(log);
        await log.animate([
            { right: "-300px", opacity: 0 },
            { right: 0, opacity: 1 },
        ], {
            duration: 500,
            fill: "forwards",
            easing: "cubic-bezier(0.175, 0.885, 0.320, 1.275)"
        }).finished;
        await this.sleep(wait);
        await log.animate([
            { right: 0, opacity: 1 },
            { right: "-300px", opacity: 0 },
        ], {
            duration: 250,
            fill: "forwards",
            easing: "cubic-bezier(0.600, -0.280, 0.735, 0.045)"
        }).finished;
        this.shadowRoot.removeChild(log);
    }
};
Alert = __decorate([
    WebComponent.register()
], Alert);

let Error$1 = class Error extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  color: var(--color-error);
  fill: var(--color-error);
}
:host h1, :host h2 {
  font-weight: normal;
  text-align: center;
  padding: var(--theme-h5) var(--theme-h3);
  margin: 0;
}
:host h1 {
  font-size: 20px;
}
:host h1:empty {
  display: none;
}
:host h2 {
  font-size: 14px;
}
:host vi-icon {
  --vi-icon-width: var(--theme-h1);
  --vi-icon-height: var(--theme-h1);
  margin-bottom: var(--theme-h4);
}</style>

<div>
    <vi-icon source="[[icon]]"></vi-icon>
    <h1>[[title]]</h1>
    <h2>[[message]]</h2>
</div>`; }
};
Error$1 = __decorate([
    WebComponent.register({
        properties: {
            icon: {
                type: String,
                value: "Notification_Error"
            },
            title: String,
            message: String
        }
    })
], Error$1);

let AppRoutePresenter = class AppRoutePresenter extends WebComponent {
    constructor() {
        super(...arguments);
        this._routeMap = {};
        this._routeUpdater = Promise.resolve();
    }
    static get template() { return html$3 `<style>:host vi-error {
  margin: calc(var(--theme-h1) * 2) 0;
}</style>

<slot id="routes"></slot>
<dom-if if="[[notFound]]">
    <template>
        <vi-error class="flex" message="[[translateMessage('NotFound', app.service.isSignedIn)]]"></vi-error>
    </template>
</dom-if>`; }
    connectedCallback() {
        super.connectedCallback();
        microTask.run(() => this.fire("app-route-presenter:connected", { presenter: this }));
        this._routesObserver = new FlattenedNodesObserver(this.$.routes, this._routesChanged.bind(this));
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._routesObserver.disconnect();
        if (this._pathListener) {
            this._pathListener();
            this._pathListener = null;
        }
    }
    _routesChanged(info) {
        info.addedNodes.filter(node => node instanceof AppRoute).forEach((appRoute) => {
            this._addRoute(appRoute, appRoute.route);
            if (appRoute.routeAlt)
                this._addRoute(appRoute, appRoute.routeAlt);
        });
        if (this._pathListener)
            this._pathListener();
        this._pathListener = ServiceBus.subscribe("path-changed", (sender, message, details) => {
            if (sender === this)
                return;
            const oldPath = this._path;
            this._pathChanged(this._path = details.path, oldPath);
        }, true);
    }
    _addRoute(appRoute, route) {
        route = AppBase.removeRootPath(route);
        if (this._routeMap[route])
            return;
        this._routeMap[route] = appRoute;
        Path.map(Path.routes.rootPath + route).to(() => {
            ServiceBus.send(this, "path-changed", { path: AppBase.removeRootPath(Path.routes.current) });
        });
    }
    async _pathChanged(path, oldPath) {
        await this.app.initialize;
        this._routeUpdater = this._routeUpdater.then(async () => {
            const initial = this.service["_initial"];
            if (initial != null)
                await this.service.hooks.onInitial(initial);
            if (path !== this._path)
                return;
            const mappedPathRoute = path != null ? Path.match(Path.routes.rootPath + path, true) : null;
            const newRoute = mappedPathRoute ? this._routeMap[AppBase.removeRootPath(mappedPathRoute.path)] : null;
            if (!this.service.isSignedIn && !newRoute?.allowSignedOut) {
                this.app.redirectToSignIn();
                return;
            }
            if (this.currentRoute) {
                if (this.currentRoute === newRoute && this.currentRoute.matchesParameters(mappedPathRoute.params))
                    return;
                if (!await this.currentRoute.deactivate(newRoute))
                    return;
            }
            Array.from(this.shadowRoot.querySelectorAll("[dialog]")).forEach((dialog) => dialog.close());
            const redirect = await this.app.service.hooks.onAppRouteChanging(newRoute, this.currentRoute);
            if (redirect) {
                this._setCurrentRoute(null);
                microTask.run(() => this.app.changePath(redirect));
                return;
            }
            if (!!newRoute)
                await newRoute.activate(mappedPathRoute.params);
            this._setCurrentRoute(newRoute);
            this.notFound = !!path && !this.currentRoute;
        });
    }
};
AppRoutePresenter = __decorate([
    WebComponent.register({
        properties: {
            currentRoute: {
                type: Object,
                notify: true,
                readOnly: true
            },
            notFound: {
                type: Boolean,
                value: false,
                readOnly: true
            }
        }
    })
], AppRoutePresenter);

let PopupMenuItemSeparator = class PopupMenuItemSeparator extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  border-top: 1px solid #ddd;
}</style>

<slot></slot>`; }
};
PopupMenuItemSeparator = __decorate([
    WebComponent.register()
], PopupMenuItemSeparator);

let PopupMenuItemWithActions = class PopupMenuItemWithActions extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  cursor: pointer;
  color: var(--color);
  fill: var(--color);
}
:host > div {
  position: relative;
  z-index: 0;
  flex: 1 0 auto;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
  padding: 0;
  text-align: left;
  white-space: nowrap;
}
:host > div > * {
  display: inline-block;
  vertical-align: top;
}
:host > div span {
  flex: 1 0 auto;
  padding: 0 var(--theme-h5) !important;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
}
:host(:not([disabled]):hover) > div::before {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  content: " ";
  background-color: var(--color);
  opacity: 0.1;
}
:host .actions {
  display: flex;
  flex-direction: row;
  padding-left: var(--theme-h5);
}
:host .actions ::slotted(*) {
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-height, var(--theme-h1));
  line-height: var(--vi-popup-menu-item-height, var(--theme-h1));
}
:host vi-icon {
  position: relative;
  display: inline-block;
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
}
:host vi-icon#icon::before {
  content: " ";
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}
:host(:not([icon-space])) .icon-space {
  display: none !important;
}

.icon-space {
  height: var(--vi-popup-menu-item-height, var(--theme-h1));
  width: var(--vi-popup-menu-item-icon-width, var(--theme-h2));
  background-color: rgba(0, 0, 0, 0.04);
}</style>

<div inverse class="layout horizontal">
    <paper-ripple></paper-ripple>
    <vi-icon id="icon" source="[[icon]]"></vi-icon>
    <div class="icon-space"></div>
    <span class="flex">[[label]]</span>
    <div class="actions" on-tap="_actionsTap" on-down="_catch">
        <slot name="button" on-slotchange="_popupMenuIconSpaceHandler"></slot>
    </div>
</div>`; }
    constructor(label, icon, _action) {
        super();
        this.label = label;
        this.icon = icon;
        this._action = _action;
    }
    _popupMenuIconSpaceHandler(e) {
        const elements = e.target.assignedElements();
        const iconSpace = elements.some(e => e.icon && exists(e.icon));
        elements.forEach(e => e.iconSpace = iconSpace && (!e.icon || !exists(e.icon)));
    }
    _onTap(e) {
        if (this._action) {
            this._action();
            Popup.closeAll();
            e.preventDefault();
            e.stopPropagation();
        }
    }
    _actionsTap(e) {
        Popup.closeAll();
        e.stopPropagation();
    }
    _catch(e) {
        e.stopPropagation();
        e.preventDefault();
    }
};
PopupMenuItemWithActions = __decorate([
    WebComponent.register({
        properties: {
            label: String,
            icon: String,
            iconSpace: {
                type: Boolean,
                reflectToAttribute: true
            },
        },
        listeners: {
            "tap": "_onTap"
        }
    })
], PopupMenuItemWithActions);

var _PopupMenu_contextHost, _PopupMenu_openContextEventListener;
let PopupMenu = class PopupMenu extends WebComponent {
    constructor() {
        super(...arguments);
        _PopupMenu_contextHost.set(this, void 0);
        _PopupMenu_openContextEventListener.set(this, void 0);
    }
    static get template() { return html$3 `<style>:host #popup {
  line-height: var(--theme-h1);
}
:host #popup #items {
  background-color: white;
  padding: 1px;
}
:host([context-menu-only]) #popup {
  position: fixed;
  z-index: 1000000;
}
:host([context-menu-only]) #popup #contextHeader {
  visibility: hidden;
}</style>

<vi-popup open-on-hover="{{openOnHover}}" id="popup" disabled="[[disabled]]" open="{{open}}" placement="[[placement]]" auto-width="[[autoWidth]]">
    <dom-if if="[[!contextMenuOnly]]">
        <template>
            <slot name="header" slot="header"></slot>
        </template>
    </dom-if>
    <div>
        <slot id="items" on-slotchange="_popupMenuIconSpaceHandler"></slot>
    </div>
</vi-popup>`; }
    popup() {
        return this.$.popup.popup();
    }
    _hookContextMenu(isConnected, contextMenu) {
        if (isConnected && contextMenu) {
            __classPrivateFieldSet(this, _PopupMenu_contextHost, this.getRootNode().host, "f");
            __classPrivateFieldGet(this, _PopupMenu_contextHost, "f").addEventListener("contextmenu", () => __classPrivateFieldSet(this, _PopupMenu_openContextEventListener, this._openContext.bind(this), "f"));
        }
        else if (__classPrivateFieldGet(this, _PopupMenu_contextHost, "f")) {
            __classPrivateFieldGet(this, _PopupMenu_contextHost, "f").removeEventListener("contextmenu", __classPrivateFieldGet(this, _PopupMenu_openContextEventListener, "f"));
            __classPrivateFieldSet(this, _PopupMenu_contextHost, __classPrivateFieldSet(this, _PopupMenu_openContextEventListener, undefined, "f"), "f");
        }
    }
    _openContext(e) {
        if (!this.contextMenuOnly)
            return true;
        if (e.button === 2 && !!this.shiftKey === !!e.shiftKey && !!this.ctrlKey === !!e.ctrlKey) {
            const popup = this.$.popup;
            popup.style.left = e.pageX + "px";
            popup.style.top = e.pageY + "px";
            if (!popup.open)
                popup.popup();
            else
                popup.close();
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
    }
    _popupMenuIconSpaceHandler(e) {
        const elements = e.target.assignedElements();
        const iconSpace = elements.some(e => e.icon && exists(e.icon));
        elements.forEach(e => e.iconSpace = iconSpace && (!e.icon || !exists(e.icon)));
    }
    _mouseenter() {
        if (this.openOnHover)
            this.popup();
    }
    _mousemove(e) {
        e.stopPropagation();
    }
    _stopTap(e) {
        e.stopPropagation();
    }
};
_PopupMenu_contextHost = new WeakMap();
_PopupMenu_openContextEventListener = new WeakMap();
PopupMenu = __decorate([
    WebComponent.register({
        properties: {
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            },
            openOnHover: {
                type: Boolean,
                reflectToAttribute: true
            },
            contextMenuOnly: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            shiftKey: Boolean,
            ctrlKey: Boolean,
            open: {
                type: Boolean,
                reflectToAttribute: true
            },
            autoWidth: {
                type: Boolean,
                reflectToAttribute: true
            },
            placement: {
                type: String,
                reflectToAttribute: true,
                value: "bottom-start"
            }
        },
        observers: [
            "_hookContextMenu(isConnected, contextMenuOnly)"
        ],
        listeners: {
            "mouseenter": "_mouseenter",
            "mousemove": "_mousemove",
            "tap": "_stopTap"
        }
    })
], PopupMenu);

var _Dialog_result, _Dialog_resolve, _Dialog_translatePosition;
let Dialog = class Dialog extends WebComponent {
    constructor() {
        super(...arguments);
        _Dialog_result.set(this, void 0);
        _Dialog_resolve.set(this, void 0);
        _Dialog_translatePosition.set(this, void 0);
    }
    static dialogTemplate(innerTemplate, options) {
        const outerTemplate = html$3 `<style>dialog {
  border: none;
  background: white;
  box-shadow: rgba(0, 0, 0, 0.24) -2px 5px 12px 0px, rgba(0, 0, 0, 0.12) 0px 0px 12px 0px;
  outline: none;
  padding: 0;
}
dialog > header, dialog > footer {
  background-color: #FAFAFA;
}
dialog > header {
  position: relative;
  flex: 0 0 auto;
  line-height: var(--theme-h1);
  padding: var(--theme-h5) var(--theme-h4);
  height: calc(var(--theme-h1) + var(--theme-h5) * 2);
  border-bottom: 1px solid #EEE;
  box-sizing: border-box;
}
dialog > header h4 {
  margin: 0;
  font-weight: 500;
  font-size: 120%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
dialog > header vi-button.close {
  margin: 0;
  padding: 0 var(--theme-h5);
  fill: #888;
  background: none;
  border: none;
  cursor: pointer;
}
dialog > header vi-button.close:hover {
  fill: #555;
}
dialog > header vi-button.close:active {
  fill: #333;
}
dialog > header vi-button.close:focus {
  outline: none;
}
dialog > footer {
  padding: var(--theme-h4);
  border-top: 1px solid #EEE;
  flex: 0 0 auto;
}
dialog > footer vi-button {
  line-height: var(--theme-h2);
  padding: 0 var(--theme-h4);
}
dialog > footer vi-button:not(:first-of-type) {
  margin-left: var(--theme-h5);
}
dialog > main {
  position: relative;
  z-index: 1;
}
dialog[is-dragging] {
  pointer-events: none;
  user-select: none;
}</style>

<dialog on-close="_onClose" on-cancel="_onCancel" on-click="_onClick" dragging$="[[dragging]]" on-contextmenu="_configureContextMenu"></dialog>`;
        if (options?.omitStyle)
            outerTemplate.content.querySelector("style").remove();
        const dialog = outerTemplate.content.querySelector("dialog");
        dialog.appendChild(innerTemplate.content.cloneNode(true));
        return outerTemplate;
    }
    get dialog() {
        return this.shadowRoot.querySelector("dialog");
    }
    async open() {
        this.dialog.showModal();
        const promise = new Promise(resolve => {
            __classPrivateFieldSet(this, _Dialog_resolve, resolve, "f");
        });
        const anchor = !!this.anchorTag ? this.shadowRoot.querySelector(this.anchorTag) : null;
        if (anchor) {
            const _track = this._track.bind(this);
            addListener(anchor, "track", _track);
            promise.finally(() => {
                removeListener(anchor, "track", _track);
            });
        }
        return promise;
    }
    _track(e) {
        if (e.detail.state === "track" && __classPrivateFieldGet(this, _Dialog_translatePosition, "f") && this.isDragging) {
            const rect = this.dialog.getBoundingClientRect();
            let x = __classPrivateFieldGet(this, _Dialog_translatePosition, "f").x + e.detail.ddx * 2;
            let y = __classPrivateFieldGet(this, _Dialog_translatePosition, "f").y + e.detail.ddy * 2;
            if (x < 0)
                x = Math.max(x, (window.innerWidth - rect.width) * -1);
            else if (x > 0)
                x = Math.min(x, window.innerWidth - rect.width);
            if (y < 0)
                y = Math.max(y, (window.innerHeight - rect.height) * -1);
            else if (y > 0)
                y = Math.min(y, window.innerHeight - rect.height);
            this._translate({ x, y });
        }
        else if (e.detail.state === "start") {
            const path = e.composedPath();
            if (path[0] instanceof HTMLInputElement) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            if (!(e.currentTarget).tagName.startsWith("H")) {
                e.stopPropagation();
                e.preventDefault();
                return;
            }
            this._setIsDragging(true);
            if (!__classPrivateFieldGet(this, _Dialog_translatePosition, "f"))
                this._translate({ x: 0, y: 0 });
        }
        else if (e.detail.state === "end")
            this._setIsDragging(false);
    }
    _translate(position) {
        const { x, y } = __classPrivateFieldSet(this, _Dialog_translatePosition, position, "f");
        this.dialog.style.left = `${x}px`;
        this.dialog.style.top = `${y}px`;
    }
    _esc(e) {
        if (!this.noCancelOnEscKey)
            this.cancel();
    }
    close(result) {
        __classPrivateFieldSet(this, _Dialog_result, result, "f");
        this.dialog.close();
    }
    cancel() {
        this.close();
    }
    _onClose() {
        __classPrivateFieldGet(this, _Dialog_resolve, "f").call(this, __classPrivateFieldGet(this, _Dialog_result, "f"));
    }
    _onCancel(e) {
        if (this.noCancelOnEscKey)
            e.preventDefault();
        __classPrivateFieldSet(this, _Dialog_result, undefined, "f");
    }
    _onClick(e) {
        if (this.noCancelOnOutsideClick)
            return;
        const rect = this.dialog.getBoundingClientRect();
        const isInDialog = (rect.top <= e.clientY && e.clientY <= rect.top + rect.height &&
            rect.left <= e.clientX && e.clientX <= rect.left + rect.width);
        if (!isInDialog)
            this.dialog.close();
    }
    async _configureContextMenu(e) {
        if (!this.service || !this.service.application)
            return;
        const configureItems = e["vi:configure"];
        if (!this.service.application.hasManagement || !configureItems?.length || window.getSelection().toString()) {
            e.stopImmediatePropagation();
            return;
        }
        e.stopPropagation();
        e.preventDefault();
        const popupMenu = new PopupMenu();
        popupMenu.contextMenuOnly = true;
        Array.from(popupMenu.children).forEach(item => popupMenu.removeChild(item));
        configureItems.forEach(item => popupMenu.appendChild(item));
        this.dialog.appendChild(popupMenu);
        try {
            popupMenu.$.popup.style.left = e.pageX + "px";
            popupMenu.$.popup.style.top = e.pageY + "px";
            await popupMenu.popup();
        }
        finally {
            this.dialog.removeChild(popupMenu);
        }
    }
};
_Dialog_result = new WeakMap();
_Dialog_resolve = new WeakMap();
_Dialog_translatePosition = new WeakMap();
Dialog = __decorate([
    WebComponent.register({
        properties: {
            anchorTag: {
                type: String,
                value: "header"
            },
            isDragging: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            noCancelOnOutsideClick: {
                type: Boolean,
                value: true,
            },
            noCancelOnEscKey: Boolean
        },
        keybindings: {
            "esc": "_esc"
        },
        mediaQueryAttributes: true
    })
], Dialog);

let RetryActionDialog = class RetryActionDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host {
  --vi-persistent-object-dialog-base-width-base: 400px;
}
:host header {
  padding: 0 var(--theme-h4);
  line-height: 4em;
}
:host main {
  display: flex;
  flex-direction: column;
  padding: 0;
}
:host main > h4 {
  display: block;
  padding: 0 var(--theme-h4);
  font-weight: normal;
  border-bottom: 1px solid var(--theme-light-border);
  margin: 0;
  line-height: 3em;
}
:host main > vi-persistent-object-tab-presenter {
  flex: 1;
  min-height: 0;
  min-width: 0;
  display: flex;
  flex-direction: column;
  padding: var(--theme-h5) 0;
}
:host main > vi-persistent-object-tab-presenter > vi-persistent-object-tab {
  position: static;
}
:host([is-phone]) main {
  width: 85vw;
}
:host([is-tablet]) main, :host([is-desktop]) main {
  min-width: 400px;
  max-width: var(--vi-persistent-object-dialog-computed-width);
}</style>

<header class="horizontal layout">
    <h4 class="flex">[[retry.title]]</h4>
</header>
<main>
    <h4 hidden$="[[!retry.message]]">[[retry.message]]</h4>
    <vi-notification service-object="[[retry.persistentObject]]"></vi-notification>
    <vi-persistent-object-tab-presenter tab="[[tab]]"></vi-persistent-object-tab-presenter>
</main>
<footer class="horizontal layout end-justified">
    <dom-repeat items="[[retry.options]]" as="option">
        <template>
            <vi-button on-tap="_onSelectOption" inverse="[[op_areNotSame(index, 0)]]" label="[[option]]"></vi-button>
        </template>
    </dom-repeat>
</footer>`); }
    constructor(retry) {
        super();
        this.retry = retry;
        if (typeof retry.message === "undefined")
            retry.message = null;
    }
    connectedCallback() {
        super.connectedCallback();
        this.noCancelOnEscKey = this.retry.cancelOption == null;
    }
    cancel() {
        this.close(this.retry.cancelOption);
    }
    _computeTab(persistentObject, isConnected) {
        if (!persistentObject || !isConnected)
            return null;
        const tab = persistentObject.tabs.find(tab => tab instanceof PersistentObjectAttributeTab);
        tab.columnCount = tab.columnCount > 1 ? tab.columnCount : 1;
        const width = parseInt(getComputedStyle(this).getPropertyValue("--vi-persistent-object-dialog-base-width-base")) * tab.columnCount;
        this.updateStyles({
            "--vi-persistent-object-dialog-computed-width": `${width}px`
        });
        return tab;
    }
    _onSelectOption(e) {
        this.close(e.model.option);
        e.stopPropagation();
    }
    _isFirst(index) {
        return index === 0;
    }
};
RetryActionDialog = __decorate([
    WebComponent.register({
        properties: {
            retry: Object,
            tab: {
                type: Object,
                computed: "_computeTab(retry.persistentObject, isConnected)"
            }
        },
        mediaQueryAttributes: true
    })
], RetryActionDialog);

const findUriLabel = /\[url:([^|]+)\|((https?:\/\/[-\w]+(\.[-\w]+)*(:\d+)?(\/#?!?[^\.\s]*(\.[^\.\s]+)*)?)|(#!\/)?[^\]]+)]/g;
const findUri = /(https?:\/\/[-\w]+(\.[-\w]+)*(:\d+)?(\/#?!?[^\.\s]*(\.[^\.\s]+)*)?)/g;
const findNewLine = /\r?\n|\r/g;
let Notification = class Notification extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  align-items: center;
  height: var(--theme-h1);
  box-sizing: border-box;
  border-bottom-width: 2px;
  border-bottom-style: solid;
}
:host #icon {
  width: var(--theme-h1);
  line-height: var(--theme-h1);
}
:host #icon vi-icon {
  fill: white;
  height: calc(var(--theme-h1) - 2px);
  --vi-icon-width: var(--theme-h3);
  --vi-icon-height: var(--theme-h3);
}
:host #close {
  cursor: pointer;
  background-color: transparent;
  width: var(--theme-h1);
  height: var(--theme-h1);
  line-height: var(--theme-h1);
  fill: white;
}
:host #close:hover {
  background-color: rgba(255, 255, 255, 0.3);
}
:host #textHost {
  color: white;
  overflow: hidden;
}
:host #textHost span {
  display: block;
  line-height: var(--theme-h1);
  height: var(--theme-h1);
  font-size: 14px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
:host #textHost span a {
  color: inherit;
}
:host([type=Error]) {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-error);
  fill: var(--theme-color-error);
}
:host([type=Notice]) {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-notice);
  fill: var(--theme-color-notice);
}
:host([type=OK]) {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-ok);
  fill: var(--theme-color-ok);
}
:host([type=Warning]) {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-warning);
  fill: var(--theme-color-warning);
}</style>

<div id="icon">
    <vi-icon source="[[icon]]"></vi-icon>
</div>
<div id="textHost" class="flex relative" on-tap="_moreInfo">
    <dom-if if="[[!hidden]]">
        <template>
            <vi-size-tracker on-sizechanged="_trackerSizeChanged"></vi-size-tracker>
        </template>
    </dom-if>
    <span id="text" inner-h-t-m-l="[[inlineText]]"></span>
</div>
<vi-button id="close" on-tap="_close" icon="Notification_Close" hidden$="[[noClose]]"></vi-button>

<vi-icon name="Notification_Close">
    <svg viewBox="0 0 32 32">
        <path d="M19.587 16.001l6.096 6.096c0.396 0.396 0.396 1.039 0 1.435l-2.151 2.151c-0.396 0.396-1.038 0.396-1.435 0l-6.097-6.096-6.097 6.096c-0.396 0.396-1.038 0.396-1.434 0l-2.152-2.151c-0.396-0.396-0.396-1.038 0-1.435l6.097-6.096-6.097-6.097c-0.396-0.396-0.396-1.039 0-1.435l2.153-2.151c0.396-0.396 1.038-0.396 1.434 0l6.096 6.097 6.097-6.097c0.396-0.396 1.038-0.396 1.435 0l2.151 2.152c0.396 0.396 0.396 1.038 0 1.435l-6.096 6.096z"></path>
    </svg>
</vi-icon>`; }
    _close() {
        this.serviceObject.setNotification(null);
    }
    _moreInfo(e) {
        if (!this.isOverflowing || e.target instanceof HTMLAnchorElement)
            return;
        this.app.showMessageDialog({
            title: this.app.translateMessage(this.type),
            titleIcon: this._computeIcon(this.type),
            message: this.text.replace(findNewLine, "<br />"),
            rich: true,
            actions: [this.translations.OK]
        });
    }
    _trackerSizeChanged(e) {
        this._setTextOverflow();
        e.stopPropagation();
    }
    _textChanged() {
        this._setTextOverflow();
    }
    _setTextOverflow() {
        if (!this.text)
            return;
        const text = this.$.text;
        if (this.text.contains("<br>"))
            this._setIsOverflowing(true);
        else {
            text.innerHTML = this.text;
            this._setIsOverflowing(text.offsetWidth < text.scrollWidth);
        }
        text.style.cursor = this.isOverflowing ? "pointer" : "auto";
    }
    _computeText(notification) {
        if (!notification)
            return null;
        const html = this._escapeHTML(notification).replace(findUriLabel, "<a href=\"$2\" title=\"\" target=\"_blank\">$1</a>");
        if (notification === html)
            return notification.replace(findUri, "<a href=\"$1\" title=\"\" target=\"_blank\">$1</a>");
        return html;
    }
    _computeInlineText(text) {
        return text && text.replace(/<br>/g, " ");
    }
    _computeHidden(text, duration) {
        return text == null || duration > 0;
    }
    _computeIcon(type) {
        return `Notification_${type}`;
    }
};
Notification = __decorate([
    WebComponent.register({
        properties: {
            serviceObject: Object,
            type: {
                type: Number,
                reflectToAttribute: true,
                computed: "serviceObject.notificationType"
            },
            text: {
                type: String,
                notify: true,
                observer: "_textChanged",
                computed: "_computeText(serviceObject.notification)",
                value: null
            },
            inlineText: {
                type: String,
                computed: "_computeInlineText(text)"
            },
            hidden: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHidden(text, serviceObject.notificationDuration)",
                value: true
            },
            icon: {
                type: String,
                computed: "_computeIcon(type)"
            },
            isOverflowing: {
                type: Boolean,
                readOnly: true
            },
            noClose: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        forwardObservers: [
            "serviceObject.notification",
            "serviceObject.notificationType",
            "serviceObject.notificationDuration"
        ]
    })
], Notification);

let SelectReferenceDialog = class SelectReferenceDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>vi-input-search {
  line-height: var(--theme-h2);
  height: var(--theme-h2);
  border: 1px solid #EAEAEA;
  box-sizing: border-box;
}
vi-input-search::part(input) {
  color: #333;
}
vi-input-search::part(input):focus {
  background-color: white;
}

main vi-query-grid {
  height: 75vh;
}

:host([is-phone]) main vi-query-grid {
  width: 85vw;
}

:host([is-tablet]) main vi-query-grid {
  width: 90vw;
}

:host([is-desktop]) main vi-query-grid {
  width: 75vw;
}</style>

<header class="horizontal layout center">
    <h4 class="flex">[[query.label]]</h4>
    <vi-input-search id="search" value="{{query.textSearch}}" on-search="_search" hidden$="[[initializing]]" autofocus></vi-input-search>
</header>
<main>
    <vi-notification service-object="[[query]]"></vi-notification>
    <vi-query-grid query="[[query]]" on-item-tap="_selectReference" as-lookup initializing="{{initializing}}"></vi-query-grid>
</main>
<footer class="horizontal-reverse layout justified">
    <div class="horizontal layout end-justified">
        <vi-button on-tap="_select" disabled$="[[!canSelect]]" label="[[translateMessage('OK', isConnected)]]"></vi-button>
        <vi-button inverse on-tap="cancel" label="[[translateMessage('Cancel', isConnected)]]"></vi-button>
    </div>
    <vi-button on-tap="_addNew" hidden$="[[!canAddNewReference]]" label="[[translateMessage('NewReference', isConnected)]]"></vi-button>
</footer>`); }
    constructor(query, forceSearch, canAddNewReference = false, keepFilter) {
        super();
        this.query = query;
        this.canAddNewReference = canAddNewReference;
        query["_query-grid-vertical-scroll-offset"] = undefined;
        if (keepFilter)
            return;
        if (!query.filters)
            query.resetFilters();
        if (forceSearch || !!query.textSearch || !query.hasSearched)
            query.search();
    }
    _initializingChanged(value) {
        if (!value)
            this._focusElement(this.$.search);
    }
    _selectedItemsChanged() {
        if (!this.isConnected)
            return;
        this.canSelect = this.query && this.query.selectedItems && this.query.selectedItems.length > 0;
    }
    _invalidateCanSelect(selectedItems = (this.query ? this.query.selectedItems : undefined)) {
        this.canSelect = selectedItems && selectedItems.length > 0;
    }
    _queryPropertyChanged(sender, detail) {
        if (detail.propertyName === "selectedItems")
            this._invalidateCanSelect(detail.newValue);
    }
    _select() {
        if (!this.canSelect)
            return;
        this.close(this.query.selectedItems);
    }
    _addNew() {
        this.close("AddNewReference");
    }
    _search(e, detail) {
        if (!this.query)
            return;
        this.query.textSearch = detail;
        this.query.search();
    }
    _selectReference(e) {
        e.preventDefault();
        const detail = e.detail;
        if (this.query.maxSelectedItems === 1)
            this.close([detail.item]);
        else
            detail.item.isSelected = !detail.item.isSelected;
    }
};
SelectReferenceDialog = __decorate([
    WebComponent.register({
        properties: {
            query: Object,
            canSelect: Boolean,
            canAddNewReference: Boolean,
            initializing: {
                type: Boolean,
                observer: "_initializingChanged"
            }
        },
        forwardObservers: [
            "_selectedItemsChanged(query.selectedItems)"
        ]
    })
], SelectReferenceDialog);

var _StreamingActionDialog_hasScrolled, _StreamingActionDialogBusyIndicator_interval;
let StreamingActionDialog = class StreamingActionDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>header {
  gap: var(--theme-h4);
}

main {
  background-color: var(--vi-streaming-action-dialog-background-color, white);
  color: var(--vi-streaming-action-dialog-foreground-color, #333);
}

vi-scroller, vi-notification {
  width: var(--vi-streaming-action-dialog-width, 600px);
  max-width: 90vw;
}

vi-scroller {
  height: var(--vi-streaming-action-dialog-height, 500px);
  max-height: 90vh;
}

.content {
  padding: var(--theme-h4);
}

vi-marked p {
  margin-block-start: 1em;
  margin-block-end: 1em;
}
vi-marked p:first-of-type {
  margin-block-start: 0;
}
vi-marked p:last-of-type {
  margin-block-end: 0;
}</style>

<header class="horizontal layout">
    <vi-icon source="[[icon]]" hidden$="[[!icon]]"></vi-icon>
    <h4 class="flex">[[title]]</h4>
    <vi-button class="close" on-tap="cancel" icon="Remove"></vi-button>
</header>
<main>
    <vi-notification service-object="[[notificationObject]]"></vi-notification>
    <vi-scroller no-horizontal id="scroller">
        <div class="content">
            <vi-marked markdown="[[content]]"></vi-marked>
            <dom-if if="[[isBusy]]">
                <template>
                    <vi-streaming-action-dialog-busy-indicator></vi-streaming-action-dialog-busy-indicator>
                </template>
            </dom-if>
        </div>
    </vi-scroller>
</main>`); }
    constructor(_actionDefinition, _abort) {
        super();
        this._actionDefinition = _actionDefinition;
        this._abort = _abort;
        _StreamingActionDialog_hasScrolled.set(this, false);
        this._setIcon(_actionDefinition.icon);
        this._setTitle(_actionDefinition.displayName);
    }
    appendMessage(message) {
        const data = JSON.parse(message);
        if (data.type === "dialog") {
            const details = data.value;
            if (details.title)
                this._setTitle(details.title);
            if (details.backgroundColor)
                this.style.setProperty("--vi-streaming-action-dialog-background-color", details.backgroundColor);
            if (details.foregroundColor)
                this.style.setProperty("--vi-streaming-action-dialog-foreground-color", details.foregroundColor);
            if (details.width)
                this.style.setProperty("--vi-streaming-action-dialog-width", details.width);
            if (details.height)
                this.style.setProperty("--vi-streaming-action-dialog-height", details.height);
            if (details.notification) {
                const svcObject = new ServiceObjectWithActions(this.service);
                svcObject.setNotification(details.notification, details.notificationType);
                this._setNotificationObject(svcObject);
            }
        }
        else if (data.type === "message")
            this._setContent(this.content + data.value + "\n");
        microTask.run(() => {
            const scroller = this.$.scroller;
            if (scroller.atBottom || !__classPrivateFieldGet(this, _StreamingActionDialog_hasScrolled, "f")) {
                scroller.scrollToBottom();
                if (!__classPrivateFieldGet(this, _StreamingActionDialog_hasScrolled, "f") && scroller.atBottom)
                    __classPrivateFieldSet(this, _StreamingActionDialog_hasScrolled, true, "f");
            }
        });
    }
    completed() {
        this._setIsBusy(false);
    }
    close(result) {
        this._abort();
        super.close(result);
    }
};
_StreamingActionDialog_hasScrolled = new WeakMap();
StreamingActionDialog = __decorate([
    WebComponent.register({
        properties: {
            content: {
                type: String,
                readOnly: true,
                value: ""
            },
            icon: {
                type: String,
                readOnly: true
            },
            isBusy: {
                type: Boolean,
                readOnly: true,
                value: true
            },
            title: {
                type: String,
                readOnly: true
            },
            notificationObject: {
                type: Object,
                readOnly: true
            }
        }
    })
], StreamingActionDialog);
let StreamingActionDialogBusyIndicator = class StreamingActionDialogBusyIndicator extends WebComponent {
    constructor() {
        super(...arguments);
        _StreamingActionDialogBusyIndicator_interval.set(this, void 0);
    }
    connectedCallback() {
        super.connectedCallback();
        const values = ["◜", "◝", "◞", "◟"];
        __classPrivateFieldSet(this, _StreamingActionDialogBusyIndicator_interval, setInterval(() => {
            const value = values.shift();
            this.innerText = value;
            values.push(value);
        }, 100), "f");
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        clearInterval(__classPrivateFieldGet(this, _StreamingActionDialogBusyIndicator_interval, "f"));
    }
};
_StreamingActionDialogBusyIndicator_interval = new WeakMap();
StreamingActionDialogBusyIndicator = __decorate([
    WebComponent.register()
], StreamingActionDialogBusyIndicator);

var _gaq;
class AppServiceHooksBase extends ServiceHooks {
    get app() {
        return window["app"];
    }
    _initializeGoogleAnalytics() {
        let addScript = false;
        if (typeof (_gaq) === "undefined") {
            _gaq = [];
            addScript = true;
        }
        _gaq.push(["_setAccount", this.app.service.application.analyticsKey]);
        _gaq.push(["_setDomainName", "none"]);
        if (addScript) {
            const ga = document.createElement("script");
            ga.type = "text/javascript";
            ga.async = true;
            ga.src = ("https:" === document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga";
            const script = document.getElementsByTagName("script")[0];
            script.parentNode.insertBefore(ga, script);
        }
    }
    trackEvent(action, option, owner) {
        if (!this.app || !this.app.service || !this.app.service.application || !this.app.service.application.analyticsKey)
            return;
        this._initializeGoogleAnalytics();
        let page = "Unknown";
        let type = "Unknown";
        if (owner != null) {
            if (owner instanceof Query$1) {
                page = "Query";
                type = owner.persistentObject.type;
            }
            else if (owner instanceof PersistentObject$1) {
                page = "PersistentObject";
                type = owner.type;
            }
        }
        _gaq.push(["_setCustomVar", 1, "UserId", this.getTrackUserId(), 1]);
        _gaq.push(["_setCustomVar", 2, "Page", page, 2]);
        _gaq.push(["_setCustomVar", 3, "Type", type, 2]);
        _gaq.push(["_setCustomVar", 4, "Option", option, 2]);
        _gaq.push(["_trackEvent", "Action", action.split(".").pop()]);
    }
    trackPageView(path) {
        if (!this.app || !this.app.service || !this.app.service.application || !this.app.service.application.analyticsKey)
            return;
        path = AppBase.removeRootPath(path);
        if (!path || path.startsWith("from-action"))
            return;
        this._initializeGoogleAnalytics();
        _gaq.push(["_setCustomVar", 1, "UserId", this.getTrackUserId(), 1]);
        _gaq.push(["_trackPageview", path]);
    }
    getTrackUserId() {
        return "";
    }
    getPersistentObjectConfig(persistentObject, persistentObjectConfigs) {
        return persistentObjectConfigs.find(c => (c.id === persistentObject.id || c.type === persistentObject.type || c.type === persistentObject.fullTypeName) && c.objectId === persistentObject.objectId) ||
            persistentObjectConfigs.find(c => !c.objectId && (c.id === persistentObject.id || c.type === persistentObject.type || c.type === persistentObject.fullTypeName));
    }
    getAttributeConfig(attribute, attributeConfigs) {
        return attributeConfigs.find(c => c.parentObjectId === attribute.parent.objectId && c.parentId === attribute.parent.id && (c.name === attribute.name || c.type === attribute.type)) ||
            attributeConfigs.find(c => c.parentId === attribute.parent.id && (c.name === attribute.name || c.type === attribute.type)) ||
            attributeConfigs.find(c => c.name === attribute.name && c.type === attribute.type && !c.parentId) ||
            attributeConfigs.find(c => c.name === attribute.name && !c.parentId && !c.type) ||
            attributeConfigs.find(c => c.type === attribute.type && !c.parentId && !c.name);
    }
    getTabConfig(tab, tabConfigs) {
        return tabConfigs.find(c => c.name === tab.name && (c.type === tab.parent.type || c.type === tab.parent.fullTypeName || c.id === tab.parent.id) && c.objectId === tab.parent.objectId) ||
            tabConfigs.find(c => c.name === tab.name && (c.type === tab.parent.type || c.type === tab.parent.fullTypeName || c.id === tab.parent.id));
    }
    getProgramUnitConfig(name, programUnitConfigs) {
        return programUnitConfigs.find(c => c.name === name);
    }
    getQueryConfig(query, queryConfigs) {
        return queryConfigs.find(c => c.id === query.id || c.name === query.name) ||
            queryConfigs.find(c => c.type === query.persistentObject.type) ||
            queryConfigs.find(c => !c.id && !c.name && !c.type);
    }
    getQueryChartConfig(type, queryChartConfigs) {
        return queryChartConfigs.find(c => c.type === type);
    }
    onConstructApplication(application) {
        const app = super.onConstructApplication(application);
        this.app.sensitive = app.hasSensitive && Boolean.parse(cookie("sensitive")) !== false;
        return app;
    }
    onConstructQuery(service, query, parent, asLookup = false, maxSelectedItems) {
        const newQuery = super.onConstructQuery(service, query, parent, asLookup, maxSelectedItems);
        const queryConfig = this.app.configuration.getQueryConfig(newQuery);
        if (queryConfig) {
            if (queryConfig.defaultChart)
                newQuery.defaultChartName = queryConfig.defaultChart;
            if (queryConfig.selectAll)
                newQuery.selectAll.isAvailable = true;
        }
        return newQuery;
    }
    async onActionConfirmation(action, option) {
        const result = await this.app.showMessageDialog({
            title: action.displayName,
            titleIcon: action.definition.icon,
            message: this.service.getTranslatedMessage(action.definition.confirmation, option >= 0 ? action.options[option] : undefined),
            actions: [action.displayName, this.service.getTranslatedMessage("Cancel")],
            actionTypes: action.name === "Delete" ? ["Danger"] : []
        });
        return result === 0;
    }
    async onAppRouteChanging(newRoute, currentRoute) {
        return Promise.resolve(null);
    }
    async onAction(args) {
        if (args.action === "AddReference") {
            args.isHandled = true;
            const query = args.query.clone(true);
            query.search();
            const result = await this.app.showDialog(new SelectReferenceDialog(query));
            if (result && result.length > 0) {
                args.selectedItems = result;
                return await args.executeServiceRequest();
            }
            else
                return null;
        }
        return super.onAction(args);
    }
    async onStreamingAction(action, messages, abort) {
        const messageIterator = messages();
        const firstMessage = await messageIterator.next();
        const streamingActionDialog = new StreamingActionDialog(this.service.actionDefinitions[action], abort);
        this.app.showDialog(streamingActionDialog);
        streamingActionDialog.appendMessage(firstMessage.value);
        try {
            for await (const message of messageIterator) {
                streamingActionDialog.appendMessage(message);
            }
        }
        finally {
            streamingActionDialog.completed();
        }
    }
    async onBeforeAppInitialized() {
        return Promise.resolve();
    }
    async onAppInitializeFailed(message) {
        if (message === "Session expired")
            return;
        const noInternet = NoInternetMessage.messages[navigator.language.split("-")[0].toLowerCase()] || NoInternetMessage.messages["en"];
        await this.app.showMessageDialog({
            title: message === noInternet.message ? noInternet.title : this.app.label || document.title,
            message: message,
            actions: [noInternet.tryAgain],
            actionTypes: ["Danger"],
            noClose: true
        });
        document.location.reload();
    }
    onRedirectToSignIn(keepUrl) {
    }
    onRedirectToSignOut(keepUrl) {
    }
    onMessageDialog(title, message, rich, ...actions) {
        return this.app.showMessageDialog({ title: title, message: message, rich: rich, actions: actions });
    }
    onShowNotification(notificationOrError, type, duration) {
        if (!duration || !notificationOrError)
            return;
        const notification = typeof notificationOrError === "string" ? notificationOrError : notificationOrError?.["message"];
        this.app.showAlert(notification, type, duration);
    }
    async onSelectReference(query) {
        if (!query.hasSearched)
            query.search();
        return this.app.showDialog(new SelectReferenceDialog(query, false, false, true));
    }
    async onInitial(initial) {
        const initialPath = `SignIn/${initial.type}`;
        const currentPathWithoutRoot = AppBase.removeRootPath(this.app.path);
        if (!currentPathWithoutRoot.startsWith(initialPath)) {
            const returnPath = currentPathWithoutRoot && !currentPathWithoutRoot.startsWith("SignIn") ? currentPathWithoutRoot : "";
            this.app.changePath(`${initialPath}/${encodeURIComponent(returnPath)}`);
        }
    }
    async onSessionExpired() {
        await this.app.service.signOut(true);
        return true;
    }
    onUpdateAvailable() {
        super.onUpdateAvailable();
        this.app.fire("app-update-available", null);
    }
    onNavigate(path, replaceCurrent = false) {
        this.app.changePath(AppBase.removeRootPath(path), replaceCurrent);
    }
    async onRetryAction(retry) {
        if (retry.persistentObject) {
            return this.app.showDialog(new RetryActionDialog(retry));
        }
        return retry.options[await this.app.showMessageDialog({
            title: retry.title,
            message: retry.message,
            actions: retry.options,
            noClose: retry.cancelOption == null,
            defaultAction: retry.defaultOption,
            cancelAction: retry.cancelOption
        })];
    }
}

let ConnectedNotifier = class ConnectedNotifier extends WebComponent {
    connectedCallback() {
        super.connectedCallback();
        if (this._wasAttached && this.oneTime)
            return;
        this._wasAttached = true;
        this.fire("connected", { id: this.id }, {
            node: this,
            bubbles: false
        });
    }
};
ConnectedNotifier = __decorate([
    WebComponent.register({
        properties: {
            oneTime: {
                type: Boolean,
                reflectToAttribute: true
            }
        }
    })
], ConnectedNotifier);

function _getDefaults() {
    return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null,
    };
}
let _defaults = _getDefaults();
function changeDefaults(newDefaults) {
    _defaults = newDefaults;
}
const noopTest = { exec: () => null };
function edit(regex, opt = '') {
    let source = typeof regex === 'string' ? regex : regex.source;
    const obj = {
        replace: (name, val) => {
            let valSource = typeof val === 'string' ? val : val.source;
            valSource = valSource.replace(other.caret, '$1');
            source = source.replace(name, valSource);
            return obj;
        },
        getRegex: () => {
            return new RegExp(source, opt);
        },
    };
    return obj;
}
const other = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
    hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
    htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),
};
const newline = /^(?:[ \t]*(?:\n|$))+/;
const blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
const bullet = /(?:[*+-]|\d{1,9}[.)])/;
const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
const lheading = edit(lheadingCore)
    .replace(/bull/g, bullet)
    .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
    .replace(/blockquote/g, / {0,3}>/)
    .replace(/heading/g, / {0,3}#{1,6}/)
    .replace(/html/g, / {0,3}<[^\n>]+>\n/)
    .replace(/\|table/g, '')
    .getRegex();
const lheadingGfm = edit(lheadingCore)
    .replace(/bull/g, bullet)
    .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
    .replace(/blockquote/g, / {0,3}>/)
    .replace(/heading/g, / {0,3}#{1,6}/)
    .replace(/html/g, / {0,3}<[^\n>]+>\n/)
    .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/)
    .getRegex();
const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
const blockText = /^[^\n]+/;
const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
const def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/)
    .replace('label', _blockLabel)
    .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
    .getRegex();
const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
    .replace(/bull/g, bullet)
    .getRegex();
const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'
    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'
    + '|tr|track|ul';
const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
const html = edit('^ {0,3}(?:'
    + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)'
    + '|comment[^\\n]*(\\n+|$)'
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)'
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)'
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)'
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)'
    + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)'
    + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)'
    + ')', 'i')
    .replace('comment', _comment)
    .replace('tag', _tag)
    .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
    .getRegex();
const paragraph = edit(_paragraph)
    .replace('hr', hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('|lheading', '')
    .replace('|table', '')
    .replace('blockquote', ' {0,3}>')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', _tag)
    .getRegex();
const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
    .replace('paragraph', paragraph)
    .getRegex();
const blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText,
};
const gfmTable = edit('^ *([^\\n ].*)\\n'
    + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)'
    + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)')
    .replace('hr', hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('blockquote', ' {0,3}>')
    .replace('code', '(?: {4}| {0,3}\t)[^\\n]')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', _tag)
    .getRegex();
const blockGfm = {
    ...blockNormal,
    lheading: lheadingGfm,
    table: gfmTable,
    paragraph: edit(_paragraph)
        .replace('hr', hr)
        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
        .replace('|lheading', '')
        .replace('table', gfmTable)
        .replace('blockquote', ' {0,3}>')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', _tag)
        .getRegex(),
};
const blockPedantic = {
    ...blockNormal,
    html: edit('^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)'
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', _comment)
        .replace(/tag/g, '(?!(?:'
        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
        + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph)
        .replace('hr', hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', lheading)
        .replace('|table', '')
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .replace('|tag', '')
        .getRegex(),
};
const escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
const br = /^( {2,}|\\)\n(?!\s*$)/;
const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
const _punctuation = /[\p{P}\p{S}]/u;
const _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
const _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
const punctuation = edit(/^((?![*_])punctSpace)/, 'u')
    .replace(/punctSpace/g, _punctuationOrSpace).getRegex();
const _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
const _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
const blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
const emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
const emStrongLDelim = edit(emStrongLDelimCore, 'u')
    .replace(/punct/g, _punctuation)
    .getRegex();
const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')
    .replace(/punct/g, _punctuationGfmStrongEm)
    .getRegex();
const emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)'
    + '|[^*]+(?=[^*])'
    + '|(?!\\*)punct(\\*+)(?=[\\s]|$)'
    + '|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)'
    + '|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)'
    + '|[\\s](\\*+)(?!\\*)(?=punct)'
    + '|(?!\\*)punct(\\*+)(?!\\*)(?=punct)'
    + '|notPunctSpace(\\*+)(?=notPunctSpace)';
const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')
    .replace(/notPunctSpace/g, _notPunctuationOrSpace)
    .replace(/punctSpace/g, _punctuationOrSpace)
    .replace(/punct/g, _punctuation)
    .getRegex();
const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')
    .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)
    .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)
    .replace(/punct/g, _punctuationGfmStrongEm)
    .getRegex();
const emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)'
    + '|[^_]+(?=[^_])'
    + '|(?!_)punct(_+)(?=[\\s]|$)'
    + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)'
    + '|(?!_)punctSpace(_+)(?=notPunctSpace)'
    + '|[\\s](_+)(?!_)(?=punct)'
    + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu')
    .replace(/notPunctSpace/g, _notPunctuationOrSpace)
    .replace(/punctSpace/g, _punctuationOrSpace)
    .replace(/punct/g, _punctuation)
    .getRegex();
const anyPunctuation = edit(/\\(punct)/, 'gu')
    .replace(/punct/g, _punctuation)
    .getRegex();
const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
    .getRegex();
const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
const tag = edit('^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>'
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>'
    + '|^<\\?[\\s\\S]*?\\?>'
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>'
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>')
    .replace('comment', _inlineComment)
    .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
    .getRegex();
const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
    .replace('label', _inlineLabel)
    .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
    .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
    .getRegex();
const reflink = edit(/^!?\[(label)\]\[(ref)\]/)
    .replace('label', _inlineLabel)
    .replace('ref', _blockLabel)
    .getRegex();
const nolink = edit(/^!?\[(ref)\](?:\[\])?/)
    .replace('ref', _blockLabel)
    .getRegex();
const reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
    .replace('reflink', reflink)
    .replace('nolink', nolink)
    .getRegex();
const inlineNormal = {
    _backpedal: noopTest,
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape: escape$1,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest,
};
const inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', _inlineLabel)
        .getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', _inlineLabel)
        .getRegex(),
};
const inlineGfm = {
    ...inlineNormal,
    emStrongRDelimAst: emStrongRDelimAstGfm,
    emStrongLDelim: emStrongLDelimGfm,
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
        .getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
};
const inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace('{2,}', '*').getRegex(),
    text: edit(inlineGfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex(),
};
const block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic,
};
const inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic,
};
const escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
    if (encode) {
        if (other.escapeTest.test(html)) {
            return html.replace(other.escapeReplace, getEscapeReplacement);
        }
    }
    else {
        if (other.escapeTestNoEncode.test(html)) {
            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
        }
    }
    return html;
}
function cleanUrl(href) {
    try {
        href = encodeURI(href).replace(other.percentDecode, '%');
    }
    catch {
        return null;
    }
    return href;
}
function splitCells(tableRow, count) {
    const row = tableRow.replace(other.findPipe, (match, offset, str) => {
        let escaped = false;
        let curr = offset;
        while (--curr >= 0 && str[curr] === '\\')
            escaped = !escaped;
        if (escaped) {
            return '|';
        }
        else {
            return ' |';
        }
    }), cells = row.split(other.splitPipe);
    let i = 0;
    if (!cells[0].trim()) {
        cells.shift();
    }
    if (cells.length > 0 && !cells.at(-1)?.trim()) {
        cells.pop();
    }
    if (count) {
        if (cells.length > count) {
            cells.splice(count);
        }
        else {
            while (cells.length < count)
                cells.push('');
        }
    }
    for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(other.slashPipe, '|');
    }
    return cells;
}
function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
        return '';
    }
    let suffLen = 0;
    while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && true) {
            suffLen++;
        }
        else {
            break;
        }
    }
    return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
        return -1;
    }
    let level = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
            i++;
        }
        else if (str[i] === b[0]) {
            level++;
        }
        else if (str[i] === b[1]) {
            level--;
            if (level < 0) {
                return i;
            }
        }
    }
    return -1;
}
function outputLink(cap, link, raw, lexer, rules) {
    const href = link.href;
    const title = link.title || null;
    const text = cap[1].replace(rules.other.outputLinkReplace, '$1');
    if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
            type: 'link',
            raw,
            href,
            title,
            text,
            tokens: lexer.inlineTokens(text),
        };
        lexer.state.inLink = false;
        return token;
    }
    return {
        type: 'image',
        raw,
        href,
        title,
        text,
    };
}
function indentCodeCompensation(raw, text, rules) {
    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
    if (matchIndentToCode === null) {
        return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text
        .split('\n')
        .map(node => {
        const matchIndentInNode = node.match(rules.other.beginningSpace);
        if (matchIndentInNode === null) {
            return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
        }
        return node;
    })
        .join('\n');
}
class _Tokenizer {
    options;
    rules;
    lexer;
    constructor(options) {
        this.options = options || _defaults;
    }
    space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
            return {
                type: 'space',
                raw: cap[0],
            };
        }
    }
    code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
            const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');
            return {
                type: 'code',
                raw: cap[0],
                codeBlockStyle: 'indented',
                text: !this.options.pedantic
                    ? rtrim(text, '\n')
                    : text,
            };
        }
    }
    fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
            const raw = cap[0];
            const text = indentCodeCompensation(raw, cap[3] || '', this.rules);
            return {
                type: 'code',
                raw,
                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                text,
            };
        }
    }
    heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
            let text = cap[2].trim();
            if (this.rules.other.endingHash.test(text)) {
                const trimmed = rtrim(text, '#');
                if (this.options.pedantic) {
                    text = trimmed.trim();
                }
                else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
                    text = trimmed.trim();
                }
            }
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[1].length,
                text,
                tokens: this.lexer.inline(text),
            };
        }
    }
    hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
            return {
                type: 'hr',
                raw: rtrim(cap[0], '\n'),
            };
        }
    }
    blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
            let lines = rtrim(cap[0], '\n').split('\n');
            let raw = '';
            let text = '';
            const tokens = [];
            while (lines.length > 0) {
                let inBlockquote = false;
                const currentLines = [];
                let i;
                for (i = 0; i < lines.length; i++) {
                    if (this.rules.other.blockquoteStart.test(lines[i])) {
                        currentLines.push(lines[i]);
                        inBlockquote = true;
                    }
                    else if (!inBlockquote) {
                        currentLines.push(lines[i]);
                    }
                    else {
                        break;
                    }
                }
                lines = lines.slice(i);
                const currentRaw = currentLines.join('\n');
                const currentText = currentRaw
                    .replace(this.rules.other.blockquoteSetextReplace, '\n    $1')
                    .replace(this.rules.other.blockquoteSetextReplace2, '');
                raw = raw ? `${raw}\n${currentRaw}` : currentRaw;
                text = text ? `${text}\n${currentText}` : currentText;
                const top = this.lexer.state.top;
                this.lexer.state.top = true;
                this.lexer.blockTokens(currentText, tokens, true);
                this.lexer.state.top = top;
                if (lines.length === 0) {
                    break;
                }
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'code') {
                    break;
                }
                else if (lastToken?.type === 'blockquote') {
                    const oldToken = lastToken;
                    const newText = oldToken.raw + '\n' + lines.join('\n');
                    const newToken = this.blockquote(newText);
                    tokens[tokens.length - 1] = newToken;
                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
                    break;
                }
                else if (lastToken?.type === 'list') {
                    const oldToken = lastToken;
                    const newText = oldToken.raw + '\n' + lines.join('\n');
                    const newToken = this.list(newText);
                    tokens[tokens.length - 1] = newToken;
                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
                    lines = newText.substring(tokens.at(-1).raw.length).split('\n');
                    continue;
                }
            }
            return {
                type: 'blockquote',
                raw,
                tokens,
                text,
            };
        }
    }
    list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
            let bull = cap[1].trim();
            const isordered = bull.length > 1;
            const list = {
                type: 'list',
                raw: '',
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : '',
                loose: false,
                items: [],
            };
            bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
            if (this.options.pedantic) {
                bull = isordered ? bull : '[*+-]';
            }
            const itemRegex = this.rules.other.listItemRegex(bull);
            let endsWithBlankLine = false;
            while (src) {
                let endEarly = false;
                let raw = '';
                let itemContents = '';
                if (!(cap = itemRegex.exec(src))) {
                    break;
                }
                if (this.rules.block.hr.test(src)) {
                    break;
                }
                raw = cap[0];
                src = src.substring(raw.length);
                let line = cap[2].split('\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));
                let nextLine = src.split('\n', 1)[0];
                let blankLine = !line.trim();
                let indent = 0;
                if (this.options.pedantic) {
                    indent = 2;
                    itemContents = line.trimStart();
                }
                else if (blankLine) {
                    indent = cap[1].length + 1;
                }
                else {
                    indent = cap[2].search(this.rules.other.nonSpaceChar);
                    indent = indent > 4 ? 1 : indent;
                    itemContents = line.slice(indent);
                    indent += cap[1].length;
                }
                if (blankLine && this.rules.other.blankLine.test(nextLine)) {
                    raw += nextLine + '\n';
                    src = src.substring(nextLine.length + 1);
                    endEarly = true;
                }
                if (!endEarly) {
                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
                    const hrRegex = this.rules.other.hrRegex(indent);
                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
                    while (src) {
                        const rawLine = src.split('\n', 1)[0];
                        let nextLineWithoutTabs;
                        nextLine = rawLine;
                        if (this.options.pedantic) {
                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');
                            nextLineWithoutTabs = nextLine;
                        }
                        else {
                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');
                        }
                        if (fencesBeginRegex.test(nextLine)) {
                            break;
                        }
                        if (headingBeginRegex.test(nextLine)) {
                            break;
                        }
                        if (htmlBeginRegex.test(nextLine)) {
                            break;
                        }
                        if (nextBulletRegex.test(nextLine)) {
                            break;
                        }
                        if (hrRegex.test(nextLine)) {
                            break;
                        }
                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
                            itemContents += '\n' + nextLineWithoutTabs.slice(indent);
                        }
                        else {
                            if (blankLine) {
                                break;
                            }
                            if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) {
                                break;
                            }
                            if (fencesBeginRegex.test(line)) {
                                break;
                            }
                            if (headingBeginRegex.test(line)) {
                                break;
                            }
                            if (hrRegex.test(line)) {
                                break;
                            }
                            itemContents += '\n' + nextLine;
                        }
                        if (!blankLine && !nextLine.trim()) {
                            blankLine = true;
                        }
                        raw += rawLine + '\n';
                        src = src.substring(rawLine.length + 1);
                        line = nextLineWithoutTabs.slice(indent);
                    }
                }
                if (!list.loose) {
                    if (endsWithBlankLine) {
                        list.loose = true;
                    }
                    else if (this.rules.other.doubleBlankLine.test(raw)) {
                        endsWithBlankLine = true;
                    }
                }
                let istask = null;
                let ischecked;
                if (this.options.gfm) {
                    istask = this.rules.other.listIsTask.exec(itemContents);
                    if (istask) {
                        ischecked = istask[0] !== '[ ] ';
                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');
                    }
                }
                list.items.push({
                    type: 'list_item',
                    raw,
                    task: !!istask,
                    checked: ischecked,
                    loose: false,
                    text: itemContents,
                    tokens: [],
                });
                list.raw += raw;
            }
            const lastItem = list.items.at(-1);
            if (lastItem) {
                lastItem.raw = lastItem.raw.trimEnd();
                lastItem.text = lastItem.text.trimEnd();
            }
            else {
                return;
            }
            list.raw = list.raw.trimEnd();
            for (let i = 0; i < list.items.length; i++) {
                this.lexer.state.top = false;
                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                if (!list.loose) {
                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');
                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));
                    list.loose = hasMultipleLineBreaks;
                }
            }
            if (list.loose) {
                for (let i = 0; i < list.items.length; i++) {
                    list.items[i].loose = true;
                }
            }
            return list;
        }
    }
    html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
            const token = {
                type: 'html',
                block: true,
                raw: cap[0],
                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                text: cap[0],
            };
            return token;
        }
    }
    def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');
            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
            return {
                type: 'def',
                tag,
                raw: cap[0],
                href,
                title,
            };
        }
    }
    table(src) {
        const cap = this.rules.block.table.exec(src);
        if (!cap) {
            return;
        }
        if (!this.rules.other.tableDelimiter.test(cap[2])) {
            return;
        }
        const headers = splitCells(cap[1]);
        const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');
        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\n') : [];
        const item = {
            type: 'table',
            raw: cap[0],
            header: [],
            align: [],
            rows: [],
        };
        if (headers.length !== aligns.length) {
            return;
        }
        for (const align of aligns) {
            if (this.rules.other.tableAlignRight.test(align)) {
                item.align.push('right');
            }
            else if (this.rules.other.tableAlignCenter.test(align)) {
                item.align.push('center');
            }
            else if (this.rules.other.tableAlignLeft.test(align)) {
                item.align.push('left');
            }
            else {
                item.align.push(null);
            }
        }
        for (let i = 0; i < headers.length; i++) {
            item.header.push({
                text: headers[i],
                tokens: this.lexer.inline(headers[i]),
                header: true,
                align: item.align[i],
            });
        }
        for (const row of rows) {
            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
                return {
                    text: cell,
                    tokens: this.lexer.inline(cell),
                    header: false,
                    align: item.align[i],
                };
            }));
        }
        return item;
    }
    lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                text: cap[1],
                tokens: this.lexer.inline(cap[1]),
            };
        }
    }
    paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
            const text = cap[1].charAt(cap[1].length - 1) === '\n'
                ? cap[1].slice(0, -1)
                : cap[1];
            return {
                type: 'paragraph',
                raw: cap[0],
                text,
                tokens: this.lexer.inline(text),
            };
        }
    }
    text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
            return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                tokens: this.lexer.inline(cap[0]),
            };
        }
    }
    escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
            return {
                type: 'escape',
                raw: cap[0],
                text: cap[1],
            };
        }
    }
    tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
                this.lexer.state.inLink = true;
            }
            else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
                this.lexer.state.inLink = false;
            }
            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
                this.lexer.state.inRawBlock = true;
            }
            else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
                this.lexer.state.inRawBlock = false;
            }
            return {
                type: 'html',
                raw: cap[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: false,
                text: cap[0],
            };
        }
    }
    link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
            const trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
                if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {
                    return;
                }
                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                    return;
                }
            }
            else {
                const lastParenIndex = findClosingBracket(cap[2], '()');
                if (lastParenIndex > -1) {
                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                    const linkLen = start + cap[1].length + lastParenIndex;
                    cap[2] = cap[2].substring(0, lastParenIndex);
                    cap[0] = cap[0].substring(0, linkLen).trim();
                    cap[3] = '';
                }
            }
            let href = cap[2];
            let title = '';
            if (this.options.pedantic) {
                const link = this.rules.other.pedanticHrefTitle.exec(href);
                if (link) {
                    href = link[1];
                    title = link[3];
                }
            }
            else {
                title = cap[3] ? cap[3].slice(1, -1) : '';
            }
            href = href.trim();
            if (this.rules.other.startAngleBracket.test(href)) {
                if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {
                    href = href.slice(1);
                }
                else {
                    href = href.slice(1, -1);
                }
            }
            return outputLink(cap, {
                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,
            }, cap[0], this.lexer, this.rules);
        }
    }
    reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src))
            || (cap = this.rules.inline.nolink.exec(src))) {
            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');
            const link = links[linkString.toLowerCase()];
            if (!link) {
                const text = cap[0].charAt(0);
                return {
                    type: 'text',
                    raw: text,
                    text,
                };
            }
            return outputLink(cap, link, cap[0], this.lexer, this.rules);
        }
    }
    emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrongLDelim.exec(src);
        if (!match)
            return;
        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
            return;
        const nextChar = match[1] || match[2] || '';
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
            const lLength = [...match[0]].length - 1;
            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
            endReg.lastIndex = 0;
            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
            while ((match = endReg.exec(maskedSrc)) != null) {
                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                if (!rDelim)
                    continue;
                rLength = [...rDelim].length;
                if (match[3] || match[4]) {
                    delimTotal += rLength;
                    continue;
                }
                else if (match[5] || match[6]) {
                    if (lLength % 3 && !((lLength + rLength) % 3)) {
                        midDelimTotal += rLength;
                        continue;
                    }
                }
                delimTotal -= rLength;
                if (delimTotal > 0)
                    continue;
                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                const lastCharLength = [...match[0]][0].length;
                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                if (Math.min(lLength, rLength) % 2) {
                    const text = raw.slice(1, -1);
                    return {
                        type: 'em',
                        raw,
                        text,
                        tokens: this.lexer.inlineTokens(text),
                    };
                }
                const text = raw.slice(2, -2);
                return {
                    type: 'strong',
                    raw,
                    text,
                    tokens: this.lexer.inlineTokens(text),
                };
            }
        }
    }
    codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
            let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');
            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text = text.substring(1, text.length - 1);
            }
            return {
                type: 'codespan',
                raw: cap[0],
                text,
            };
        }
    }
    br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
            return {
                type: 'br',
                raw: cap[0],
            };
        }
    }
    del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
            return {
                type: 'del',
                raw: cap[0],
                text: cap[2],
                tokens: this.lexer.inlineTokens(cap[2]),
            };
        }
    }
    autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
            let text, href;
            if (cap[2] === '@') {
                text = cap[1];
                href = 'mailto:' + text;
            }
            else {
                text = cap[1];
                href = text;
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text,
                    },
                ],
            };
        }
    }
    url(src) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
            let text, href;
            if (cap[2] === '@') {
                text = cap[0];
                href = 'mailto:' + text;
            }
            else {
                let prevCapZero;
                do {
                    prevCapZero = cap[0];
                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                } while (prevCapZero !== cap[0]);
                text = cap[0];
                if (cap[1] === 'www.') {
                    href = 'http://' + cap[0];
                }
                else {
                    href = cap[0];
                }
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text,
                    },
                ],
            };
        }
    }
    inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
            const escaped = this.lexer.state.inRawBlock;
            return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                escaped,
            };
        }
    }
}
class _Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || _defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
            inLink: false,
            inRawBlock: false,
            top: true,
        };
        const rules = {
            other,
            block: block.normal,
            inline: inline.normal,
        };
        if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
        }
        else if (this.options.gfm) {
            rules.block = block.gfm;
            if (this.options.breaks) {
                rules.inline = inline.breaks;
            }
            else {
                rules.inline = inline.gfm;
            }
        }
        this.tokenizer.rules = rules;
    }
    static get rules() {
        return {
            block,
            inline,
        };
    }
    static lex(src, options) {
        const lexer = new _Lexer(options);
        return lexer.lex(src);
    }
    static lexInline(src, options) {
        const lexer = new _Lexer(options);
        return lexer.inlineTokens(src);
    }
    lex(src) {
        src = src.replace(other.carriageReturn, '\n');
        this.blockTokens(src, this.tokens);
        for (let i = 0; i < this.inlineQueue.length; i++) {
            const next = this.inlineQueue[i];
            this.inlineTokens(next.src, next.tokens);
        }
        this.inlineQueue = [];
        return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
        if (this.options.pedantic) {
            src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');
        }
        while (src) {
            let token;
            if (this.options.extensions?.block?.some((extTokenizer) => {
                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                }
                return false;
            })) {
                continue;
            }
            if (token = this.tokenizer.space(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (token.raw.length === 1 && lastToken !== undefined) {
                    lastToken.raw += '\n';
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (token = this.tokenizer.code(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.at(-1).src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (token = this.tokenizer.fences(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.heading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.hr(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.blockquote(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.list(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.html(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.def(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.raw;
                    this.inlineQueue.at(-1).src = lastToken.text;
                }
                else if (!this.tokens.links[token.tag]) {
                    this.tokens.links[token.tag] = {
                        href: token.href,
                        title: token.title,
                    };
                }
                continue;
            }
            if (token = this.tokenizer.table(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.lheading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            let cutSrc = src;
            if (this.options.extensions?.startBlock) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startBlock.forEach((getStartIndex) => {
                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                const lastToken = tokens.at(-1);
                if (lastParagraphClipped && lastToken?.type === 'paragraph') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue.at(-1).src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                lastParagraphClipped = cutSrc.length !== src.length;
                src = src.substring(token.raw.length);
                continue;
            }
            if (token = this.tokenizer.text(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue.at(-1).src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                }
                else {
                    throw new Error(errMsg);
                }
            }
        }
        this.state.top = true;
        return tokens;
    }
    inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
    }
    inlineTokens(src, tokens = []) {
        let maskedSrc = src;
        let match = null;
        if (this.tokens.links) {
            const links = Object.keys(this.tokens.links);
            if (links.length > 0) {
                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                        maskedSrc = maskedSrc.slice(0, match.index)
                            + '[' + 'a'.repeat(match[0].length - 2) + ']'
                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                    }
                }
            }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        let keepPrevChar = false;
        let prevChar = '';
        while (src) {
            if (!keepPrevChar) {
                prevChar = '';
            }
            keepPrevChar = false;
            let token;
            if (this.options.extensions?.inline?.some((extTokenizer) => {
                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                }
                return false;
            })) {
                continue;
            }
            if (token = this.tokenizer.escape(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.tag(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.link(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (token.type === 'text' && lastToken?.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.codespan(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.br(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.del(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (token = this.tokenizer.autolink(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            let cutSrc = src;
            if (this.options.extensions?.startInline) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startInline.forEach((getStartIndex) => {
                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (token = this.tokenizer.inlineText(cutSrc)) {
                src = src.substring(token.raw.length);
                if (token.raw.slice(-1) !== '_') {
                    prevChar = token.raw.slice(-1);
                }
                keepPrevChar = true;
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                }
                else {
                    throw new Error(errMsg);
                }
            }
        }
        return tokens;
    }
}
class _Renderer {
    options;
    parser;
    constructor(options) {
        this.options = options || _defaults;
    }
    space(token) {
        return '';
    }
    code({ text, lang, escaped }) {
        const langString = (lang || '').match(other.notSpaceStart)?.[0];
        const code = text.replace(other.endingNewline, '') + '\n';
        if (!langString) {
            return '<pre><code>'
                + (escaped ? code : escape(code, true))
                + '</code></pre>\n';
        }
        return '<pre><code class="language-'
            + escape(langString)
            + '">'
            + (escaped ? code : escape(code, true))
            + '</code></pre>\n';
    }
    blockquote({ tokens }) {
        const body = this.parser.parse(tokens);
        return `<blockquote>\n${body}</blockquote>\n`;
    }
    html({ text }) {
        return text;
    }
    heading({ tokens, depth }) {
        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;
    }
    hr(token) {
        return '<hr>\n';
    }
    list(token) {
        const ordered = token.ordered;
        const start = token.start;
        let body = '';
        for (let j = 0; j < token.items.length; j++) {
            const item = token.items[j];
            body += this.listitem(item);
        }
        const type = ordered ? 'ol' : 'ul';
        const startAttr = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startAttr + '>\n' + body + '</' + type + '>\n';
    }
    listitem(item) {
        let itemBody = '';
        if (item.task) {
            const checkbox = this.checkbox({ checked: !!item.checked });
            if (item.loose) {
                if (item.tokens[0]?.type === 'paragraph') {
                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);
                        item.tokens[0].tokens[0].escaped = true;
                    }
                }
                else {
                    item.tokens.unshift({
                        type: 'text',
                        raw: checkbox + ' ',
                        text: checkbox + ' ',
                        escaped: true,
                    });
                }
            }
            else {
                itemBody += checkbox + ' ';
            }
        }
        itemBody += this.parser.parse(item.tokens, !!item.loose);
        return `<li>${itemBody}</li>\n`;
    }
    checkbox({ checked }) {
        return '<input '
            + (checked ? 'checked="" ' : '')
            + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
        return `<p>${this.parser.parseInline(tokens)}</p>\n`;
    }
    table(token) {
        let header = '';
        let cell = '';
        for (let j = 0; j < token.header.length; j++) {
            cell += this.tablecell(token.header[j]);
        }
        header += this.tablerow({ text: cell });
        let body = '';
        for (let j = 0; j < token.rows.length; j++) {
            const row = token.rows[j];
            cell = '';
            for (let k = 0; k < row.length; k++) {
                cell += this.tablecell(row[k]);
            }
            body += this.tablerow({ text: cell });
        }
        if (body)
            body = `<tbody>${body}</tbody>`;
        return '<table>\n'
            + '<thead>\n'
            + header
            + '</thead>\n'
            + body
            + '</table>\n';
    }
    tablerow({ text }) {
        return `<tr>\n${text}</tr>\n`;
    }
    tablecell(token) {
        const content = this.parser.parseInline(token.tokens);
        const type = token.header ? 'th' : 'td';
        const tag = token.align
            ? `<${type} align="${token.align}">`
            : `<${type}>`;
        return tag + content + `</${type}>\n`;
    }
    strong({ tokens }) {
        return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
        return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
        return `<code>${escape(text, true)}</code>`;
    }
    br(token) {
        return '<br>';
    }
    del({ tokens }) {
        return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
        const text = this.parser.parseInline(tokens);
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
            out += ' title="' + (escape(title)) + '"';
        }
        out += '>' + text + '</a>';
        return out;
    }
    image({ href, title, text }) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return escape(text);
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
            out += ` title="${escape(title)}"`;
        }
        out += '>';
        return out;
    }
    text(token) {
        return 'tokens' in token && token.tokens
            ? this.parser.parseInline(token.tokens)
            : ('escaped' in token && token.escaped ? token.text : escape(token.text));
    }
}
class _TextRenderer {
    strong({ text }) {
        return text;
    }
    em({ text }) {
        return text;
    }
    codespan({ text }) {
        return text;
    }
    del({ text }) {
        return text;
    }
    html({ text }) {
        return text;
    }
    text({ text }) {
        return text;
    }
    link({ text }) {
        return '' + text;
    }
    image({ text }) {
        return '' + text;
    }
    br() {
        return '';
    }
}
class _Parser {
    options;
    renderer;
    textRenderer;
    constructor(options) {
        this.options = options || _defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.renderer.parser = this;
        this.textRenderer = new _TextRenderer();
    }
    static parse(tokens, options) {
        const parser = new _Parser(options);
        return parser.parse(tokens);
    }
    static parseInline(tokens, options) {
        const parser = new _Parser(options);
        return parser.parseInline(tokens);
    }
    parse(tokens, top = true) {
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
            const anyToken = tokens[i];
            if (this.options.extensions?.renderers?.[anyToken.type]) {
                const genericToken = anyToken;
                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            const token = anyToken;
            switch (token.type) {
                case 'space': {
                    out += this.renderer.space(token);
                    continue;
                }
                case 'hr': {
                    out += this.renderer.hr(token);
                    continue;
                }
                case 'heading': {
                    out += this.renderer.heading(token);
                    continue;
                }
                case 'code': {
                    out += this.renderer.code(token);
                    continue;
                }
                case 'table': {
                    out += this.renderer.table(token);
                    continue;
                }
                case 'blockquote': {
                    out += this.renderer.blockquote(token);
                    continue;
                }
                case 'list': {
                    out += this.renderer.list(token);
                    continue;
                }
                case 'html': {
                    out += this.renderer.html(token);
                    continue;
                }
                case 'paragraph': {
                    out += this.renderer.paragraph(token);
                    continue;
                }
                case 'text': {
                    let textToken = token;
                    let body = this.renderer.text(textToken);
                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                        textToken = tokens[++i];
                        body += '\n' + this.renderer.text(textToken);
                    }
                    if (top) {
                        out += this.renderer.paragraph({
                            type: 'paragraph',
                            raw: body,
                            text: body,
                            tokens: [{ type: 'text', raw: body, text: body, escaped: true }],
                        });
                    }
                    else {
                        out += body;
                    }
                    continue;
                }
                default: {
                    const errMsg = 'Token with "' + token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(errMsg);
                        return '';
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        }
        return out;
    }
    parseInline(tokens, renderer = this.renderer) {
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
            const anyToken = tokens[i];
            if (this.options.extensions?.renderers?.[anyToken.type]) {
                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            const token = anyToken;
            switch (token.type) {
                case 'escape': {
                    out += renderer.text(token);
                    break;
                }
                case 'html': {
                    out += renderer.html(token);
                    break;
                }
                case 'link': {
                    out += renderer.link(token);
                    break;
                }
                case 'image': {
                    out += renderer.image(token);
                    break;
                }
                case 'strong': {
                    out += renderer.strong(token);
                    break;
                }
                case 'em': {
                    out += renderer.em(token);
                    break;
                }
                case 'codespan': {
                    out += renderer.codespan(token);
                    break;
                }
                case 'br': {
                    out += renderer.br(token);
                    break;
                }
                case 'del': {
                    out += renderer.del(token);
                    break;
                }
                case 'text': {
                    out += renderer.text(token);
                    break;
                }
                default: {
                    const errMsg = 'Token with "' + token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(errMsg);
                        return '';
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        }
        return out;
    }
}
class _Hooks {
    options;
    block;
    constructor(options) {
        this.options = options || _defaults;
    }
    static passThroughHooks = new Set([
        'preprocess',
        'postprocess',
        'processAllTokens',
    ]);
    preprocess(markdown) {
        return markdown;
    }
    postprocess(html) {
        return html;
    }
    processAllTokens(tokens) {
        return tokens;
    }
    provideLexer() {
        return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    provideParser() {
        return this.block ? _Parser.parse : _Parser.parseInline;
    }
}
let Marked$1 = class Marked {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args) {
        this.use(...args);
    }
    walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens) {
            values = values.concat(callback.call(this, token));
            switch (token.type) {
                case 'table': {
                    const tableToken = token;
                    for (const cell of tableToken.header) {
                        values = values.concat(this.walkTokens(cell.tokens, callback));
                    }
                    for (const row of tableToken.rows) {
                        for (const cell of row) {
                            values = values.concat(this.walkTokens(cell.tokens, callback));
                        }
                    }
                    break;
                }
                case 'list': {
                    const listToken = token;
                    values = values.concat(this.walkTokens(listToken.items, callback));
                    break;
                }
                default: {
                    const genericToken = token;
                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                            const tokens = genericToken[childTokens].flat(Infinity);
                            values = values.concat(this.walkTokens(tokens, callback));
                        });
                    }
                    else if (genericToken.tokens) {
                        values = values.concat(this.walkTokens(genericToken.tokens, callback));
                    }
                }
            }
        }
        return values;
    }
    use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
            const opts = { ...pack };
            opts.async = this.defaults.async || opts.async || false;
            if (pack.extensions) {
                pack.extensions.forEach((ext) => {
                    if (!ext.name) {
                        throw new Error('extension name required');
                    }
                    if ('renderer' in ext) {
                        const prevRenderer = extensions.renderers[ext.name];
                        if (prevRenderer) {
                            extensions.renderers[ext.name] = function (...args) {
                                let ret = ext.renderer.apply(this, args);
                                if (ret === false) {
                                    ret = prevRenderer.apply(this, args);
                                }
                                return ret;
                            };
                        }
                        else {
                            extensions.renderers[ext.name] = ext.renderer;
                        }
                    }
                    if ('tokenizer' in ext) {
                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                            throw new Error("extension level must be 'block' or 'inline'");
                        }
                        const extLevel = extensions[ext.level];
                        if (extLevel) {
                            extLevel.unshift(ext.tokenizer);
                        }
                        else {
                            extensions[ext.level] = [ext.tokenizer];
                        }
                        if (ext.start) {
                            if (ext.level === 'block') {
                                if (extensions.startBlock) {
                                    extensions.startBlock.push(ext.start);
                                }
                                else {
                                    extensions.startBlock = [ext.start];
                                }
                            }
                            else if (ext.level === 'inline') {
                                if (extensions.startInline) {
                                    extensions.startInline.push(ext.start);
                                }
                                else {
                                    extensions.startInline = [ext.start];
                                }
                            }
                        }
                    }
                    if ('childTokens' in ext && ext.childTokens) {
                        extensions.childTokens[ext.name] = ext.childTokens;
                    }
                });
                opts.extensions = extensions;
            }
            if (pack.renderer) {
                const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                for (const prop in pack.renderer) {
                    if (!(prop in renderer)) {
                        throw new Error(`renderer '${prop}' does not exist`);
                    }
                    if (['options', 'parser'].includes(prop)) {
                        continue;
                    }
                    const rendererProp = prop;
                    const rendererFunc = pack.renderer[rendererProp];
                    const prevRenderer = renderer[rendererProp];
                    renderer[rendererProp] = (...args) => {
                        let ret = rendererFunc.apply(renderer, args);
                        if (ret === false) {
                            ret = prevRenderer.apply(renderer, args);
                        }
                        return ret || '';
                    };
                }
                opts.renderer = renderer;
            }
            if (pack.tokenizer) {
                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                for (const prop in pack.tokenizer) {
                    if (!(prop in tokenizer)) {
                        throw new Error(`tokenizer '${prop}' does not exist`);
                    }
                    if (['options', 'rules', 'lexer'].includes(prop)) {
                        continue;
                    }
                    const tokenizerProp = prop;
                    const tokenizerFunc = pack.tokenizer[tokenizerProp];
                    const prevTokenizer = tokenizer[tokenizerProp];
                    tokenizer[tokenizerProp] = (...args) => {
                        let ret = tokenizerFunc.apply(tokenizer, args);
                        if (ret === false) {
                            ret = prevTokenizer.apply(tokenizer, args);
                        }
                        return ret;
                    };
                }
                opts.tokenizer = tokenizer;
            }
            if (pack.hooks) {
                const hooks = this.defaults.hooks || new _Hooks();
                for (const prop in pack.hooks) {
                    if (!(prop in hooks)) {
                        throw new Error(`hook '${prop}' does not exist`);
                    }
                    if (['options', 'block'].includes(prop)) {
                        continue;
                    }
                    const hooksProp = prop;
                    const hooksFunc = pack.hooks[hooksProp];
                    const prevHook = hooks[hooksProp];
                    if (_Hooks.passThroughHooks.has(prop)) {
                        hooks[hooksProp] = (arg) => {
                            if (this.defaults.async) {
                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                                    return prevHook.call(hooks, ret);
                                });
                            }
                            const ret = hooksFunc.call(hooks, arg);
                            return prevHook.call(hooks, ret);
                        };
                    }
                    else {
                        hooks[hooksProp] = (...args) => {
                            let ret = hooksFunc.apply(hooks, args);
                            if (ret === false) {
                                ret = prevHook.apply(hooks, args);
                            }
                            return ret;
                        };
                    }
                }
                opts.hooks = hooks;
            }
            if (pack.walkTokens) {
                const walkTokens = this.defaults.walkTokens;
                const packWalktokens = pack.walkTokens;
                opts.walkTokens = function (token) {
                    let values = [];
                    values.push(packWalktokens.call(this, token));
                    if (walkTokens) {
                        values = values.concat(walkTokens.call(this, token));
                    }
                    return values;
                };
            }
            this.defaults = { ...this.defaults, ...opts };
        });
        return this;
    }
    setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
    }
    lexer(src, options) {
        return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
        return _Parser.parse(tokens, options ?? this.defaults);
    }
    parseMarkdown(blockType) {
        const parse = (src, options) => {
            const origOpt = { ...options };
            const opt = { ...this.defaults, ...origOpt };
            const throwError = this.onError(!!opt.silent, !!opt.async);
            if (this.defaults.async === true && origOpt.async === false) {
                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
            }
            if (typeof src === 'undefined' || src === null) {
                return throwError(new Error('marked(): input parameter is undefined or null'));
            }
            if (typeof src !== 'string') {
                return throwError(new Error('marked(): input parameter is of type '
                    + Object.prototype.toString.call(src) + ', string expected'));
            }
            if (opt.hooks) {
                opt.hooks.options = opt;
                opt.hooks.block = blockType;
            }
            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);
            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);
            if (opt.async) {
                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                    .then(src => lexer(src, opt))
                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)
                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)
                    .then(tokens => parser(tokens, opt))
                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)
                    .catch(throwError);
            }
            try {
                if (opt.hooks) {
                    src = opt.hooks.preprocess(src);
                }
                let tokens = lexer(src, opt);
                if (opt.hooks) {
                    tokens = opt.hooks.processAllTokens(tokens);
                }
                if (opt.walkTokens) {
                    this.walkTokens(tokens, opt.walkTokens);
                }
                let html = parser(tokens, opt);
                if (opt.hooks) {
                    html = opt.hooks.postprocess(html);
                }
                return html;
            }
            catch (e) {
                return throwError(e);
            }
        };
        return parse;
    }
    onError(silent, async) {
        return (e) => {
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';
            if (silent) {
                const msg = '<p>An error occurred:</p><pre>'
                    + escape(e.message + '', true)
                    + '</pre>';
                if (async) {
                    return Promise.resolve(msg);
                }
                return msg;
            }
            if (async) {
                return Promise.reject(e);
            }
            throw e;
        };
    }
};
const markedInstance = new Marked$1();
function marked(src, opt) {
    return markedInstance.parse(src, opt);
}
marked.options =
    marked.setOptions = function (options) {
        markedInstance.setOptions(options);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
    };
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function (...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
};
marked.walkTokens = function (tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;

purify.addHook("afterSanitizeAttributes", function (node) {
    if (node instanceof HTMLAnchorElement && node.getAttribute("href")?.startsWith("http")) {
        node.setAttribute("target", "_blank");
        node.setAttribute("rel", "noopener");
    }
});
purify.addHook('uponSanitizeAttribute', (node, data) => {
    if (node.tagName === "VI-ICON" && data.attrName === 'source')
        data.forceKeepAttr = true;
});
let Marked = class Marked extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
}</style>

<slot></slot>`; }
    async _markdownChanged(markdown, breaks, gfm, addTags, forbidTags) {
        this.innerHTML = getMarkdown(markdown, { breaks, gfm, addTags, forbidTags });
    }
};
Marked = __decorate([
    WebComponent.register({
        properties: {
            addTags: {
                type: String,
                value: null
            },
            forbidTags: {
                type: String,
                value: null
            },
            breaks: {
                type: Boolean,
                value: true
            },
            gfm: {
                type: Boolean,
                value: true
            },
            markdown: String
        },
        observers: [
            "_markdownChanged(markdown, breaks, gfm, addTags, forbidTags)"
        ]
    })
], Marked);
function getMarkdown(markdown, options) {
    const html = marked(markdown, {
        breaks: options?.breaks !== false ? true : false,
        gfm: options?.gfm !== false ? true : false,
        async: false
    });
    const sanitized = purify.sanitize(html, {
        ADD_TAGS: options?.addTags?.split(",") || [],
        FORBID_TAGS: options?.forbidTags?.split(",") || []
    });
    return sanitized;
}

let MessageDialog = class MessageDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host main {
  min-width: 17em;
  max-width: 70vw;
  display: flex;
  flex-direction: row;
}
:host main:not([rich]) {
  padding: var(--theme-h4);
}
:host main:not([rich]) pre {
  flex: 1;
  min-height: 0;
  min-width: 0;
  white-space: pre-wrap;
}
:host main:not([rich]) pre a {
  color: inherit;
}
:host main[rich] vi-marked {
  overflow: auto;
  padding: var(--theme-h4);
}
:host main[rich] vi-marked p {
  margin: 0.5em 0;
}
:host header > vi-icon {
  padding-right: var(--theme-h4);
  height: var(--theme-h1);
  --vi-icon-width: var(--theme-h3);
  --vi-icon-height: var(--theme-h3);
}
:host header > vi-icon[source$=Error] {
  fill: var(--theme-color-error);
}
:host header > vi-icon[source$=Warning] {
  fill: var(--theme-color-warning);
}
:host header > vi-icon[source$=Notice] {
  fill: var(--theme-color-notice);
}
:host header > vi-icon[source$=OK] {
  fill: var(--theme-color-ok);
}</style>

<header class="horizontal layout">
    <vi-icon source="[[options.titleIcon]]" hidden$="[[!hasHeaderIcon]]"></vi-icon>
    <h4 class="flex">[[options.title]]</h4>
    <dom-if if="[[!options.noClose]]">
        <template>
            <vi-button class="close" on-tap="cancel" icon="Remove"></vi-button>
        </template>
    </dom-if>
</header>
<main rich$="[[options.rich]]">
    <dom-if if="[[options.rich]]">
        <template>
            <vi-marked markdown="[[options.message]]"></vi-marked>
        </template>
    </dom-if>
    <dom-if if="[[!options.rich]]">
        <template>
            <pre>[[options.message]]</pre>
        </template>
    </dom-if>
</main>
<footer class="horizontal layout end-justified" id="actions">
    <dom-repeat items="[[options.actions]]" as="action">
        <template>
            <vi-button on-tap="_onSelectAction" type$="[[_actionType(options, index)]]" inverse="[[op_areNotSame(activeAction, index)]]" label="[[action]]"></vi-button>
        </template>
    </dom-repeat>
</footer>`); }
    constructor(options) {
        super();
        this._setOptions(options);
        if (options.defaultAction)
            this._setActiveAction(options.defaultAction);
    }
    connectedCallback() {
        super.connectedCallback();
        this.noCancelOnEscKey = this.noCancelOnOutsideClick = this.options.noClose || this.options.cancelAction == null;
    }
    cancel() {
        if (this.options.cancelAction == null)
            super.cancel();
        else
            super.close(this.options.cancelAction);
    }
    async open() {
        const focus = setInterval(() => {
            const button = this.$.actions.querySelectorAll("vi-button")[this.activeAction];
            if (!button)
                return;
            if (this.app.activeElement !== button)
                this._focusElement(button);
            else
                clearInterval(focus);
        }, 100);
        return super.open();
    }
    _computeHasHeaderIcon(options) {
        return options && typeof options.titleIcon === "string";
    }
    _actionType(options, index) {
        if (!options || !options.actionTypes)
            return undefined;
        return options.actionTypes[index];
    }
    _onSelectAction(e) {
        this.close(e.model.index);
        e.stopPropagation();
    }
    _isFirst(index) {
        return index === 0;
    }
    _activeActionChanged(activeAction) {
        const button = this.$.actions.querySelector(`button:nth-child(${activeAction + 1})`);
        if (!button)
            return;
        this._focusElement(button);
    }
    _keyboardNextAction() {
        this._setActiveAction((this.activeAction + 1) % this.options.actions.length);
    }
    _keyboardPreviousAction() {
        this._setActiveAction((this.activeAction - 1 + this.options.actions.length) % this.options.actions.length);
    }
};
MessageDialog = __decorate([
    WebComponent.register({
        properties: {
            options: {
                type: Object,
                readOnly: true
            },
            activeAction: {
                type: Number,
                readOnly: true,
                value: 0,
                observer: "_activeActionChanged"
            },
            hasHeaderIcon: {
                type: Boolean,
                computed: "_computeHasHeaderIcon(options)"
            }
        },
        keybindings: {
            "tab": "_keyboardNextAction",
            "right": "_keyboardNextAction",
            "left": "_keyboardPreviousAction"
        }
    })
], MessageDialog);

let Sensitive = class Sensitive extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: contents;
  text-overflow: ellipsis;
  overflow: hidden;
}
:host(:not([disabled])[is-app-sensitive]) ::slotted(*) {
  filter: blur(5px);
}</style>

<slot></slot>`; }
};
Sensitive = __decorate([
    WebComponent.register({
        properties: {
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        sensitive: true
    })
], Sensitive);

let SessionPresenter = class SessionPresenter extends WebComponent {
    static get template() { return html$3 `<slot></slot>`; }
    _stamp(session, isConnected) {
        if (!isConnected)
            return;
        const template = this.querySelector("template");
        if (!template) {
            console.error("SessionPresenter expects a template child");
            return;
        }
        if (!this._stampedTemplate) {
            const templateClass = templatize(template);
            this._stampedTemplate = new templateClass({
                "session": session
            });
            this.appendChild(this._stampedTemplate.root);
        }
        else
            this._stampedTemplate.set("session", session);
    }
};
SessionPresenter = __decorate([
    WebComponent.register({
        properties: {
            session: {
                type: Object,
                computed: "service.application.session"
            }
        },
        forwardObservers: [
            "service.application.session"
        ],
        observers: [
            "_stamp(session, isConnected)"
        ]
    })
], SessionPresenter);

Polymer({
  is: 'iron-a11y-keys',
  behaviors: [IronA11yKeysBehavior],
  properties: {
    target: {type: Object, observer: '_targetChanged'},
    keys: {type: String, reflectToAttribute: true, observer: '_keysChanged'}
  },
  attached: function() {
    if (!this.target) {
      this.target = this.parentNode;
    }
  },
  _targetChanged: function(target) {
    this.keyEventTarget = target;
  },
  _keysChanged: function() {
    this.removeOwnKeyBindings();
    this.addOwnKeyBinding(this.keys, '_fireKeysPressed');
  },
  _fireKeysPressed: function(event) {
    this.fire('keys-pressed', event.detail, {});
  }
});

var Utility = {
  distance: function(x1, y1, x2, y2) {
    var xDelta = (x1 - x2);
    var yDelta = (y1 - y2);
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },
  now: window.performance && window.performance.now ?
      window.performance.now.bind(window.performance) :
      Date.now
};
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;
  this.size = Math.max(this.width, this.height);
}
ElementMetrics.prototype = {
  get boundingRect() {
    return this.element.getBoundingClientRect();
  },
  furthestCornerDistanceFrom: function(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);
    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;
  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  dom(this.waveContainer).appendChild(this.wave);
  this.resetInteractionState();
}
Ripple.MAX_RADIUS = 300;
Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },
  get center() {
    return this.element.center;
  },
  get mouseDownElapsed() {
    var elapsed;
    if (!this.mouseDownStart) {
      return 0;
    }
    elapsed = Utility.now() - this.mouseDownStart;
    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }
    return elapsed;
  },
  get mouseUpElapsed() {
    return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
  },
  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },
  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },
  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },
  get initialOpacity() {
    return this.element.initialOpacity;
  },
  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },
  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius =
        Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;
    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));
    return Math.abs(size);
  },
  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }
    return Math.max(
        0,
        this.initialOpacity -
            this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
  },
  get outerOpacity() {
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;
    return Math.max(0, Math.min(outerOpacity, waveOpacity));
  },
  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 &&
        this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },
  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity &&
        this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },
  get isAnimationComplete() {
    return this.mouseUpStart ? this.isOpacityFullyDecayed :
                               this.isRestingAtMaxRadius;
  },
  get translationFraction() {
    return Math.min(
        1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
  },
  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }
    return this.xStart;
  },
  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }
    return this.yStart;
  },
  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },
  resetInteractionState: function() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;
    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;
    this.containerMetrics = new ElementMetrics(this.element);
  },
  draw: function() {
    var scale;
    var dx;
    var dy;
    this.wave.style.opacity = this.opacity;
    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - (this.containerMetrics.width / 2);
    dy = this.yNow - (this.containerMetrics.height / 2);
    this.waveContainer.style.webkitTransform =
        'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform =
        'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },
  downAction: function(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;
    this.resetInteractionState();
    this.mouseDownStart = Utility.now();
    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance =
          Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    } else {
      this.xStart = event ?
          event.detail.x - this.containerMetrics.boundingRect.left :
          this.containerMetrics.width / 2;
      this.yStart = event ?
          event.detail.y - this.containerMetrics.boundingRect.top :
          this.containerMetrics.height / 2;
    }
    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance =
          Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }
    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
        this.xStart, this.yStart);
    this.waveContainer.style.top =
        (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left =
        (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },
  upAction: function(event) {
    if (!this.isMouseDown) {
      return;
    }
    this.mouseUpStart = Utility.now();
  },
  remove: function() {
    dom(dom(this.waveContainer).parentNode).removeChild(this.waveContainer);
  }
};
Polymer({
  _template: html$3`
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
`,
  is: 'paper-ripple',
  behaviors: [IronA11yKeysBehavior],
  properties: {
    initialOpacity: {type: Number, value: 0.25},
    opacityDecayVelocity: {type: Number, value: 0.8},
    recenters: {type: Boolean, value: false},
    center: {type: Boolean, value: false},
    ripples: {
      type: Array,
      value: function() {
        return [];
      }
    },
    animating:
        {type: Boolean, readOnly: true, reflectToAttribute: true, value: false},
    holdDown: {type: Boolean, value: false, observer: '_holdDownChanged'},
    noink: {type: Boolean, value: false},
    _animating: {type: Boolean},
    _boundAnimate: {
      type: Function,
      value: function() {
        return this.animate.bind(this);
      }
    }
  },
  get target() {
    return this.keyEventTarget;
  },
  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },
  attached: function() {
    if (dom(this).parentNode.nodeType == 11) {
      this.keyEventTarget = dom(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = dom(this).parentNode;
    }
    var keyEventTarget =  (this.keyEventTarget);
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },
  detached: function() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },
  get shouldKeepAnimating() {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }
    return false;
  },
  simulatedRipple: function() {
    this.downAction(null);
    this.async(function() {
      this.upAction();
    }, 1);
  },
  uiDownAction: function(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },
  downAction: function(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }
    var ripple = this.addRipple();
    ripple.downAction(event);
    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },
  uiUpAction: function(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },
  upAction: function(event) {
    if (this.holdDown) {
      return;
    }
    this.ripples.forEach(function(ripple) {
      ripple.upAction(event);
    });
    this._animating = true;
    this.animate();
  },
  onAnimationComplete: function() {
    this._animating = false;
    this.$.background.style.backgroundColor = '';
    this.fire('transitionend');
  },
  addRipple: function() {
    var ripple = new Ripple(this);
    dom(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);
    this._setAnimating(true);
    return ripple;
  },
  removeRipple: function(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);
    if (rippleIndex < 0) {
      return;
    }
    this.ripples.splice(rippleIndex, 1);
    ripple.remove();
    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },
  animate: function() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;
    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];
      ripple.draw();
      this.$.background.style.opacity = ripple.outerOpacity;
      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }
    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },
  animateRipple: function() {
    return this.animate();
  },
  _onEnterKeydown: function() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },
  _onSpaceKeydown: function() {
    this.uiDownAction();
  },
  _onSpaceKeyup: function() {
    this.uiUpAction();
  },
  _holdDownChanged: function(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }
});

var AppBase_1;
const hashBangRe = /(.+)#!\/(.*)/;
if (hashBangRe.test(document.location.href)) {
    const hashBangParts = hashBangRe.exec(document.location.href);
    if (hashBangParts[2].startsWith("SignInWithToken/")) {
        history.replaceState(null, null, hashBangParts[1]);
        Service.token = hashBangParts[2].substr(16);
    }
    else if (hashBangParts[2].startsWith("SignInWithAuthorizationHeader/")) {
        history.replaceState(null, null, hashBangParts[1]);
        Service.token = `JWT:${hashBangParts[2].substr(30)}`;
    }
    else if (hashBangParts[2].startsWith("login_hint=")) {
        history.replaceState(null, null, hashBangParts[1]);
        cookie("userName", hashBangParts[2].split("=")[1], { expires: 30 });
    }
    else
        history.replaceState(null, null, `${hashBangParts[1]}${hashBangParts[2]}`);
}
window["Vidyano"] = Vidyano;
const base = document.head.querySelector("base");
if (!base)
    throw new Error("Document is missing base tag");
let AppBase = AppBase_1 = class AppBase extends WebComponent {
    static get template() { return html$3 `<style>:host {
  --theme-color-error: #a80511;
  --theme-color-warning: #e5a300;
  --theme-color-notice: #48545e;
  --theme-color-ok: #339f7b;
  --theme-h1: 40px;
  --theme-h2: 32px;
  --theme-h3: 22px;
  --theme-h4: 12px;
  --theme-h5: 6px;
  --theme-foreground: #333;
  --theme-light-border: #ddd;
  --theme-dark-border: darken(#EAEAEA, 15%);
  --theme-read-only: #f7f7f7;
  --theme-box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.5);
  position: relative;
  overflow-x: hidden;
  font-family: "Open Sans", Arial, Helvetica, sans-serif;
  font-size: 13px;
  color: var(--theme-foreground);
  fill: var(--theme-foreground);
  outline: none;
  --color-faint: var(--theme-color-faint);
  --color-semi-faint: var(--theme-color-semi-faint);
  --color-lighter: var(--theme-color-lighter);
  --color-light: var(--theme-color-light);
  --color: var(--theme-color);
  --color-dark: var(--theme-color-dark);
  --color-darker: var(--theme-color-darker);
  --color-rgb: var(--theme-color-rgb);
  --colors-steel-blue: #4682B4;
  --colors-steel-blue-50: #ecf2f7;
  --colors-steel-blue-100: #90b4d2;
  --colors-steel-blue-200: #7da7ca;
  --colors-steel-blue-300: #6a9bc3;
  --colors-steel-blue-400: #588ebb;
  --colors-steel-blue-500: #4682B4;
  --colors-steel-blue-600: #3f75a2;
  --colors-steel-blue-700: #386890;
  --colors-steel-blue-800: #315b7d;
  --colors-steel-blue-900: #2a4e6c;
  --colors-red: #f44336;
  --colors-red-50: #ffebee;
  --colors-red-100: #ffcdd2;
  --colors-red-200: #ef9a9a;
  --colors-red-300: #e57373;
  --colors-red-400: #ef5350;
  --colors-red-500: #f44336;
  --colors-red-600: #e53935;
  --colors-red-700: #d32f2f;
  --colors-red-800: #c62828;
  --colors-red-900: #b71c1c;
  --colors-pink: #e91e63;
  --colors-pink-50: #fce4ec;
  --colors-pink-100: #f8bbd0;
  --colors-pink-200: #f48fb1;
  --colors-pink-300: #f06292;
  --colors-pink-400: #ec407a;
  --colors-pink-500: #e91e63;
  --colors-pink-600: #d81b60;
  --colors-pink-700: #c2185b;
  --colors-pink-800: #ad1457;
  --colors-pink-900: #880e4f;
  --colors-purple: #9c27b0;
  --colors-purple-50: #f3e5f5;
  --colors-purple-100: #e1bee7;
  --colors-purple-200: #ce93d8;
  --colors-purple-300: #ba68c8;
  --colors-purple-400: #ab47bc;
  --colors-purple-500: #9c27b0;
  --colors-purple-600: #8e24aa;
  --colors-purple-700: #7b1fa2;
  --colors-purple-800: #6a1b9a;
  --colors-purple-900: #4a148c;
  --colors-deep-purple: #673ab7;
  --colors-deep-purple-50: #ede7f6;
  --colors-deep-purple-100: #d1c4e9;
  --colors-deep-purple-200: #b39ddb;
  --colors-deep-purple-300: #9575cd;
  --colors-deep-purple-400: #7e57c2;
  --colors-deep-purple-500: #673ab7;
  --colors-deep-purple-600: #5e35b1;
  --colors-deep-purple-700: #512da8;
  --colors-deep-purple-800: #4527a0;
  --colors-deep-purple-900: #311b92;
  --colors-indigo: #3f51b5;
  --colors-indigo-50: #e8eaf6;
  --colors-indigo-100: #c5cae9;
  --colors-indigo-200: #9fa8da;
  --colors-indigo-300: #7986cb;
  --colors-indigo-400: #5c6bc0;
  --colors-indigo-500: #3f51b5;
  --colors-indigo-600: #3949ab;
  --colors-indigo-700: #303f9f;
  --colors-indigo-800: #283593;
  --colors-indigo-900: #1a237e;
  --colors-blue: #2196f3;
  --colors-blue-50: #e3f2fd;
  --colors-blue-100: #bbdefb;
  --colors-blue-200: #90caf9;
  --colors-blue-300: #64b5f6;
  --colors-blue-400: #42a5f5;
  --colors-blue-500: #2196f3;
  --colors-blue-600: #1e88e5;
  --colors-blue-700: #1976d2;
  --colors-blue-800: #1565c0;
  --colors-blue-900: #0d47a1;
  --colors-light-blue: #03a9f4;
  --colors-light-blue-50: #e1f5fe;
  --colors-light-blue-100: #b3e5fc;
  --colors-light-blue-200: #81d4fa;
  --colors-light-blue-300: #4fc3f7;
  --colors-light-blue-400: #29b6f6;
  --colors-light-blue-500: #03a9f4;
  --colors-light-blue-600: #039be5;
  --colors-light-blue-700: #0288d1;
  --colors-light-blue-800: #0277bd;
  --colors-light-blue-900: #01579b;
  --colors-cyan: #00bcd4;
  --colors-cyan-50: #e0f7fa;
  --colors-cyan-100: #b2ebf2;
  --colors-cyan-200: #80deea;
  --colors-cyan-300: #4dd0e1;
  --colors-cyan-400: #26c6da;
  --colors-cyan-500: #00bcd4;
  --colors-cyan-600: #00acc1;
  --colors-cyan-700: #0097a7;
  --colors-cyan-800: #00838f;
  --colors-cyan-900: #006064;
  --colors-teal: #009688;
  --colors-teal-50: #e0f2f1;
  --colors-teal-100: #b2dfdb;
  --colors-teal-200: #80cbc4;
  --colors-teal-300: #4db6ac;
  --colors-teal-400: #26a69a;
  --colors-teal-500: #009688;
  --colors-teal-600: #00897b;
  --colors-teal-700: #00796b;
  --colors-teal-800: #00695c;
  --colors-teal-900: #004d40;
  --colors-green: #4caf50;
  --colors-green-50: #e8f5e9;
  --colors-green-100: #c8e6c9;
  --colors-green-200: #a5d6a7;
  --colors-green-300: #81c784;
  --colors-green-400: #66bb6a;
  --colors-green-500: #4caf50;
  --colors-green-600: #43a047;
  --colors-green-700: #388e3c;
  --colors-green-800: #2e7d32;
  --colors-green-900: #1b5e20;
  --colors-light-green: #8bc34a;
  --colors-light-green-50: #f1f8e9;
  --colors-light-green-100: #dcedc8;
  --colors-light-green-200: #c5e1a5;
  --colors-light-green-300: #aed581;
  --colors-light-green-400: #9ccc65;
  --colors-light-green-500: #8bc34a;
  --colors-light-green-600: #7cb342;
  --colors-light-green-700: #689f38;
  --colors-light-green-800: #558b2f;
  --colors-light-green-900: #33691e;
  --colors-lime: #cddc39;
  --colors-lime-50: #f9fbe7;
  --colors-lime-100: #f0f4c3;
  --colors-lime-200: #e6ee9c;
  --colors-lime-300: #dce775;
  --colors-lime-400: #d4e157;
  --colors-lime-500: #cddc39;
  --colors-lime-600: #c0ca33;
  --colors-lime-700: #afb42b;
  --colors-lime-800: #9e9d24;
  --colors-lime-900: #827717;
  --colors-yellow: #ffeb3b;
  --colors-yellow-50: #fffde7;
  --colors-yellow-100: #fff9c4;
  --colors-yellow-200: #fff59d;
  --colors-yellow-300: #fff176;
  --colors-yellow-400: #ffee58;
  --colors-yellow-500: #ffeb3b;
  --colors-yellow-600: #fdd835;
  --colors-yellow-700: #fbc02d;
  --colors-yellow-800: #f9a825;
  --colors-yellow-900: #f57f17;
  --colors-amber: #ffc107;
  --colors-amber-50: #fff8e1;
  --colors-amber-100: #ffecb3;
  --colors-amber-200: #ffe082;
  --colors-amber-300: #ffd54f;
  --colors-amber-400: #ffca28;
  --colors-amber-500: #ffc107;
  --colors-amber-600: #ffb300;
  --colors-amber-700: #ffa000;
  --colors-amber-800: #ff8f00;
  --colors-amber-900: #ff6f00;
  --colors-orange: #ff9800;
  --colors-orange-50: #fff3e0;
  --colors-orange-100: #ffe0b2;
  --colors-orange-200: #ffcc80;
  --colors-orange-300: #ffb74d;
  --colors-orange-400: #ffa726;
  --colors-orange-500: #ff9800;
  --colors-orange-600: #fb8c00;
  --colors-orange-700: #f57c00;
  --colors-orange-800: #ef6c00;
  --colors-orange-900: #e65100;
  --colors-deep-orange: #ff5722;
  --colors-deep-orange-50: #fbe9e7;
  --colors-deep-orange-100: #ffccbc;
  --colors-deep-orange-200: #ffab91;
  --colors-deep-orange-300: #ff8a65;
  --colors-deep-orange-400: #ff7043;
  --colors-deep-orange-500: #ff5722;
  --colors-deep-orange-600: #f4511e;
  --colors-deep-orange-700: #e64a19;
  --colors-deep-orange-800: #d84315;
  --colors-deep-orange-900: #bf360c;
  --colors-brown: #795548;
  --colors-brown-50: #efebe9;
  --colors-brown-100: #d7ccc8;
  --colors-brown-200: #bcaaa4;
  --colors-brown-300: #a1887f;
  --colors-brown-400: #8d6e63;
  --colors-brown-500: #795548;
  --colors-brown-600: #6d4c41;
  --colors-brown-700: #5d4037;
  --colors-brown-800: #4e342e;
  --colors-brown-900: #3e2723;
  --colors-grey: #9e9e9e;
  --colors-grey-50: #fafafa;
  --colors-grey-100: #f5f5f5;
  --colors-grey-200: #eeeeee;
  --colors-grey-300: #e0e0e0;
  --colors-grey-400: #bdbdbd;
  --colors-grey-500: #9e9e9e;
  --colors-grey-600: #757575;
  --colors-grey-700: #616161;
  --colors-grey-800: #424242;
  --colors-grey-900: #212121;
  --colors-blue-grey: #607d8b;
  --colors-blue-grey-50: #eceff1;
  --colors-blue-grey-100: #cfd8dc;
  --colors-blue-grey-200: #b0bec5;
  --colors-blue-grey-300: #90a4ae;
  --colors-blue-grey-400: #78909c;
  --colors-blue-grey-500: #607d8b;
  --colors-blue-grey-600: #546e7a;
  --colors-blue-grey-700: #455a64;
  --colors-blue-grey-800: #37474f;
  --colors-blue-grey-900: #263238;
}
:host([initializing]) vi-app-route, :host([initializing]) #dialogs {
  display: none !important;
}
:host(:not([is-profiling])) vi-profiler {
  display: none !important;
}
:host([is-profiling]) {
  padding-top: var(--theme-h1);
}
:host([is-profiling]) vi-profiler {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
:host([session-lost]) {
  padding-top: var(--theme-h1);
}
:host([session-lost][is-profiling]) {
  padding-top: calc(var(--theme-h1) * 2);
}
:host([session-lost][is-profiling]) vi-profiler {
  top: var(--theme-h1);
}
:host([is-tracking]) {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host [dialog] {
  display: flex;
  flex-direction: column;
  background-color: white;
  max-height: 90vh;
  max-width: 90vw;
  box-shadow: var(--theme-box-shadow);
}
:host [dialog][dragging] {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  cursor: move !important;
}
:host [dialog][no-header] ::content > header {
  display: none;
}
:host [dialog][no-header] ::content > main {
  padding-top: var(--theme-h4);
  margin-top: 0;
}
:host [dialog] ::content > header, :host [dialog] ::content > footer {
  background-color: #FAFAFA;
}
:host [dialog] ::content > header {
  flex: 0 0 auto;
  line-height: var(--theme-h1);
  padding: var(--theme-h5) var(--theme-h4);
  height: calc(var(--theme-h1) + var(--theme-h5) * 2);
  border-bottom: 1px solid #EEE;
  box-sizing: border-box;
}
:host [dialog] ::content > header h4 {
  margin: 0;
  font-weight: 500;
  font-size: 120%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
:host [dialog] ::content > header vi-button.close {
  margin: 0;
  padding: 0 var(--theme-h5);
  fill: #888;
  background: none;
  border: none;
  cursor: pointer;
}
:host [dialog] ::content > header vi-button.close:hover {
  fill: #555;
}
:host [dialog] ::content > header vi-button.close:active {
  fill: #333;
}
:host [dialog] ::content > header vi-button.close:focus {
  outline: none;
}
:host [dialog] ::content > footer {
  padding: var(--theme-h4);
  border-top: 1px solid #EEE;
  -webkit-flex: 0 0 auto;
  -moz-flex: 0 0 auto;
  -ms-flex: 0 0 auto;
  flex: 0 0 auto;
}
:host [dialog] ::content > footer vi-button {
  line-height: var(--theme-h2);
  padding: 0 var(--theme-h4);
}
:host [dialog] ::content > footer vi-button:not(:first-of-type) {
  margin-left: var(--theme-h5);
}
:host [dialog] ::content > main {
  position: relative;
  z-index: 1;
}
:host #sessionLost {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: var(--theme-h1);
  line-height: var(--theme-h1);
  background-color: #fefbda;
  border-bottom: 2px solid black;
  color: #6a541f;
  box-sizing: border-box;
  padding: 0 calc((var(--theme-h1) - var(--theme-h2)) / 2) 0 var(--theme-h5);
}
:host #sessionLost vi-icon {
  --vi-icon-width: 22px;
  --vi-icon-height: 22px;
  fill: #6a541f;
}
:host #sessionLost p {
  margin: 0 var(--theme-h4) 0 var(--theme-h5);
}
:host #sessionLost vi-button {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  background-color: #6a541f;
  padding: 0 var(--theme-h4);
}
:host #update {
  position: relative;
  z-index: 100000;
}
:host #update .overlay {
  position: fixed;
  content: "";
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: black;
  opacity: 0;
  transition: all 500ms ease-out;
  will-change: opacity;
}
:host #update .message {
  position: fixed;
  top: calc(var(--theme-h1) + var(--theme-h5));
  left: 50%;
  transform: translate(-50%, calc((var(--theme-h1) + var(--theme-h5)) * -2));
  background-color: var(--theme-foreground);
  color: white;
  padding: var(--theme-h4) var(--theme-h3);
  cursor: pointer;
  box-shadow: 3px 3px 12px 0px rgba(0, 0, 0, 0.5);
  transition: all 500ms cubic-bezier(0.175, 0.885, 0.32, 1.275);
  will-change: transform;
}
:host #update .message > .highlight {
  margin-left: var(--theme-h4);
  color: var(--colors-yellow);
  font-weight: bold;
}
:host #update.show .overlay {
  opacity: 0.25;
}
:host #update.show .message {
  transform: translate(-50%, 0px);
}</style>
<style include="vi-responsive-style-module"></style>

<iron-a11y-keys keys="[[keys]]" on-keys-pressed="_keysPressed"></iron-a11y-keys>
<iron-media-query query="(max-width: 479px)" query-matches="{{isPhone}}"></iron-media-query>
<iron-media-query query="(min-width: 480px) and (max-width: 839px)" query-matches="{{isTablet}}"></iron-media-query>
<iron-media-query query="(min-width: 840px)" query-matches="{{isDesktop}}"></iron-media-query>
<input id="catchautofill" style="position: fixed; visibility: hidden; left: -100vw;" />
<dom-if if="[[sessionLost]]">
    <template>
        <div id="sessionLost" class="layout horizontal" on-tap="_reload">
            <vi-icon source="Notification_Warning"></vi-icon>
            <p>[[translations.SessionLost]]</p>
            <vi-button class="self-center" label="[[translations.Reload]]"></vi-button>
        </div>
    </template>
</dom-if>
<vi-app-config>
    <vi-persistent-object-attribute-config type="CommonMark" height="3"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="Reference" height="attr.selectInPlace && ['radio', 'chip'].indexOf(attr.getTypeHint('inputtype', '', undefined, true)) >= 0 ? 0 : 1"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="DropDown" height="['radio', 'chip'].indexOf(attr.getTypeHint('inputtype', '', undefined, true)) >= 0 ? 0 : 1"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="KeyValueList" height="['radio', 'chip'].indexOf(attr.getTypeHint('inputtype', '', undefined, true)) >= 0 ? 0 : 1"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="Enum" height="['radio', 'chip'].indexOf(attr.getTypeHint('inputtype', '', undefined, true)) >= 0 ? 0 : 1"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="MultiLineString" height="attr.getTypeHint('height', 3, undefined, true)"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="MultiString" height="attr.getTypeHint('height', 3, undefined, true)"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="Image" height="attr.getTypeHint('height', 2, undefined, true)"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="TranslatedString" height="attr.getTypeHint('MultiLine') == 'True' ? 3 : 1"></vi-persistent-object-attribute-config>
    <vi-persistent-object-attribute-config type="AsDetail" height="attr.getTypeHint('height', 'auto', undefined, true) == 'auto' ? 0 : 6"></vi-persistent-object-attribute-config>
    <vi-persistent-object-tab-config type="Vidyano.GlobalSearch" name="">
        <template is="dom-template">
            <style is="custom-style">
                #globalSearch {
                    color: var(--theme-color-error);
                    fill: var(--theme-color-error);
                }

                    #globalSearch span {
                        display: block;
                        text-align: center;
                        padding: var(--theme-h5) var(--theme-h3);
                    }
            </style>
            <div id="globalSearch" class="flex layout horizontal center-center">
                <div>
                    <vi-icon source="Notification_Error" class="size-h1"></vi-icon>
                    <span class="error">[[translations.NoResultsFound]]</span>
                </div>
            </div>
        </template>
    </vi-persistent-object-tab-config>
    <vi-persistent-object-attribute-config parent-id="d2662fbc-5bfc-44c0-9ba1-1e84058c2dc2" name="Message" height="0"></vi-persistent-object-attribute-config>
    <vi-persistent-object-config type="Vidyano.Placeholder" object-id="Vidyano.Audit">
        <template is="dom-template">
            <vi-audit class="flex" persistent-object="[[persistentObject]]"></vi-audit>
        </template>
    </vi-persistent-object-config>
    <vi-persistent-object-tab-config type="LogVerboseData" name="LogVerboseData">
        <template is="dom-template">
            <textarea readonly style="outline: none; border: none; resize: none;">[[tab.attributes.Data.value]]</textarea>
        </template>
    </vi-persistent-object-tab-config>
    <slot name="vi-app-config" slot="vi-app-config"></slot>
</vi-app-config>
<dom-if if="[[updateAvailable]]">
    <template>
        <div id="update">
            <div class="overlay" on-tap="_refreshForUpdateDismiss"></div>
            <div class="message" on-tap="_refreshForUpdate">
                <span>[[translations.ApplicationOutdated]]</span>
                <span class="highlight">[[translations.ApplicationOutdatedRefresh]]</span>
            </div>
        </div>
    </template>
</dom-if>
<vi-spinner hidden$="[[!initializing]]"></vi-spinner>

<dom-module id="vi-app-config">
    <template>
        <slot id="configs" name="vi-app-config"></slot>
    </template>
</dom-module>

<vi-alert id="alert"></vi-alert>`; }
    constructor(_hooks) {
        super();
        this._hooks = _hooks;
        this._keybindingRegistrations = {};
        this._activeDialogs = [];
        this._initialize = new Promise(resolve => { this._initializeResolve = resolve; });
        window["app"] = this;
        window.dispatchEvent(new CustomEvent("app-changed", { detail: { value: this } }));
        if (!this.uri && document.location.hash)
            this.uri = document.location.hash.trimStart("#");
    }
    async connectedCallback() {
        window.addEventListener("storage", this._onSessionStorage.bind(this), false);
        ServiceBus.subscribe("path-changed", (sender, message, details) => {
            if (sender === this)
                return;
            this.path = details.path;
        }, true);
        this._initPathRescue();
        super.connectedCallback();
        const a11yKeys = this.shadowRoot.querySelector("iron-a11y-keys");
        a11yKeys.target = document.body;
        this.setAttribute("tabindex", "-1");
    }
    get initialize() {
        return this._initialize;
    }
    get hooks() {
        return this._hooks;
    }
    get activeElement() {
        return this.activeElementPath[0];
    }
    get activeElementPath() {
        const path = [document.activeElement];
        let element = document.activeElement;
        while (element.shadowRoot != null && element.shadowRoot.activeElement)
            path.push(element = element.shadowRoot.activeElement);
        return path.reverse();
    }
    _noHistoryChanged(noHistory) {
        Path.history.noHistory = noHistory;
    }
    _initPathRescue() {
        Path.rescue(() => {
            this.path = AppBase_1.removeRootPath(Path.routes.current);
        });
    }
    _appRoutePresenterConnected(e) {
        this._setAppRoutePresenter(e.detail["presenter"]);
    }
    async _computeInitialService(uri, isConnected) {
        if (!isConnected)
            return;
        if (this.service) {
            console.warn("Service uri cannot be altered.");
            return this.service;
        }
        if (!this._hooks)
            this._hooks = new AppServiceHooksBase();
        this._setService(new Service(uri, this.hooks));
        const path = AppBase_1.removeRootPath(document.location.pathname);
        const skipDefaultCredentialLogin = path.startsWith("sign-in");
        this._setInitializing(true);
        try {
            await this.service.initialize(skipDefaultCredentialLogin);
            await this.hooks.onBeforeAppInitialized();
            this._initializeResolve(this.service.application);
            this._setInitializing(false);
        }
        catch (e) {
            this.hooks.onAppInitializeFailed(e);
        }
    }
    _onSessionStorage(event) {
        if (!event)
            event = window.event;
        if (event.newValue == null || (!event.newValue.startsWith("{") && cookiePrefix() !== event.newValue))
            return;
        else if (event.newValue.startsWith("{")) {
            const value = JSON.parse(event.newValue);
            if (cookiePrefix() !== value.cookiePrefix)
                return;
        }
        if (event.key === "vi-signOut" && this.service && this.service.isSignedIn)
            this._setSessionLost(true);
        else if (this.sessionLost && event.key === "vi-setAuthToken") {
            const authTokenInfo = JSON.parse(event.newValue);
            this.service.authToken = authTokenInfo.authToken;
            this._setSessionLost(false);
        }
        else if (event.key === "vi-updateAvailable") {
            if (this.service != null)
                this.service.hooks.onUpdateAvailable();
            else
                this._updateAvailable();
        }
    }
    _reload(e) {
        e.stopPropagation();
        document.location.reload();
    }
    get configuration() {
        return this.shadowRoot.querySelector("vi-app-config");
    }
    changePath(path, replaceCurrent = false) {
        while (path[0] === "/")
            path = path.slice(1);
        if (this.path === path)
            return;
        if (!replaceCurrent)
            Path.history.pushState(null, null, Path.routes.rootPath + path);
        else
            Path.history.replaceState(null, null, Path.routes.rootPath + path);
    }
    async _pathChanged(path) {
        await this.initialize;
        if (path !== this.path)
            return;
        ServiceBus.send(this, "path-changed", { path: path });
    }
    async showDialog(dialog) {
        this.shadowRoot.appendChild(dialog);
        this._activeDialogs.push(dialog);
        try {
            return await dialog.open();
        }
        finally {
            this.shadowRoot.removeChild(dialog);
            this._activeDialogs.pop();
        }
    }
    async showMessageDialog(options) {
        return this.showDialog(new MessageDialog(options));
    }
    showAlert(notification, type = "Notice", duration = 3000) {
        this.$.alert.log(notification, type, duration);
    }
    redirectToSignIn(keepUrl = true) {
        this.service.hooks.onRedirectToSignIn(keepUrl);
    }
    redirectToSignOut(keepUrl = true) {
        this.service.hooks.onRedirectToSignOut(keepUrl);
    }
    _sensitiveChanged(sensitive) {
        const currentSensitiveCookie = !!Boolean.parse(cookie("sensitive"));
        if (currentSensitiveCookie !== sensitive)
            cookie("sensitive", String(sensitive));
        ServiceBus.send("vi-app:sensitive-changed", sensitive);
    }
    _cookiePrefixChanged(cookiePrefix$1) {
        cookiePrefix(cookiePrefix$1);
    }
    _anchorClickHandler(e) {
        if (e.defaultPrevented)
            return;
        const path = e.composedPath();
        const anchorParent = path.find((el) => el.tagName === "A");
        if (anchorParent && anchorParent.href.startsWith(Path.routes.root || "") && !anchorParent.hasAttribute("download") && !(anchorParent.getAttribute("rel") || "").contains("external")) {
            e.stopPropagation();
            e.preventDefault();
            let path = anchorParent.href.slice(Path.routes.root.length);
            if (path.startsWith("#!/"))
                path = path.substr(3);
            this.changePath(path);
        }
    }
    _updateAvailable() {
        if (this._updateAvailableSnoozeTimer)
            return;
        this._setUpdateAvailable(true);
        flush$1();
    }
    _refreshForUpdate() {
        document.location.reload();
    }
    _refreshForUpdateDismiss() {
        if (this._updateAvailableSnoozeTimer)
            clearTimeout(this._updateAvailableSnoozeTimer);
        this._updateAvailableSnoozeTimer = setTimeout(() => {
            this._updateAvailableSnoozeTimer = null;
            this._updateAvailable();
        }, 300000);
        this.shadowRoot.querySelector("#update").classList.remove("show");
    }
    _computeThemeColorVariants(base, target, isConnected) {
        if (!isConnected || !base)
            return;
        if (!base.startsWith("#"))
            base = `#${base}`;
        const appColor = new AppColor(base);
        this.style.setProperty(`--theme-${target}`, base);
        this.style.setProperty(`--theme-${target}-light`, appColor.light);
        this.style.setProperty(`--theme-${target}-lighter`, appColor.lighter);
        this.style.setProperty(`--theme-${target}-dark`, appColor.dark);
        this.style.setProperty(`--theme-${target}-darker`, appColor.darker);
        this.style.setProperty(`--theme-${target}-faint`, appColor.faint);
        this.style.setProperty(`--theme-${target}-semi-faint`, appColor.semiFaint);
        this.style.setProperty(`--theme-${target}-rgb`, appColor.rgb);
    }
    _cleanUpOnSignOut(isSignedIn) {
        if (isSignedIn === false) {
            localStorage.setItem("vi-signOut", cookiePrefix());
            localStorage.removeItem("vi-signOut");
        }
    }
    _registerKeybindings(registration) {
        const currentKeys = this.keys ? this.keys.split(" ") : [];
        registration.keys.forEach(key => {
            registration.scope = this.findParent(e => e instanceof AppRoute || e instanceof Dialog, registration.element);
            const registrations = this._keybindingRegistrations[key] || (this._keybindingRegistrations[key] = []);
            registrations.push(registration);
            currentKeys.push(key);
        });
        this._setKeys(currentKeys.distinct().join(" "));
    }
    _unregisterKeybindings(registration) {
        const currentKeys = this.keys.split(" ");
        registration.keys.forEach(key => {
            const registrations = this._keybindingRegistrations[key];
            registrations.remove(registration);
            if (registrations.length === 0) {
                this._keybindingRegistrations[key] = undefined;
                currentKeys.remove(key);
            }
        });
        this._setKeys(currentKeys.distinct().join(" "));
    }
    _mediaQueryChanged(isDesktop, isTablet, isPhone) {
        this.fire("media-query-changed", isDesktop ? "desktop" : (isTablet ? "tablet" : "phone"), { bubbles: false });
    }
    _keysPressed(e) {
        if (!this._keybindingRegistrations[e.detail.combo])
            return;
        if (this.activeElement instanceof HTMLInputElement && !(e.detail.keyboardEvent.ctrlKey || e.detail.keyboardEvent.shiftKey || e.detail.keyboardEvent.altKey) && e.detail.key !== "esc")
            return;
        let combo = e.detail.combo;
        if (e.detail.keyboardEvent.ctrlKey && combo.indexOf("ctrl") < 0)
            combo = "ctrl+" + combo;
        if (e.detail.keyboardEvent.shiftKey && combo.indexOf("shift") < 0)
            combo = "shift+" + combo;
        if (e.detail.keyboardEvent.altKey && combo.indexOf("alt") < 0)
            combo = "alt+" + combo;
        let registrations = this._keybindingRegistrations[combo];
        if (!registrations)
            return;
        if (this._activeDialogs.length > 0) {
            const activeDialog = this._activeDialogs[this._activeDialogs.length - 1];
            registrations = registrations.filter(r => r.scope === activeDialog);
        }
        registrations = registrations.filter(reg => !reg.scope || (reg.scope instanceof AppRoute && reg.scope.active));
        const highestPriorityRegs = registrations.groupBy(r => r.priority).orderByDescending(kvp => kvp.key)[0];
        if (!highestPriorityRegs || !highestPriorityRegs.value.length)
            return;
        const regs = highestPriorityRegs;
        if (regs.value.length > 1 && regs.value.some(r => !r.nonExclusive))
            return;
        regs.value.forEach(reg => {
            reg.listener(e);
        });
    }
    static removeRootPath(path = "") {
        if (path.startsWith(Path.routes.rootPath))
            return path.substr(Path.routes.rootPath.length);
        return path;
    }
};
AppBase = AppBase_1 = __decorate([
    WebComponent.registerAbstract({
        properties: {
            uri: {
                type: String,
                reflectToAttribute: true,
                value: ""
            },
            base: {
                type: String,
                readOnly: true,
                value: () => {
                    return base.href;
                }
            },
            path: {
                type: String,
                reflectToAttribute: true,
                observer: "_pathChanged",
                value: () => {
                    const parser = document.createElement("a");
                    parser.href = base.href;
                    Path.routes.rootPath = parser.pathname;
                    Path.root(base.href);
                    Path.history.listen();
                    return document.location.toString().substr(base.href.length).replace(document.location.hash, "");
                }
            },
            service: {
                type: Object,
                readOnly: true
            },
            appRoutePresenter: {
                type: Object,
                readOnly: true
            },
            user: {
                type: String,
                reflectToAttribute: true,
                value: null
            },
            keys: {
                type: String,
                readOnly: true
            },
            initializing: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                value: true
            },
            isDesktop: {
                type: Boolean,
                reflectToAttribute: true
            },
            isTablet: {
                type: Boolean,
                reflectToAttribute: true
            },
            isPhone: {
                type: Boolean,
                reflectToAttribute: true
            },
            isTracking: {
                type: Boolean,
                reflectToAttribute: true
            },
            cookiePrefix: {
                type: String,
                reflectToAttribute: true,
                observer: "_cookiePrefixChanged"
            },
            noHistory: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
                observer: "_noHistoryChanged"
            },
            themeColor: {
                type: String,
                reflectToAttribute: true,
                value: "#4682B4"
            },
            themeAccentColor: {
                type: String,
                reflectToAttribute: true,
                value: "#009688"
            },
            configs: String,
            updateAvailable: {
                type: Boolean,
                readOnly: true,
                value: false
            },
            sensitive: {
                type: Boolean,
                reflectToAttribute: true,
                observer: "_sensitiveChanged"
            },
            sessionLost: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                value: false
            }
        },
        observers: [
            "_computeInitialService(uri, isConnected)",
            "_cleanUpOnSignOut(service.isSignedIn)",
            "_computeThemeColorVariants(themeColor, 'color', isConnected)",
            "_computeThemeColorVariants(themeAccentColor, 'accent-color', isConnected)",
            "_mediaQueryChanged(isDesktop, isTablet, isPhone)"
        ],
        listeners: {
            "app-route-presenter:connected": "_appRoutePresenterConnected",
            "click": "_anchorClickHandler",
            "app-update-available": "_updateAvailable"
        },
        forwardObservers: [
            "service.isSignedIn",
            "service.application"
        ]
    })
], AppBase);

let Button = class Button extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  align-items: center;
  justify-content: center;
  contain: content;
  position: relative;
  cursor: pointer;
  transition-property: fill, color, background-color;
  transition-duration: 0.1s;
  transition-timing-function: ease-out;
  border: none;
  outline: none;
  box-sizing: border-box;
  user-select: none;
  --vi-spinner-size: 1.5em;
  /* elevation values from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */
}
:host .highlight {
  display: none !important;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background-color: var(--color);
  opacity: 0.1;
}
:host([elevation]) {
  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
  will-change: transition;
}
:host([elevation]:active) {
  box-shadow: none;
}
:host([elevation="1"]) {
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
}
:host([elevation="2"]) {
  box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.4);
}
:host([elevation="3"]) {
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.4);
}
:host([elevation="4"]) {
  box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.4);
}
:host([elevation="5"]) {
  box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(0, 0, 0, 0.4);
}
:host([disabled]) {
  cursor: default;
  pointer-events: none;
}
:host(:not([custom-layout])) {
  padding: 1px var(--theme-h5);
  text-align: center;
  white-space: nowrap;
  gap: 2px;
}
:host(:not([custom-layout])) > *:not(style) {
  display: inline-block;
}
:host(:not([custom-layout])[busy]) > span, :host(:not([custom-layout])[busy]) > vi-icon {
  visibility: hidden;
}
:host([type=""]:not([inverse])), :host(:not([type]):not([inverse])) {
  background-color: var(--color);
  color: white;
  fill: white;
  --vi-spinner-color: white;
}
:host([type=""]:not([inverse]):not([disabled]):hover), :host(:not([type]):not([inverse]):not([disabled]):hover) {
  background-color: var(--color-light);
}
:host([type=""]:not([inverse]):not([busy])[disabled]), :host(:not([type]):not([inverse]):not([busy])[disabled]) {
  opacity: 0.5;
}
:host([type=""][inverse]), :host(:not([type])[inverse]) {
  background-color: transparent;
  color: var(--color);
  fill: var(--color);
  --vi-spinner-color: var(--color);
}
:host([type=""][inverse]:not([disabled]):hover), :host(:not([type])[inverse]:not([disabled]):hover) {
  background-color: rgba(var(--color-rgb), 0.1);
}
:host([type=""][inverse]:not([busy])[disabled]), :host(:not([type])[inverse]:not([busy])[disabled]) {
  opacity: 0.5;
}
:host([type=light-monochrome]:not([inverse])) {
  background-color: #f0f0f0;
  color: white;
  fill: white;
  --vi-spinner-color: white;
}
:host([type=light-monochrome]:not([inverse]):not([disabled]):hover) {
  background-color: white;
}
:host([type=light-monochrome]:not([inverse])[disabled]) {
  background-color: fadeout(#f0f0f0, 50%) !important;
  fill: fadeout(white, 50%) !important;
  color: fadeout(white, 50%) !important;
}
:host([type=light-monochrome][inverse]) {
  background-color: transparent;
  color: #f0f0f0;
  fill: #f0f0f0;
  --vi-spinner-color: #f0f0f0;
}
:host([type=light-monochrome][inverse]:not([disabled]):hover) {
  background-color: fadeout(#f0f0f0, 90%);
}
:host([type=light-monochrome][inverse][disabled]) {
  background-color: fadeout(transparent, 50%) !important;
  fill: fadeout(#f0f0f0, 50%) !important;
  color: fadeout(#f0f0f0, 50%) !important;
}
:host([type=danger]:not([inverse])) {
  background-color: #FF4136;
  color: white;
  fill: white;
  --vi-spinner-color: white;
}
:host([type=danger]:not([inverse]):not([disabled]):hover) {
  background-color: #ff7169;
}
:host([type=danger]:not([inverse])[disabled]) {
  background-color: fadeout(#FF4136, 50%) !important;
  fill: fadeout(white, 50%) !important;
  color: fadeout(white, 50%) !important;
}
:host([type=danger][inverse]) {
  background-color: transparent;
  color: #FF4136;
  fill: #FF4136;
  --vi-spinner-color: #FF4136;
}
:host([type=danger][inverse]:not([disabled]):hover) {
  background-color: fadeout(#FF4136, 90%);
}
:host([type=danger][inverse][disabled]) {
  background-color: fadeout(transparent, 50%) !important;
  fill: fadeout(#FF4136, 50%) !important;
  color: fadeout(#FF4136, 50%) !important;
}
:host([type=safe]:not([inverse])) {
  background-color: #3D9970;
  color: white;
  fill: white;
  --vi-spinner-color: white;
}
:host([type=safe]:not([inverse]):not([disabled]):hover) {
  background-color: #50b98a;
}
:host([type=safe]:not([inverse])[disabled]) {
  background-color: fadeout(#3D9970, 50%) !important;
  fill: fadeout(white, 50%) !important;
  color: fadeout(white, 50%) !important;
}
:host([type=safe][inverse]) {
  background-color: transparent;
  color: #3D9970;
  fill: #3D9970;
  --vi-spinner-color: #3D9970;
}
:host([type=safe][inverse]:not([disabled]):hover) {
  background-color: fadeout(#3D9970, 90%);
}
:host([type=safe][inverse][disabled]) {
  background-color: fadeout(transparent, 50%) !important;
  fill: fadeout(#3D9970, 50%) !important;
  color: fadeout(#3D9970, 50%) !important;
}
:host([accent]) {
  --color: var(--theme-accent-color);
  --color-light: var(--theme-accent-color-light);
  --color-lighter: var(--theme-accent-color-lighter);
  --color-dark: var(--theme-accent-color-dark);
  --color-darker: var(--theme-accent-color-darker);
  --color-faint: var(--theme-accent-color-faint);
  --color-semi-faint: var(--theme-accent-color-semi-faint);
  --color-rgb: var(--theme-accent-color-rgb);
}
:host([accent]) paper-ripple {
  color: var(--color);
}

vi-popup[open] > [toggle] vi-button[slot=header][type=""]:not([inverse]), vi-popup[open] > [toggle] vi-button[slot=header]:not([type]):not([inverse]) {
  background-color: var(--color-light);
}
vi-popup[open] > [toggle] vi-button[slot=header][type=""][inverse], vi-popup[open] > [toggle] vi-button[slot=header]:not([type])[inverse] {
  background-color: var(--color-faint);
}
vi-popup[open] > [toggle] vi-button[slot=header][type=light-monochrome]:not([inverse]) {
  background-color: white;
}
vi-popup[open] > [toggle] vi-button[slot=header][type=light-monochrome][inverse] {
  background-color: fadeout(#f0f0f0, 90%);
}
vi-popup[open] > [toggle] vi-button[slot=header][type=danger]:not([inverse]) {
  background-color: #ff7169;
}
vi-popup[open] > [toggle] vi-button[slot=header][type=danger][inverse] {
  background-color: fadeout(#FF4136, 90%);
}
vi-popup[open] > [toggle] vi-button[slot=header][type=safe]:not([inverse]) {
  background-color: #50b98a;
}
vi-popup[open] > [toggle] vi-button[slot=header][type=safe][inverse] {
  background-color: fadeout(#3D9970, 90%);
}</style>

<paper-ripple></paper-ripple>
<div class="highlight"></div>
<dom-if if="[[customLayout]]">
    <template>
        <slot></slot>
    </template>
</dom-if>
<dom-if if="[[!customLayout]]">
    <template>
        <vi-icon source="[[icon]]" part="icon"></vi-icon>
        <dom-if if="[[label]]">
            <template>
                <span part="label">[[label]]</span>
            </template>
        </dom-if>
        <dom-if if="[[busy]]">
            <template>
                <vi-spinner></vi-spinner>
            </template>
        </dom-if>
    </template>
</dom-if>`; }
    connectedCallback() {
        super.connectedCallback();
        if (!this.getAttribute("tabindex"))
            this.setAttribute("tabindex", "0");
        this._setCustomLayout(this.children.length > 0);
    }
    _fireTap() {
        this.click();
    }
    _tap(e) {
        if (this.disabled) {
            e.stopImmediatePropagation();
            e.preventDefault();
        }
    }
};
Button = __decorate([
    WebComponent.register({
        properties: {
            accent: {
                type: Boolean,
                reflectToAttribute: true
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            },
            inverse: {
                type: String,
                reflectToAttribute: true
            },
            customLayout: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            elevation: {
                type: Number,
                reflectToAttribute: true
            },
            icon: String,
            label: String,
            busy: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        keybindings: {
            "space": "_fireTap",
            "enter": "_fireTap"
        },
        listeners: {
            "tap": "_tap"
        }
    })
], Button);

let InputSearch = class InputSearch extends WebComponent {
    static get template() { return html$3 `<style include="vi-reset-css-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  line-height: var(--theme-h2);
  position: relative;
}
:host form {
  margin: 0;
  flex: 1;
}
:host input {
  border: none;
  outline: none;
  box-sizing: border-box;
  padding-right: var(--theme-h2);
  padding-left: var(--theme-h5);
  background-color: transparent;
  color: white;
  width: 100%;
}
:host input::placeholder {
  color: var(--vi-input-search-placeholder-color, #aaa);
}
:host button {
  position: absolute;
  top: 1px;
  right: 1px;
  bottom: 1px;
  border: none;
  outline: none;
  fill: #aaa;
  cursor: pointer;
  width: var(--theme-h2);
  background-color: transparent;
  margin: 1px 1px 1px 0;
}</style>

<form autocomplete="off" class="flex layout horizontal" on-submit="_catchOnSumbit">
    <input class="flex" placeholder="[[translateMessage('FilterSearchHint', isConnected)]]" value="{{value::input}}" on-keypress="_searchKeypressed" on-focus="_input_focused" on-blur="_input_blurred" autofocus$="[[autofocus]]" role="search" part="input">
</form>
<button class="reset" on-tap="_resetClick" hidden$="[[!hasValue]]" part="reset">
    <vi-icon source="SearchReset"></vi-icon>
</button>
<button class="search" on-tap="_searchClick" hidden$="[[hasValue]]" part="search">
    <vi-icon source="Search"></vi-icon>
</button>`; }
    connectedCallback() {
        super.connectedCallback();
        if (this.autofocus)
            this._focusElement(this);
    }
    _searchKeypressed(e) {
        if (e.keyCode === 13)
            this._searchClick();
    }
    _searchClick(e) {
        this.fire("search", this.value);
        if (e && !this.value)
            e.stopPropagation();
    }
    _resetClick(e) {
        this.fire("search", this.value = "");
        if (e && !this.value)
            e.stopPropagation();
    }
    _input_focused() {
        this.focused = true;
    }
    _input_blurred() {
        this.focused = false;
    }
    _stop_tap(e) {
        e.stopPropagation();
        this._focusElement(this);
    }
    _catchOnSumbit(e) {
        e.preventDefault();
    }
    _computeHasValue(value) {
        return !!value;
    }
    focus() {
        this._focusElement(this.shadowRoot.querySelector("input"));
    }
};
InputSearch = __decorate([
    WebComponent.register({
        properties: {
            value: {
                type: String,
                notify: true,
                value: ""
            },
            hasValue: {
                type: Boolean,
                computed: "_computeHasValue(value)"
            },
            focused: {
                type: Boolean,
                notify: true,
                reflectToAttribute: true
            },
            autofocus: {
                type: Boolean,
                reflectToAttribute: true
            }
        }
    })
], InputSearch);

Polymer({
  _template: html$3`
    <style>
      :host {
        display: block;
        transition-duration: var(--iron-collapse-transition-duration, 300ms);
        /* Safari 10 needs this property prefixed to correctly apply the custom property */
        -webkit-transition-duration: var(--iron-collapse-transition-duration, 300ms);
        overflow: visible;
      }

      :host(.iron-collapse-closed) {
        display: none;
      }

      :host(:not(.iron-collapse-opened)) {
        overflow: hidden;
      }
    </style>

    <slot></slot>
`,
  is: 'iron-collapse',
  behaviors: [IronResizableBehavior],
  properties: {
    horizontal: {type: Boolean, value: false, observer: '_horizontalChanged'},
    opened:
        {type: Boolean, value: false, notify: true, observer: '_openedChanged'},
    transitioning: {type: Boolean, notify: true, readOnly: true},
    noAnimation: {type: Boolean},
    _desiredSize: {type: String, value: ''}
  },
  get dimension() {
    return this.horizontal ? 'width' : 'height';
  },
  get _dimensionMax() {
    return this.horizontal ? 'maxWidth' : 'maxHeight';
  },
  get _dimensionMaxCss() {
    return this.horizontal ? 'max-width' : 'max-height';
  },
  hostAttributes: {
    role: 'group',
    'aria-hidden': 'true',
  },
  listeners: {transitionend: '_onTransitionEnd'},
  toggle: function() {
    this.opened = !this.opened;
  },
  show: function() {
    this.opened = true;
  },
  hide: function() {
    this.opened = false;
  },
  updateSize: function(size, animated) {
    size = size === 'auto' ? '' : size;
    var willAnimate = animated && !this.noAnimation && this.isAttached &&
        this._desiredSize !== size;
    this._desiredSize = size;
    this._updateTransition(false);
    if (willAnimate) {
      var startSize = this._calcSize();
      if (size === '') {
        this.style[this._dimensionMax] = '';
        size = this._calcSize();
      }
      this.style[this._dimensionMax] = startSize;
      this.scrollTop = this.scrollTop;
      this._updateTransition(true);
      willAnimate = (size !== startSize);
    }
    this.style[this._dimensionMax] = size;
    if (!willAnimate) {
      this._transitionEnd();
    }
  },
  enableTransition: function(enabled) {
    Base._warn(
        '`enableTransition()` is deprecated, use `noAnimation` instead.');
    this.noAnimation = !enabled;
  },
  _updateTransition: function(enabled) {
    this.style.transitionDuration = (enabled && !this.noAnimation) ? '' : '0s';
  },
  _horizontalChanged: function() {
    this.style.transitionProperty = this._dimensionMaxCss;
    var otherDimension =
        this._dimensionMax === 'maxWidth' ? 'maxHeight' : 'maxWidth';
    this.style[otherDimension] = '';
    this.updateSize(this.opened ? 'auto' : '0px', false);
  },
  _openedChanged: function() {
    this.setAttribute('aria-hidden', !this.opened);
    this._setTransitioning(true);
    this.toggleClass('iron-collapse-closed', false);
    this.toggleClass('iron-collapse-opened', false);
    this.updateSize(this.opened ? 'auto' : '0px', true);
    if (this.opened) {
      this.focus();
    }
  },
  _transitionEnd: function() {
    this.style[this._dimensionMax] = this._desiredSize;
    this.toggleClass('iron-collapse-closed', !this.opened);
    this.toggleClass('iron-collapse-opened', this.opened);
    this._updateTransition(false);
    this.notifyResize();
    this._setTransitioning(false);
  },
  _onTransitionEnd: function(event) {
    if (dom(event).rootTarget === this) {
      this._transitionEnd();
    }
  },
  _calcSize: function() {
    return this.getBoundingClientRect()[this.dimension] + 'px';
  }
});

var MenuItem_1;
let MenuItem = MenuItem_1 = class MenuItem extends ConfigurableWebComponent {
    static get template() { return html$3 `<style>:host {
  position: relative;
  box-sizing: border-box;
  display: block;
  line-height: var(--theme-h2);
  color: var(--vi-menu-color, #FAFAFA);
  fill: var(--vi-menu-color, #FAFAFA);
  cursor: pointer;
  --iron-collapse-transition-duration: 150ms;
}
:host span.match {
  color: #FFDD00;
  font-weight: bold;
  pointer-events: none;
}
:host > .title {
  display: flex;
  flex-direction: row;
  position: relative;
  padding-right: var(--theme-h5);
  text-decoration: none;
  color: var(--vi-menu-color, #FAFAFA);
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  outline: none;
}
:host > .title:hover {
  background-color: rgba(0, 0, 0, 0.1);
}
:host > .title > vi-icon {
  height: var(--theme-h2);
  width: var(--theme-h3);
  --vi-icon-width: 1em;
  --vi-icon-height: 1em;
  margin-left: calc(var(--theme-h3) * var(--vi-menu-item-indent-level, 0));
  fill: var(--vi-menu-color, #FAFAFA);
  transition: transform 0.2s ease;
  transform: rotate(0deg);
}
:host > .title > vi-icon[unresolved] {
  display: none;
}
:host > .title > vi-icon[unresolved] + span {
  margin-left: calc(var(--theme-h3) + var(--theme-h3) * var(--vi-menu-item-indent-level, 0));
}
:host([hidden]) {
  display: none !important;
}
:host([expand]) > .title > vi-icon[source=ProgramUnitGroup], :host([filtering]) > .title > vi-icon[source=ProgramUnitGroup] {
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  -webkit-transform: rotate(90deg);
  transform: rotate(90deg);
}
:host(.program-unit) {
  background-color: transparent;
}
:host(.program-unit) > .title {
  font-weight: 600;
  color: var(--vi-menu-color, #FAFAFA);
  text-transform: uppercase;
}
:host(.program-unit) > .title > vi-icon {
  display: none;
}
:host(.program-unit) > .title > vi-icon + span {
  margin-left: var(--theme-h4);
}
:host([is-separator]) {
  cursor: default;
  --separator-height: var(--theme-h2);
}
:host([is-separator]) a {
  height: var(--separator-height);
  pointer-events: none;
  position: relative;
}
:host([is-separator]) a > * {
  display: none;
}
:host([is-separator]) a::after {
  position: absolute;
  inset: calc(var(--separator-height) / 2) var(--theme-h3) 0 calc(var(--theme-h3) + var(--theme-h3) * var(--vi-menu-item-indent-level, 0));
  content: "";
  height: 1px;
  background-color: rgba(255, 255, 255, 0.2);
}</style>

<a class="title" href$="[[href]]" target$="[[target]]" rel$="[[rel]]">
    <paper-ripple></paper-ripple>
    <vi-icon source="[[icon]]"></vi-icon>
    <span class="flex" id="title" on-mouseenter="_titleMouseenter"></span>
</a>

<iron-collapse id="subItems" class="subItems" hidden$="[[!hasItems]]" no-animation="[[filtering]]">
    <dom-repeat items="[[items]]" as="subItem">
        <template>
            <vi-menu-item item="[[subItem]]" items="[[subItem.items]]" level="[[subLevel]]" filter="[[filter]]" filter-parent="[[item]]"></vi-menu-item>
        </template>
    </dom-repeat>
</iron-collapse>`; }
    _updateIndentVariable(level) {
        this.style.setProperty("--vi-menu-item-indent-level", level.toString());
    }
    _computeSubLevel(level) {
        return level + 1;
    }
    _collapseRecursive() {
        if (!this.collapseGroupsOnTap)
            this._setExpand(false);
        Array.prototype.forEach.call(this.shadowRoot.querySelectorAll("vi-menu-item[has-items]"), (item) => item._collapseRecursive());
    }
    _tap(e) {
        if (!this.filtering && this.collapseGroupsOnTap)
            this._collapseRecursive();
        if (!this.item || !this.item.path) {
            e.preventDefault();
            this._setExpand(!this.expand);
        }
        else {
            let item = this.item;
            if (item instanceof ProgramUnit && item.openFirst && item.items)
                item = item.items[0];
            if (item instanceof ProgramUnitItemQuery)
                this.app.cacheRemove(new AppCacheEntryQuery(item.queryId));
            else if (item instanceof ProgramUnitItemPersistentObject)
                this.app.cacheRemove(new AppCacheEntryPersistentObject(item.persistentObjectId, item.persistentObjectObjectId));
            if (this.filtering && this.app.configuration.getSetting("vi-menu.sticky-search", "false").toLowerCase() !== "true")
                this.fire("reset-filter", null);
        }
        e.stopPropagation();
    }
    _expandChanged(expand) {
        this.$.subItems.opened = expand;
    }
    _filterChanged() {
        this.filtering = !String.isNullOrEmpty(this.filter);
        this.hidden = this.filtering && !this._hasMatch(this.item, this.filter.toUpperCase());
    }
    _updateOpened(filtering, item, expand) {
        this.$.subItems.opened = filtering || item === this.programUnit || expand;
    }
    _hasMatch(item, search) {
        if (!item)
            return false;
        if (item.title.toUpperCase().contains(search))
            return true;
        const items = item.items;
        if (items != null && items.filter(i => this._hasMatch(i, search)).length > 0)
            return true;
        return this.filterParent instanceof ProgramUnitItemGroup && this.filterParent.title.toUpperCase().contains(search);
    }
    _programUnitChanged() {
        if (!this.classList.contains("program-unit"))
            return;
        this._setExpand(this.item && (this.item === this.programUnit || this.collapsed));
    }
    _updateItemTitle(item, filter, filtering, collapsed) {
        if (item instanceof ProgramUnit && collapsed)
            this.$.title.textContent = item.title[0];
        else if (filtering && this._hasMatch(item, this.filter.toUpperCase())) {
            const exp = new RegExp(`(${filter})`, "gi");
            this.$.title.innerHTML = item.title.replace(exp, "<span class='style-scope vi-menu-item match'>$1</span>");
        }
        else
            this.$.title.textContent = item.title;
    }
    _computeIcon(item) {
        let prefix;
        if (item instanceof ProgramUnitItemGroup)
            return "ProgramUnitGroup";
        if (item instanceof ProgramUnit) {
            if (item.offset === 2147483647)
                return "ProgramUnit_Vidyano";
            else
                prefix = "ProgramUnit_";
        }
        else if (item instanceof ProgramUnitItemQuery)
            prefix = "ProgramUnitItem_Query_";
        else if (item instanceof ProgramUnitItemPersistentObject)
            prefix = "ProgramUnitItem_PersistentObject_";
        else if (item instanceof ProgramUnitItemUrl)
            prefix = "ProgramUnitItem_Url_";
        if (exists(prefix + item.name))
            return prefix + item.name;
        return null;
    }
    _computedHasItems(item) {
        return (item instanceof ProgramUnit || item instanceof ProgramUnitItemGroup) && item.items.length > 0;
    }
    _computedIsSeparator(item) {
        return item instanceof ProgramUnitItemSeparator;
    }
    _computedHref(item, app) {
        if (!item || !app)
            return undefined;
        if (item instanceof ProgramUnitItemUrl)
            return item.path;
        return (this.item && !(item instanceof ProgramUnitItemGroup)) ? Path.routes.rootPath + this.item.path : undefined;
    }
    _computedTarget(href) {
        return href?.startsWith("http") ? null : "_blank";
    }
    _computedRel(item, href) {
        if (item instanceof ProgramUnitItemUrl && href?.startsWith("http"))
            return "external noopener";
        return null;
    }
    _titleMouseenter() {
        this.$.title.setAttribute("title", this.$.title.offsetWidth < this.$.title.scrollWidth ? this.item.title : "");
    }
    _onServiceBusSelect(sender, message, { name }) {
        if (this.item.name === name) {
            this.findParent(e => {
                if (e instanceof Menu)
                    return true;
                if (e instanceof MenuItem_1 && !e.expand)
                    e._setExpand(true);
            });
        }
    }
    _configure(e) {
        if (!this.item.path || this.item.path.startsWith("Management/"))
            return;
        if (this.item instanceof ProgramUnit) {
            e.detail.push({
                label: `Program unit: ${this.item.name}`,
                icon: "viConfigure",
                action: () => this.app.changePath(`Management/PersistentObject.b53ec1cd-e0b3-480f-b16d-bf33b133c05c/${this.item.name}`),
                subActions: [
                    {
                        label: "Add Query",
                        icon: "Add",
                        action: async () => {
                            const query = await this.service.getQuery("5a4ed5c7-b843-4a1b-88f7-14bd1747458b");
                            if (!query)
                                return;
                            await this.app.showDialog(new SelectReferenceDialog(query));
                            if (!query.selectedItems || query.selectedItems.length === 0)
                                return;
                            await this.service.executeAction("System.AddQueriesToProgramUnit", null, query, query.selectedItems, { Id: this.item.id });
                            document.location.reload();
                        }
                    }
                ]
            });
            e.detail.push();
        }
        else if (this.item instanceof ProgramUnitItem) {
            e.detail.push({
                label: `Program unit item: ${this.item.name}`,
                icon: "viConfigure",
                action: () => this.app.changePath(`Management/PersistentObject.68f7b99e-ce10-4d43-80fb-191b6742d53c/${this.item.name}`)
            });
        }
    }
};
MenuItem = MenuItem_1 = __decorate([
    ConfigurableWebComponent.register({
        properties: {
            item: Object,
            items: Array,
            level: {
                type: Number,
                value: 0
            },
            subLevel: {
                type: Number,
                computed: "_computeSubLevel(level)"
            },
            collapsed: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            programUnit: {
                type: Object,
                observer: "_programUnitChanged"
            },
            hasItems: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computedHasItems(item)"
            },
            isSeparator: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computedIsSeparator(item)"
            },
            icon: {
                type: String,
                computed: "_computeIcon(item)"
            },
            expand: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                observer: "_expandChanged",
                value: false
            },
            filtering: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            filter: {
                type: String,
                observer: "_filterChanged",
                value: ""
            },
            filterParent: Object,
            hidden: {
                type: Boolean,
                reflectToAttribute: true
            },
            href: {
                type: String,
                computed: "_computedHref(item, app)"
            },
            target: {
                type: String,
                computed: "_computedTarget(href)"
            },
            rel: {
                type: String,
                computed: "_computedRel(item, href)"
            },
            collapseGroupsOnTap: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        observers: [
            "_updateItemTitle(item, filter, filtering, collapsed)",
            "_updateIndentVariable(level)",
            "_updateOpened(filtering, item, expand)"
        ],
        listeners: {
            "tap": "_tap",
            "vi:configure": "_configure"
        },
        serviceBusObservers: {
            "vi-menu-item:select": "_onServiceBusSelect"
        }
    })
], MenuItem);

let User = class User extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  border-top: 1px solid #3b484e;
}
:host .username {
  line-height: calc(var(--theme-h2) - 2px);
  background-color: var(--vi-user--background-color, #2b3940);
  margin-bottom: 1px;
  white-space: nowrap;
}
:host .username span {
  padding: 0 2px;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 12px;
}
:host .actions {
  display: flex;
  justify-content: space-around;
  background-color: var(--vi-user--background-color, #2b3940);
}
:host .actions vi-button {
  height: var(--theme-h2) !important;
  line-height: var(--theme-h2) !important;
  cursor: pointer;
  fill: #f0f0f0;
  --vi-icon-height: var(--theme-h4);
  --vi-icon-width: var(--theme-h4);
}
:host .actions vi-button#signIn {
  border-left: 1px solid #3b484e;
  color: white;
}
:host .actions vi-button#signIn > vi-icon {
  height: var(--theme-h1) !important;
  margin-left: var(--theme-h5);
}
:host vi-button {
  width: var(--theme-h1);
  height: var(--theme-h1) !important;
  line-height: var(--theme-h1) !important;
  cursor: pointer;
}
:host vi-button#settings {
  width: var(--theme-h1);
  box-sizing: border-box;
  border-left: 1px solid rgba(255, 255, 255, 0.12);
  background-color: rgba(255, 255, 255, 0.05);
  color: white;
  -moz-transition-property: fill, color, background-color;
  -o-transition-property: fill, color, background-color;
  -webkit-transition-property: fill, color, background-color;
  transition-property: fill, color, background-color;
  -moz-transition-duration: 0.1s;
  -o-transition-duration: 0.1s;
  -webkit-transition-duration: 0.1s;
  transition-duration: 0.1s;
  -moz-transition-timing-function: ease-out;
  -o-transition-timing-function: ease-out;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
:host vi-button#settings:hover {
  background-color: rgba(255, 255, 255, 0.05);
}
:host vi-button#settings:active {
  background-color: rgba(230, 230, 230, 0.05);
}
:host vi-button#settings[disabled] {
  fill: fadeout(white, 50%);
  color: fadeout(white, 50%);
}
:host vi-button > span {
  display: inline-block;
  vertical-align: top;
  line-height: var(--theme-h1);
  height: var(--theme-h1);
}
:host vi-button > vi-icon {
  display: inline-block;
  fill: white;
}

:host-context([is-signed-in]) vi-button {
  cursor: pointer;
}</style>

<div class="username horizontal layout center-justified" hidden$="[[!isSignedIn]]">
    <span>[[userName]]</span>
</div>
<div class="actions">
    <vi-button icon="Invisible" inverse="[[!isAppSensitive]]" title="[[translateMessage('Privacy', isConnected)]]" hidden$="[[!hasSensitive]]" on-tap="_toggleSensitive"></vi-button>
    <dom-if if="[[isSignedIn]]">
        <template>
            <vi-button icon="Profiler" inverse title="[[translateMessage('Profiler', isConnected)]]" hidden$="[[!hasProfiler]]" on-tap="_showProfiler"></vi-button>
            <vi-button icon="UserFeedback" inverse title="[[translateMessage('Feedback', isConnected)]]" hidden$="[[!hasFeedback]]" on-tap="feedback"></vi-button>
            <vi-button icon="Configure" inverse title="[[translateMessage('UserSettings', isConnected)]]" hidden$="[[!hasUserSettings]]" on-tap="userSettings"></vi-button>
            <vi-button icon="SignOut" inverse title="[[translateMessage('SignOut', isConnected)]]" hidden$="[[service.windowsAuthentication]]" on-tap="signOut"></vi-button>
        </template>
    </dom-if>
    <dom-if if="[[!isSignedIn]]">
        <template>
            <vi-button class="flex" id="signIn" icon="SignIn" label="[[signInLabel]]" inverse title="[[signInLabel]]" hidden$="[[isSignedIn]]" on-tap="signIn"></vi-button>
        </template>
    </dom-if>
</div>

<vi-icon name="Profiler">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 11.320312 0 L 11.320312 2.5957031 L 12.96875 3.2636719 L 14.669922 3.2636719 L 14.669922 4.21875 C 11.517402 4.611414 8.6883391 6.0558025 6.5488281 8.1953125 L 8.4902344 10.138672 C 10.518005 8.1101999 13.317629 6.8554688 16.404297 6.8554688 C 22.580085 6.8554688 27.603516 11.877997 27.603516 18.052734 C 27.603516 24.227822 22.580085 29.251953 16.404297 29.251953 C 10.966199 29.251953 6.4223706 25.354195 5.4160156 20.205078 L 7.5839844 20.205078 L 3.9785156 13.960938 L 0.375 20.205078 L 2.625 20.205078 C 3.6625296 26.877913 9.4466838 32 16.404297 32 C 24.095397 32 30.351563 25.743133 30.351562 18.052734 C 30.351913 10.950105 25.012919 5.0739319 18.138672 4.2167969 L 18.138672 3.2636719 L 19.839844 3.2636719 L 21.488281 2.5957031 L 21.488281 0 L 11.320312 0 z M 26.701172 2.7753906 L 24.931641 4.5449219 L 25.273438 5.7988281 L 28.601562 9.125 L 29.855469 9.46875 L 31.625 7.6992188 L 26.701172 2.7753906 z M 16.404297 9.1757812 L 16.404297 18.025391 L 25.001953 18.025391 C 25.001953 13.137232 21.153745 9.1757813 16.404297 9.1757812 z " />
        </g>
    </svg>
</vi-icon>`; }
    _computeSignInLabel(isConnected, collapsed) {
        if (!isConnected)
            return;
        return collapsed ? "" : this.translateMessage("SignIn");
    }
    signIn() {
        this.app.redirectToSignIn();
    }
    signOut() {
        this.service.clearSiteData = true;
        this.app.redirectToSignOut(false);
    }
    async feedback() {
        const po = await this.service.getPersistentObject(null, this.service.application.feedbackId);
        const commentAttr = po.getAttribute("Comment");
        const commentOptions = ["Browser: " + navigator.userAgent, "Vidyano Client: " + version$2];
        const location = window.location.toString();
        if (!location.contains("FromAction/"))
            commentOptions.push("Url: " + location);
        commentAttr.options = commentOptions;
        commentAttr.isValueChanged = true;
        this.service.hooks.onOpen(po, false);
    }
    userSettings() {
        this.app.changePath((this.app.programUnit ? this.app.programUnit.name + "/" : "") + "PersistentObject." + this.service.application.userSettingsId + "/" + this.service.application.userId);
    }
    _toggleSensitive() {
        this.app.sensitive = !this.app.sensitive;
    }
    _showProfiler() {
        this.service.profile = true;
    }
    _signedInChanged() {
        const isSignedIn = this.service.isSignedIn && !this.service.isUsingDefaultCredentials;
        this._setIsSignedIn(isSignedIn);
        this._setUserName(isSignedIn ? this.service.application.friendlyUserName : null);
        this._setHasSensitive(this.service.application && this.service.application.hasSensitive);
        this._setHasFeedback(isSignedIn && !!this.service.application.feedbackId && this.service.application.feedbackId !== "00000000-0000-0000-0000-000000000000");
        this._setHasUserSettings(isSignedIn && !!this.service.application.userSettingsId && this.service.application.userSettingsId !== "00000000-0000-0000-0000-000000000000");
        this._setHasProfiler(isSignedIn && this.service.application.canProfile);
    }
};
User = __decorate([
    WebComponent.register({
        properties: {
            isSignedIn: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            userName: {
                type: String,
                readOnly: true
            },
            signInLabel: {
                type: String,
                computed: "_computeSignInLabel(isConnected, collapsed)"
            },
            hasSensitive: {
                type: Boolean,
                readOnly: true
            },
            hasFeedback: {
                type: Boolean,
                readOnly: true
            },
            hasUserSettings: {
                type: Boolean,
                readOnly: true
            },
            hasProfiler: {
                type: Boolean,
                readOnly: true
            },
            collapsed: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            appSensitive: {
                type: Boolean,
                readOnly: true
            }
        },
        forwardObservers: [
            "_signedInChanged(service.isSignedIn)",
            "_signedInChanged(service.isUsingDefaultCredentials)"
        ],
        sensitive: true
    })
], User);

var Menu_1;
let Menu = Menu_1 = class Menu extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  color: var(--vi-menu-color, #FAFAFA);
  width: var(--vi-menu--expand-width, 17em);
  min-width: var(--vi-menu--expand-width, 17em);
  will-change: width;
}
:host([hide-search]) vi-input-search {
  display: none !important;
}
:host([hide-search]) vi-menu-item:first-of-type {
  margin-top: var(--theme-h5);
}
:host([is-resizing]) #resizer, :host #resizer:hover {
  background-color: #333;
}

#toggleCollapse {
  position: absolute;
  top: 0;
  right: 0;
  background-color: transparent;
  height: var(--theme-h1);
  width: var(--theme-h1);
  fill: rgba(255, 255, 255, 0.5);
}
#toggleCollapse::part(icon) {
  transition: transform 0.3s ease-out;
  --vi-icon-width: var(--theme-h4);
  --vi-icon-height: var(--theme-h4);
}

vi-scroller[vertical][hovering] + #resizer {
  width: calc(var(--theme-h5) / 2);
}

#add {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  padding-left: calc(var(--theme-h4) * 2);
  cursor: pointer;
  font-style: italic;
}
#add:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.instantSearch {
  position: relative;
  margin-bottom: var(--theme-h5);
  padding: var(--theme-h5) 0;
  background-color: rgba(0, 0, 0, 0.2);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}
.instantSearch a {
  cursor: pointer;
  color: var(--vi-menu-color, #FAFAFA);
  line-height: var(--theme-h2);
  padding: 0 var(--theme-h4);
  text-decoration: none;
  overflow: hidden;
  text-overflow: ellipsis;
}
.instantSearch a div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: var(--theme-h5);
}
.instantSearch a span.match {
  color: #FFDD00;
  font-weight: bold;
  pointer-events: none;
}
.instantSearch a span.label {
  font-size: 11px;
  font-weight: 100;
  text-transform: uppercase;
  line-height: var(--theme-h2);
  transform: translateY(1px);
}
.instantSearch a:hover {
  background-color: rgba(0, 0, 0, 0.1);
}
.instantSearch + vi-menu-item {
  margin-top: var(--theme-h5);
}

header, footer {
  display: block;
  line-height: var(--theme-h1);
  flex-shrink: 0;
}

header {
  position: relative;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
header .background {
  background-color: var(--color-dark);
}
header .label {
  display: block;
  font-size: var(--theme-h3);
  line-height: calc(var(--theme-h1) * 2);
  height: calc(var(--theme-h1) * 2);
  white-space: nowrap;
  overflow: hidden;
}

footer {
  overflow: hidden;
}

vi-input-search {
  margin-top: calc(var(--theme-h4) / 2);
  margin-right: calc(var(--theme-h4) - var(--theme-h4) / 2);
  margin-bottom: calc(var(--theme-h4) / 2);
  margin-left: calc(var(--theme-h4) - var(--theme-h4) / 2);
}
vi-input-search::part(input) {
  line-height: var(--theme-h2);
  padding-left: var(--theme-h5);
}
vi-input-search::part(input):focus {
  background-color: white;
  color: #333;
}

#resizer {
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: var(--theme-h5);
  background-color: transparent;
  cursor: ew-resize;
  z-index: 99;
  opacity: 0.5;
  transform: translateX(calc(var(--theme-h5) / 2));
}

.container {
  width: var(--vi-menu--expand-width, 17em);
  opacity: 1;
  transition: opacity 0.22s cubic-bezier(0.2, 0, 0, 1);
  background-color: var(--vi-menu-background, #263238);
}

:host([collapsed]) {
  width: var(--theme-h1);
  min-width: var(--theme-h1);
}
:host([collapsed]) .container {
  transform: translateX(calc(var(--vi-menu--expand-width, 17em) * -1 + var(--theme-h1)));
  transition: all 0.22s cubic-bezier(0.2, 0, 0, 1);
  transition-property: transform, box-shadow;
  transition-delay: 200ms;
  box-shadow: none;
  will-change: transform;
  z-index: 100;
}
:host([collapsed]) .container > main, :host([collapsed]) .container footer, :host([collapsed]) .container header .label {
  opacity: 0;
  transition: opacity 0.22s ease-out;
  transition-delay: 200ms;
  will-change: opacity;
}
:host([collapsed]) #toggleCollapse {
  z-index: 1000;
  background-color: var(--color-dark);
}
:host([collapsed]) #toggleCollapse::part(icon) {
  transform: rotate(180deg);
}
:host([collapsed]:hover) .container, :host([collapsed][search-focused]) .container {
  transform: translateX(0);
  box-shadow: 4px 0px 10px 0px rgba(0, 0, 0, 0.5);
}
:host([collapsed]:hover) .container > main, :host([collapsed]:hover) .container footer, :host([collapsed]:hover) .container header .label, :host([collapsed][search-focused]) .container > main, :host([collapsed][search-focused]) .container footer, :host([collapsed][search-focused]) .container header .label {
  opacity: 1;
}</style>

<div class="container layout vertical fit">
    <header>
        <div class="background layout vertical">
            <div class="label flex">
                <span hidden$="[[hasCustomLabel]]">[[label]]</span>
                <slot name="label" on-slotchange="_onLabelSlotchange"></slot>
            </div>
            <div id="headerElements"></div>
        </div>
        <vi-input-search value="{{filter}}" on-search="_search" focused="{{searchFocused}}"></vi-input-search>
    </header>
    <main class="horizontal layout flex relative">
        <vi-scroller class="flex programUnits" no-horizontal>
            <div class="instantSearch" hidden$="[[!instantSearchResults]]">
                <dom-repeat items="[[instantSearchResults]]" as="item">
                    <template>
                        <a href$="[[item.href]]" class="layout horizontal" on-mouseenter="_instantSearchResultMouseEnter"><div class="flex" inner-h-t-m-l="[[item.match]]"></div><span class="label">[[item.label]]</span></a>
                    </template>
                </dom-repeat>
            </div>
            <dom-repeat items="[[programUnits]]" as="programUnit">
                <template>
                    <vi-menu-item class="program-unit" item="[[programUnit]]" filter="[[filter]]" program-unit="[[activeProgramUnit]]" items="[[programUnit.items]]" collapse-groups-on-tap></vi-menu-item>
                    <dom-if if="[[_isFirstRunProgramUnit(app.service.application, programUnit)]]">
                        <template>
                            <div id="add" on-tap="_add">+ Add menu item</div>
                        </template>
                    </dom-if>
                </template>
            </dom-repeat>
        </vi-scroller>
    </main>
    <footer>
        <slot name="footer"></slot>
        <vi-user></vi-user>
    </footer>
</div>

<vi-button id="toggleCollapse" icon="Menu_Collapse" on-tap="_toggleCollapse"></vi-button>
<div id="resizer" on-track="_onResize"></div>`; }
    connectedCallback() {
        super.connectedCallback();
        this.hideSearch = this.app.configuration.getSetting("vi-menu.hide-search", "false").toLowerCase() === "true";
        if (!Menu_1._minResizeWidth)
            Menu_1._minResizeWidth = this.offsetWidth;
        const menuWidth = parseInt(cookie("menu-width"));
        if (menuWidth)
            this.style.setProperty("--vi-menu--expand-width", `${menuWidth}px`);
    }
    ready() {
        this.collapsed = Boolean.parse(cookie("menu-collapsed"));
        super.ready();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
    }
    _filterChanged() {
        this.filtering = !String.isNullOrEmpty(this.filter);
        if (this.filtering) {
            if (this.instantSearchDelay) {
                const filter = this.filter;
                this._instantSearchDebouncer = Debouncer.debounce(this._instantSearchDebouncer, timeOut.after(this.instantSearchDelay), async () => {
                    const results = await this.service.getInstantSearch(filter);
                    if (filter !== this.filter)
                        return;
                    const exp = new RegExp(`(${filter})`, "gi");
                    this._setInstantSearchResults(results.length > 0 ? results.map(r => {
                        r["match"] = r.breadcrumb.replace(exp, "<span class='style-scope vi-menu match'>$1</span>");
                        r["href"] = `${Path.routes.rootPath}PersistentObject.${r.id}/${r.objectId}`;
                        return r;
                    }) : null);
                });
            }
        }
        else if (this._instantSearchDebouncer) {
            this._instantSearchDebouncer.cancel();
            this._instantSearchDebouncer = null;
            this._setInstantSearchResults(null);
        }
    }
    _search() {
        if (this.collapsed && this.filter)
            Popup.closeAll();
        if (!this.filtering || !this.hasGlobalSearch)
            return;
        this.app.changePath(this.app.getUrlForPersistentObject(this.service.application.globalSearchId, this.filter));
        this.filter = "";
    }
    _computeHasGlobalSearch(globalSearchId) {
        return globalSearchId !== "00000000-0000-0000-0000-000000000000";
    }
    _computeInstantSearchDelay(application) {
        return application.getAttributeValue("InstantSearchDelay");
    }
    _computeCollapsedWithGlobalSearch(collapsed, hasGlobalSearch) {
        return collapsed && hasGlobalSearch;
    }
    _toggleCollapse() {
        this.collapsed = !this.collapsed;
        cookie("menu-collapsed", String(this.collapsed));
    }
    _hasGroupItems(programUnitItems) {
        return !!programUnitItems && programUnitItems.some(item => item instanceof ProgramUnitItemGroup);
    }
    _programUnitItemsCount(programUnitItems) {
        return !!programUnitItems ? programUnitItems.length : 0;
    }
    _focusSearch() {
        const inputSearch = this.shadowRoot.querySelector("#collapsedInputSearch");
        this._focusElement(inputSearch);
    }
    _catchInputSearchTap(e) {
        e.stopPropagation();
    }
    _resetFilter(e) {
        this.filter = "";
    }
    _onResize(e) {
        if (e.detail.state === "start") {
            this.app.isTracking = true;
            this._resizeWidth = Math.max(Menu_1._minResizeWidth, this.offsetWidth);
            this.style.setProperty("--vi-menu--expand-width", `${this._resizeWidth}px`);
            this._setIsResizing(true);
        }
        else if (e.detail.state === "track") {
            this._resizeWidth = Math.max(Menu_1._minResizeWidth, this._resizeWidth + e.detail.ddx);
            this.style.setProperty("--vi-menu--expand-width", `${this._resizeWidth}px`);
        }
        else if (e.detail.state === "end") {
            cookie("menu-width", String(this._resizeWidth));
            this._setIsResizing(false);
            this.app.isTracking = false;
        }
    }
    _onLabelSlotchange(e) {
        const slot = e.target;
        this._setHasCustomLabel(slot?.assignedElements({ flatten: true })?.length > 0);
    }
    _isFirstRunProgramUnit(application, programUnit) {
        if (application && application.programUnits.length === 2) {
            if (application.programUnits[0] === programUnit && programUnit.name === "Home" && programUnit.items.length === 0)
                return application.programUnits[1].path.contains("e683de37-2b39-45e9-9522-ef69c3f0287f");
        }
        return false;
    }
    async _add(e) {
        const query = await this.service.getQuery("5a4ed5c7-b843-4a1b-88f7-14bd1747458b");
        if (!query)
            return;
        if (query.items.length === 0) {
            this.app.showMessageDialog({
                title: "Add menu item",
                message: "Your application contains no persistent objects.\n\nFor more information [Getting Started](https://vidyano.com/gettingstarted)",
                actions: [this.translateMessage("OK")],
                actionTypes: ["Danger"],
                rich: true
            });
            return;
        }
        const dialog = new SelectReferenceDialog(query);
        this.app.showDialog(dialog).then(async () => {
            if (!query.selectedItems || query.selectedItems.length === 0)
                return;
            try {
                await this.service.executeAction("System.AddQueriesToProgramUnit", null, query, query.selectedItems, { Id: this.service.application.programUnits[0].id });
                document.location.reload();
            }
            catch (e) {
                this.app.showMessageDialog({
                    title: "Add menu item",
                    message: e,
                    actions: [this.translateMessage("OK")],
                    actionTypes: ["Danger"]
                });
            }
        });
    }
    _instantSearchResultMouseEnter(e) {
        const anchor = e.target;
        const div = anchor.querySelector("div");
        anchor.setAttribute("title", div.offsetWidth < div.scrollWidth ? e["model"].item.breadcrumb : "");
    }
};
Menu = Menu_1 = __decorate([
    WebComponent.register({
        properties: {
            label: String,
            activeProgramUnit: Object,
            programUnits: Array,
            collapsed: {
                type: Boolean,
                reflectToAttribute: true
            },
            collapsedWithGlobalSearch: {
                type: Boolean,
                computed: "_computeCollapsedWithGlobalSearch(collapsed, hasGlobalSearch)"
            },
            hasCustomLabel: {
                type: Boolean,
                readOnly: true,
            },
            hasGlobalSearch: {
                type: Boolean,
                computed: "_computeHasGlobalSearch(app.service.application.globalSearchId)"
            },
            instantSearchDelay: {
                type: Number,
                computed: "_computeInstantSearchDelay(app.service.application)"
            },
            instantSearchResults: {
                type: Array,
                readOnly: true,
                value: null
            },
            filter: {
                type: String,
                observer: "_filterChanged"
            },
            filtering: {
                type: Boolean,
                reflectToAttribute: true
            },
            currentProgramUnit: Object,
            isResizing: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            hideSearch: {
                type: Boolean,
                reflectToAttribute: true
            },
            searchFocused: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        listeners: {
            "reset-filter": "_resetFilter"
        }
    })
], Menu);

const Keys = {
    Backspace: "Backspace",
    Tab: "Tab",
    Enter: "Enter",
    Shift: "Shift",
    Control: "Control",
    Alt: "Alt",
    Pause: "Pause",
    Break: "Break",
    CapsLock: "CapsLock",
    Escape: "Escape",
    PageUp: "PageUp",
    PageDown: "PageDown",
    End: "End",
    Home: "Home",
    ArrowLeft: "ArrowLeft",
    ArrowUp: "ArrowUp",
    ArrowRight: "ArrowRight",
    ArrowDown: "ArrowDown",
    Comma: ",",
    Subtract: "-",
    Period: ".",
    Zero: "0",
    One: "1",
    Two: "2",
    Three: "3",
    Four: "4",
    Five: "5",
    Six: "6",
    Seven: "7",
    Eight: "8",
    Nine: "9"
};

let SignIn = class SignIn extends WebComponent {
    static get template() { return html$3 `<style>@font-face {
  font-family: "viBrands";
  src: url(data:font/truetype;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SB4gAAAC8AAAAYGNtYXDVZ9RhAAABHAAAAGxnYXNwAAAAEAAAAYgAAAAIZ2x5ZsRSMBQAAAGQAAAD1GhlYWQRp15dAAAFZAAAADZoaGVhCHQEfAAABZwAAAAkaG10eBqyAQ0AAAXAAAAAJGxvY2ECjAOOAAAF5AAAABRtYXhwAA4AcgAABfgAAAAgbmFtZZlKCfsAAAYYAAABhnBvc3QAAwAAAAAHoAAAACAAAwPIAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADqlgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAUAAAABAAEAADAAAAAQAg6QHqiOqQ6pb//f//AAAAAAAg6QDqiOqQ6pb//f//AAH/4xcEFX4VdxVyAAMAAQAAAAAAAAAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAAEAAD/wAQAA8AAAwAHAAsADwAAASERIQEhESEBIREhASERIQHn/hkB5wIZ/hkB5/3n/hkB5wIZ/hkB5wHZAef+GQHn/AAB5/4ZAecABAAD/8QEsgO8ABsAMwBLAG8AAAEqASM4ASMxIgcOAQcGFxYXHgEXFjM+AScuAScDJicuAScmBwYXHgEXFhceARcWNjc2JicRPgEnLgEHIgYHBgcOAQcGFxY3PgE3NjcBDgEjIiYjJgYHBhYXHgEzMjY3ATYmJyYGBwMjAy4BBw4BFwEEggEEAgERPT2CMTIGByUmaz4+NxcdAgEbFHAwODhkJSYLDCUlaTIzDwIEARMnCw0IEhIIDQsnEwEEAg8zMmklJQwLJiVkODgw/QAcQT0GHQITIQUGFxYQIA9wYyUBIwgYGBksCc0D1wswGBkXCAEPAfQGBhQNDA0NCQkNAwMEJRgVHgT+oRobGykKCggIIyNQIyMIAQIBBQ0SFC4PAkEOLxQRDgYCAQkjIlEiIwgICgooGxsb/f5RTQIBFxQWKQYDAnVeAtYZLggIFxf94wIhFxQJCjAZ/WsAAQAK/8AD9gPAADoAAAEVIQYHDgEHBiMiJy4BJyY1NDc+ATc2MzIWFzcmJy4BJyYjIgcOAQcGFRQXHgEXFjMyNz4BNzY1NCYnAgoBIwUREkQ2NUxBOjpWGRkZGVY6OkFLZRyLIScmVi8wNGpdXYspKCgpi11dam9bWoEkIwUDAgmvHSYmRBgYGRpXOztDQzs7VxoZMxyGHxkZIwkJKCiLXl1qal1eiygoJSWFXFxtGSkTAAAAAQEA/8ADAAPAABcAAAEzNSMiBw4BBwYdASMVMxEzETM3IzU0NgJgoKAuKSk9ERKAgMCgIMATAwDAEhE9KSkuYMD+AAIAwGANEwAAAAEAAAAABAADQABPAAABDgEHPgE3DgEHLgEjIgcOAQcGFRQWFyYnLgEnJicOARUUFhcuASccARUUFhcOASMiJiceARcOASMiJicWFx4BFxYzMjc+ATc2NTQmNT4BNwQAHD0gITAMH0MkHFAtKycmORARAwJBPT5uMDAnDQ8zKhkxFWFIDRwPChMKFGtFNoVKDRkMIyYmUSsrLJFvcJgnJwEfNRUC3g0RAxM8JRIaBx4kEBE5JiYsDBgMAxEROScnMBc2HTZcHQEODAEBAUx0DgQDAgE+UgIqMAIBFhIRGAcGNjesamtoBw0HFjcgAAAAAAEAAAAAAABLNQeLXw889QALBAAAAAAA1uuM8AAAAADW64zwAAD/wASyA8AAAAAIAAIAAAAAAAAAAQAAA8D/wAAABLIAAAAABLIAAQAAAAAAAAAAAAAAAAAAAAkEAAAAAAAAAAAAAAACAAAABAAAAASyAAMEAAAKBAABAAQAAAAAAAAAAAoAFAAeAEQA8gFMAXIB6gABAAAACQBwAAQAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEABwAAAAEAAAAAAAIABwBgAAEAAAAAAAMABwA2AAEAAAAAAAQABwB1AAEAAAAAAAUACwAVAAEAAAAAAAYABwBLAAEAAAAAAAoAGgCKAAMAAQQJAAEADgAHAAMAAQQJAAIADgBnAAMAAQQJAAMADgA9AAMAAQQJAAQADgB8AAMAAQQJAAUAFgAgAAMAAQQJAAYADgBSAAMAAQQJAAoANACkaWNvbW9vbgBpAGMAbwBtAG8AbwBuVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwaWNvbW9vbgBpAGMAbwBtAG8AbwBuaWNvbW9vbgBpAGMAbwBtAG8AbwBuUmVndWxhcgBSAGUAZwB1AGwAYQByaWNvbW9vbgBpAGMAbwBtAG8AbwBuRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==) format("truetype");
}
:host {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  position: relative;
  --vi-sign-in-persistent-object-width-base: 400px;
}
:host #background {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center center;
  overflow: hidden;
}
:host #background .default {
  background: linear-gradient(45deg, var(--color-dark) 0%, var(--color) 100%);
}
:host #background .default svg {
  height: 100%;
  width: 100%;
}
:host #background .default:not(:nth-child(2)) {
  display: none;
}
:host header {
  padding: var(--theme-h2) var(--theme-h2) var(--theme-h4) var(--theme-h2);
}
:host header h1 {
  margin: 0;
  color: var(--color);
  text-shadow: 2px 2px #eee;
}
:host header h1:empty {
  display: none;
}
:host header #logo:not([src]) {
  display: none;
}
:host .dialog {
  display: flex;
  flex-direction: column;
  position: relative;
  background-color: white;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12), 0 1px 5px 0 rgba(0, 0, 0, 0);
}
:host .dialog .loader {
  height: 4px;
  width: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  overflow: hidden;
  background-color: #ddd;
}
:host .dialog .loader:before {
  display: block;
  position: absolute;
  content: "";
  left: -200px;
  width: 200px;
  height: 4px;
  background-color: var(--color-dark);
  animation: loading 2s linear infinite;
}
:host .dialog main {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host .dialog main section {
  padding: 0 var(--theme-h2) var(--theme-h2) var(--theme-h2);
}
:host .dialog main section:not(.active) {
  display: none !important;
}
:host .dialog main section.username input {
  margin: var(--theme-h3) 0 0 0;
}
:host .dialog main section.password input, :host .dialog main section.password h1, :host .dialog main section.twofactor input, :host .dialog main section.twofactor h1 {
  margin: var(--theme-h3) 0 0 0;
}
:host .dialog main section.password vi-checkbox, :host .dialog main section.twofactor vi-checkbox {
  margin-top: var(--theme-h5);
  line-height: var(--theme-h2);
}
:host .dialog main section.register vi-persistent-object-tab-presenter, :host .dialog main section.initial vi-persistent-object-tab-presenter {
  max-height: 50vh;
}
:host .dialog main h1, :host .dialog main h2, :host .dialog main h3 {
  margin: 0;
}
:host .dialog main h1, :host .dialog main h2 {
  font-weight: 300;
  font-size: 1.5rem;
}
:host .dialog main input {
  box-sizing: border-box;
  padding: var(--theme-h5);
  border: 1px solid #ddd;
  outline: none;
  width: 100%;
}
:host .dialog main input:focus {
  border-color: var(--color-light);
}
:host .dialog main input[error] {
  border-color: var(--colors-red-700);
  background-color: var(--colors-red-50);
}
:host .dialog main .description {
  display: block;
  margin-top: var(--theme-h5);
  color: #757575;
  font-size: 12px;
  line-height: 1.3333;
}
:host .dialog main .description:empty {
  display: none;
}
:host .dialog main .actions {
  padding-top: var(--theme-h3);
}
:host .dialog main .actions vi-button {
  padding: 0 var(--theme-h3);
  line-height: var(--theme-h2);
}
:host .dialog main .actions vi-button[inverse] {
  padding: 0 var(--theme-h5);
  margin-left: calc(var(--theme-h5) * -1);
}
:host .dialog main .user {
  margin: var(--theme-h5) calc(var(--theme-h2) * -1) 0 calc(var(--theme-h2) * -1);
  padding: 0 var(--theme-h2);
  background-color: #eee;
  gap: var(--theme-h5);
}
:host .dialog main .user h3, :host .dialog main .user vi-button {
  font-weight: 300;
  font-size: 13px;
  line-height: var(--theme-h3);
}
:host .dialog main .user vi-icon {
  fill: #555;
  --vi-icon-height: 12px;
}
:host .dialog main .splitter {
  position: relative;
  text-align: center;
  padding: var(--theme-h3) 0;
}
:host .dialog main .splitter::before {
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background-color: var(--theme-light-border);
  content: " ";
}
:host .dialog main .splitter span {
  position: relative;
  background-color: white;
  padding: 0 var(--theme-h4);
}
:host .dialog main .brands {
  display: flex;
  flex-direction: column;
  align-items: center;
}
:host .dialog main .brands .brand {
  display: flex;
  flex-direction: row;
  line-height: var(--theme-h1);
  width: 300px;
  padding: 0;
}
:host .dialog main .brands .brand:not(:first-of-type) {
  margin-top: var(--theme-h4);
}
:host .dialog main .brands .brand span {
  flex: 1;
  min-height: 0;
  min-width: 0;
  border-left: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0 var(--theme-h5);
}
:host .dialog main .brands .brand .logo {
  font-family: "viBrands";
  text-align: center;
  width: var(--theme-h1);
  height: var(--theme-h1);
  color: white;
  font-size: 16px;
}
:host .dialog main .brands .brand[brand=facebook] {
  background-color: #3c66c4;
}
:host .dialog main .brands .brand[brand=facebook] .logo:before {
  content: "\ea90";
}
:host .dialog main .brands .brand[brand=google] {
  background-color: #cf4332;
}
:host .dialog main .brands .brand[brand=google] .logo:before {
  content: "\ea88";
}
:host .dialog main .brands .brand[brand=microsoft] {
  background-color: #525252;
}
:host .dialog main .brands .brand[brand=microsoft] .logo:before {
  content: "\e900";
}
:host .dialog main .brands .brand[brand=twitter] {
  background-color: #33ccff;
}
:host .dialog main .brands .brand[brand=twitter] .logo:before {
  content: "\ea96";
}
:host .dialog main .brands .brand[brand=yammer] {
  background-color: #0193be;
}
:host .dialog main .brands .brand[brand=yammer] .logo:before {
  content: "\e901";
}
:host .dialog main vi-persistent-object-tab-presenter {
  margin: var(--theme-h3) calc(var(--theme-h4) * -1) 0 calc(var(--theme-h4) * -1);
  min-height: calc(var(--theme-h2) * 3);
  max-height: 80vh;
}
:host .dialog main vi-persistent-object-tab-presenter > vi-persistent-object-tab {
  position: static;
  width: 100%;
}
:host .dialog footer {
  position: relative;
  color: white;
  padding: var(--theme-h4);
  box-shadow: inset 0px 6px 4px 0px rgba(0, 0, 0, 0.15);
}
:host .dialog footer[type=error], :host .dialog footer[type=Error], :host .dialog footer[type="0"] {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-error);
  fill: var(--theme-color-error);
}
:host .dialog footer[type=notice], :host .dialog footer[type=Notice], :host .dialog footer[type="1"] {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-notice);
  fill: var(--theme-color-notice);
}
:host .dialog footer[type=ok], :host .dialog footer[type=OK], :host .dialog footer[type="2"] {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-ok);
  fill: var(--theme-color-ok);
}
:host .dialog footer[type=warning], :host .dialog footer[type=Warning], :host .dialog footer[type="3"] {
  border-bottom-color: rgba(0, 0, 0, 0.1);
  background-color: var(--theme-color-warning);
  fill: var(--theme-color-warning);
}
:host([initialization-error]) vi-scroller {
  display: none;
}
:host #sideHost {
  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);
  overflow: hidden;
}
:host vi-scroller #side {
  padding: var(--theme-h3);
}
:host vi-scroller #side h1 {
  font-size: 36px;
  text-transform: lowercase;
  display: block;
  font-weight: normal;
  margin: var(--theme-h3) 0 var(--theme-h1) 0;
  color: var(--color);
}
:host vi-scroller #side h1:not(:first-child) {
  display: none;
}
:host vi-scroller #side h2 {
  margin: var(--theme-h1) 0;
  font-size: 14px;
  font-weight: normal;
  color: #888;
}
:host vi-scroller #side main {
  list-style: none;
  padding: 0;
}
:host ::slotted([slot=sign-in-footer]) {
  max-width: 100vw;
  width: 400px;
}
:host([is-desktop]) .dialog, :host([is-tablet]) .dialog {
  width: var(--vi-sign-in-persistent-object-width, var(--vi-sign-in-persistent-object-width-base));
  max-width: 90vw;
  min-height: 360px;
}

/* Extra small devices (phones, less than 768px) */
@media (max-width: 767px) {
  :host #image {
    display: none;
  }
  :host #sideHost {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  ::slotted([slot=sign-in-footer]) {
    width: auto !important;
  }
}
@keyframes loading {
  from {
    left: -200px;
    width: 30%;
  }
  50% {
    width: 30%;
  }
  70% {
    width: 70%;
  }
  80% {
    left: 50%;
  }
  95% {
    left: 120%;
  }
  to {
    left: 100%;
  }
}</style>

<div id="background">
    <slot name="sign-in-background"></slot>
    <div class="default fit">
        <svg xmlns="https://www.w3.org/2000/svg" viewBox="0 0 1440 810" preserveAspectRatio="xMinYMin slice" aria-hidden="true">
            <g>
                <path fill="#ffffff" fill-opacity="0.035" d="M441.8,1526c307-432.2,221.8-1019.9-190.3-1312.6s-995-179.6-1302,252.6L441.8,1526z" />
                <path fill="#ffffff" fill-opacity="0.035" d="M697.5,1707.6C1109.7,1127.3,995.3,338.3,442-54.8S-894-295.9-1306.2,284.4L697.5,1707.6z" />
                <path fill="#ffffff" fill-opacity="0.035" d="M972.6,1903.1C1498.1,1163.4,1352.3,157.6,647-343.3S-1055.9-650.8-1581.3,88.9L972.6,1903.1z" />
            </g>
            <g>
                <path fill="#ffffff" fill-opacity="0.035" d="M2882.7,678.3C2470,345.6,1878.2,394.9,1561,788.4s-239.8,982.3,173,1315L2882.7,678.3z" />
                <path fill="#ffffff" fill-opacity="0.035" d="M3079.5,434.1C2525.3-12.6,1730.8,53.6,1304.9,582s-322,1318.9,232.2,1765.6L3079.5,434.1z" />
                <path fill="#ffffff" fill-opacity="0.035" d="M3291.3,171.4c-706.4-569.4-1719.2-485-2262.1,188.5s-410.4,1681.1,296,2250.5L3291.3,171.4z" />
            </g>
        </svg>
    </div>
</div>
<div class="dialog">
    <div class="loader" hidden$="[[!isBusy]]"></div>
    <header>
        <dom-if if="[[!logo]]">
            <template>
                <h1>[[label]]</h1>
            </template>
        </dom-if>
        <img id="logo" src$="[[logo]]" />
    </header>
    <main>
        <section class="username">
            <h1>[[translateMessage("SignInTo", label, translations)]]</h1>
            <dom-if if="[[hasVidyano]]">
                <template>
                    <input id="username" autocomplete="username" type="text" placeholder="[[translations.UserName]]" value="{{userName::input}}" on-keydown="_keydown" disabled$="[[isBusy]]" />
                    <label class="description">[[description]]</label>
                    <div class="actions layout horizontal-reverse justified">
                        <vi-button label="[[translations.Next]]" on-tap="_authenticate" disabled$="[[!canAuthenticate]]"></vi-button>
                        <dom-if if="[[hasRegister]]">
                            <template>
                                <vi-button label="[[translations.Register]]" inverse on-tap="_register" disabled$="[[isBusy]]"></vi-button>
                            </template>
                        </dom-if>
                    </div>
                    <dom-if if="[[hasOther]]">
                        <template>
                            <div class="splitter">
                                <span>[[translations.Or]]</span>
                            </div>
                        </template>
                    </dom-if>
                </template>
            </dom-if>
            <dom-if if="[[hasOther]]">
                <template>
                    <div class="brands">
                        <dom-repeat items="[[_getProviders(service.providers)]]" as="provider">
                            <template>
                                <vi-button class="brand" brand$="[[provider.name]]" disabled$="[[isBusy]]" on-tap="_authenticateExternal">
                                    <div class="logo"></div>
                                    <span>[[translations.SignInUsing]] [[provider.parameters.label]]</span>
                                </vi-button>
                            </template>
                        </dom-repeat>
                    </div>
                </template>
            </dom-if>
        </section>
        <section class="password">
            <div class="layout horizontal user wrap">
                <vi-icon source="Action_viImpersonate"></vi-icon>
                <h3>[[userName]]</h3>
                <vi-button label="([[translations.NotYou]])" inverse on-tap="_back" disabled$="[[isBusy]]"></vi-button>
            </div>
            <h1>[[translations.EnterPassword]]</h1>
            <input id="password" autocomplete="current-password" type="password" placeholder="[[translations.Password]]" value="{{password::input}}" on-keydown="_keydown" disabled$="[[isBusy]]" />
            <vi-checkbox label="[[translations.StaySignedIn]]" disabled$="[[isBusy]]" checked="{{staySignedIn}}"></vi-checkbox>
            <div class="actions layout horizontal-reverse justified">
                <vi-button label="[[translations.Next]]" on-tap="_authenticate" disabled$="[[!canAuthenticate]]"></vi-button>
                <dom-if if="[[hasForgot]]">
                    <template>
                        <vi-button label="[[translations.ForgotPassword]]" inverse on-tap="_forgot" disabled$="[[isBusy]]"></vi-button>
                    </template>
                </dom-if>
            </div>
        </section>
        <section class="twofactor">
            <div class="layout horizontal user wrap">
                <vi-icon source="Action_viImpersonate"></vi-icon>
                <h3>[[userName]]</h3>
                <vi-button label="([[translations.NotYou]])" inverse on-tap="_back" disabled$="[[isBusy]]"></vi-button>
            </div>
            <h1>[[translations.EnterTwoFactorCode]]</h1>
            <input id="twofactor" autocomplete="one-time-code" type="text" placeholder="[[translations.TwoFactorCode]]" value="{{twoFactorCode::input}}" on-keydown="_keydown" disabled$="[[isBusy]]" />
            <vi-checkbox label="[[translations.StaySignedIn]]" disabled$="[[isBusy]]" checked="{{staySignedIn}}"></vi-checkbox>
            <div class="actions layout horizontal-reverse justified">
                <vi-button label="[[translations.SignIn]]" on-tap="_authenticate" disabled$="[[!canAuthenticate]]"></vi-button>
                <vi-button label="[[translations.Previous]]" on-tap="_back" disabled$="[[isBusy]]" inverse></vi-button>
            </div>
        </section>
        <section class="register">
            <h1>[[register.breadcrumb]]</h1>
            <vi-persistent-object-tab-presenter tab="[[register.tabs.0]]" on-vi-persistent-object-tab-inner-size-changed="_tabInnerSizeChanged"></vi-persistent-object-tab-presenter>
            <div class="actions layout horizontal-reverse justified">
                <vi-button label="[[translations.RegisterSave]]" on-tap="_register" disabled$="[[register.isBusy]]"></vi-button>
                <vi-button label="[[translations.SignIn]]" on-tap="_back" disabled$="[[isBusy]]" inverse></vi-button>
            </div>
        </section>
        <section class="initial">
            <dom-if if="[[initial]]">
                <template>
                    <h1>[[initial.breadcrumb]]</h1>
                    <vi-persistent-object-tab-presenter tab="[[initial.tabs.0]]" on-vi-persistent-object-tab-inner-size-changed="_tabInnerSizeChanged"></vi-persistent-object-tab-presenter>
                    <div class="actions layout horizontal-reverse justified">
                        <vi-button label="[[_getInitialSaveLabel(initial)]]" on-tap="_finishInitial" disabled$="[[initial.isBusy]]"></vi-button>
                        <vi-button label="[[translations.SignOut]]" on-tap="_back" disabled$="[[isBusy]]" inverse></vi-button>
                    </div>
                </template>
            </dom-if>
        </section>
    </main>
    <footer hidden$="[[!notification]]" type$="[[notification.type]]">
        <span>[[notification.text]]</span>
    </footer>
</div>
<slot name="sign-in-footer"></slot>`; }
    async _activate(e) {
        const { parameters } = e.detail;
        if (parameters.stateOrReturnUrl) {
            if (/^(register)$/i.test(parameters.stateOrReturnUrl)) {
                this._setReturnUrl(decodeURIComponent(parameters.returnUrl || ""));
                this._setNotification(null);
                this._setIsBusy(true);
                try {
                    const registerService = new Service(this.service.serviceUri, this.service.hooks, true);
                    await registerService.initialize(true);
                    registerService.staySignedIn = false;
                    await registerService.signInUsingCredentials(this.service.providers.Vidyano.registerUser, "");
                    const register = await registerService.getPersistentObject(null, this.service.providers.Vidyano.registerPersistentObjectId, undefined, true);
                    register.beginEdit();
                    register.stateBehavior = "StayInEdit";
                    this._setRegister(register);
                    this.step = "register";
                }
                catch (error) {
                    this._error(error);
                }
                finally {
                    this._setIsBusy(false);
                    return;
                }
            }
            else {
                if (this.service.initial) {
                    this._setReturnUrl(decodeURIComponent(parameters.returnUrl || ""));
                    this.service.initial.beginEdit();
                    this.service.initial.stateBehavior = "StayInEdit";
                    this._setInitial(this.service.initial);
                    this.step = "initial";
                    return;
                }
            }
        }
        this._setReturnUrl(decodeURIComponent(parameters.returnUrl || parameters.stateOrReturnUrl || ""));
        this.userName = (this.service.userName !== this.service.defaultUserName && this.service.userName !== this.service.registerUserName ? this.service.userName : "") || "";
        this.staySignedIn = cookie("staySignedIn", { force: true }) === "true";
        this._setHasVidyano(!!this.service.providers.Vidyano);
        this._setHasOther(Object.keys(this.service.providers).length > 1 || !this.hasVidyano);
        if (this.hasVidyano) {
            this._setHasForgot(this.service.providers.Vidyano.forgotPassword || false);
            this._setHasRegister(!!this.service.providers.Vidyano.registerUser && !!this.service.providers.Vidyano.registerPersistentObjectId);
        }
        if (this.hasVidyano)
            this._setDescription(this.service.providers.Vidyano.description || "");
        if (this.service.isSignedIn) {
            microTask.run(() => this.app.redirectToSignOut());
            e.preventDefault();
            return;
        }
        if (this.service.windowsAuthentication) {
            e.preventDefault();
            await this.service.signInUsingCredentials("", "");
            this.app.changePath(this.returnUrl);
            return;
        }
        else if (this.service.providers && Object.keys(this.service.providers).length === 1 && !this.service.providers.Vidyano) {
            this._authenticateExternal(Object.keys(this.service.providers)[0]);
            return;
        }
        if (!this.service.isSignedIn) {
            if (this.userName && this.service.providers.Vidyano.getCredentialType) {
                this._setIsBusy(true);
                this.step = "username";
                try {
                    const credentialType = await this.service.getCredentialType(this.userName);
                    if (credentialType.redirectUri) {
                        setTimeout(() => {
                            cookie("returnUrl", this.returnUrl, { expires: 1, force: true });
                            document.location.assign(credentialType.redirectUri);
                        }, 500);
                        return;
                    }
                    this._setIsBusy(false);
                }
                catch (error) {
                    this._error(error);
                    this._setIsBusy(false);
                }
            }
            this.step = this.hasVidyano && this.userName ? "password" : "username";
        }
    }
    _deactivate() {
        this.password = this.twoFactorCode = "";
    }
    _back() {
        if (this.step === "password") {
            this.userName = "";
            this.step = "username";
        }
        else if (this.step === "twofactor") {
            this.password = this.twoFactorCode = "";
            this.step = "password";
        }
        else if (this.step === "register") {
            this.app.changePath("SignIn" + (this.returnUrl ? `/${this.returnUrl}` : ""));
            this._setRegister(null);
        }
        else if (this.step === "initial") {
            this.app.changePath("SignOut/SignIn" + (this.returnUrl ? `/${this.returnUrl}` : ""));
            this._setInitial(this.service["_initial"] = null);
        }
        this._setNotification(null);
    }
    _stepChanged(step, oldStep) {
        if (oldStep)
            this.shadowRoot.querySelector(`section.${oldStep}`).classList.remove("active");
        if (step === "register")
            this._updateWidth(this.register);
        else if (step === "initial")
            this._updateWidth(this.service.initial);
        else
            this._updateWidth(null);
        this.shadowRoot.querySelector(`section.${step}`).classList.add("active");
        flush$1();
        this._focusElement(step);
    }
    _isStep(step) {
        return this.step === step;
    }
    async _register() {
        if (this.step !== "register") {
            this.app.changePath("SignIn/Register", false);
            return;
        }
        try {
            await this.register.save();
            this._setNotification(this.register.notification ? {
                text: this.register.notification,
                type: this.register.notificationType
            } : null);
            this.userName = "";
            this.app.changePath("SignIn", true);
        }
        catch (error) {
            this._setNotification({
                text: error,
                type: "Error"
            });
        }
    }
    async _finishInitial() {
        try {
            this._setIsBusy(true);
            await this.initial.save();
            this._setNotification(this.initial.notification ? {
                text: this.initial.notification,
                type: this.initial.notificationType
            } : null);
            this._setInitial(this.service["_initial"] = null);
            this.app.changePath(this.returnUrl || "", true);
        }
        catch (error) {
            this._setNotification({
                text: error,
                type: "Error"
            });
        }
        finally {
            this._setIsBusy(false);
        }
    }
    _keydown(e) {
        if (e.key === Keys.Enter) {
            switch (this.step) {
                case "username": {
                    if (!String.isNullOrEmpty(this.userName))
                        this._authenticate();
                    break;
                }
                case "password": {
                    if (!String.isNullOrEmpty(this.password))
                        this._authenticate();
                    break;
                }
                case "twofactor": {
                    if (!String.isNullOrEmpty(this.twoFactorCode))
                        this._authenticate();
                    break;
                }
            }
        }
    }
    _computeCanAuthenticate(isBusy, userName, password, twoFactorCode) {
        if (isBusy)
            return false;
        if (this.step === "username")
            return !String.isNullOrEmpty(userName);
        if (this.step === "password")
            return !String.isNullOrEmpty(password);
        if (this.step === "twofactor")
            return !String.isNullOrEmpty(twoFactorCode);
        return false;
    }
    async _authenticate() {
        this._setIsBusy(true);
        try {
            if (this.step === "username") {
                if (this.service.providers.Vidyano.getCredentialType) {
                    const credentialType = await this.service.getCredentialType(this.userName);
                    if (credentialType.redirectUri) {
                        setTimeout(() => {
                            cookie("returnUrl", this.returnUrl, { expires: 1, force: true });
                            document.location.assign(credentialType.redirectUri);
                        }, 500);
                        return;
                    }
                }
                this.step = "password";
            }
            else if (this.step === "password") {
                try {
                    await this.service.signInUsingCredentials(this.userName, this.password, this.staySignedIn);
                    this.app.changePath(decodeURIComponent(this.returnUrl || ""));
                }
                catch (e) {
                    if (e === "Two-factor authentication enabled for user.") {
                        this.step = "twofactor";
                        this._setNotification(null);
                    }
                    else
                        throw e;
                }
            }
            else if (this.step === "twofactor") {
                await this.service.signInUsingCredentials(this.userName, this.password, this.twoFactorCode, this.staySignedIn);
                this.app.changePath(decodeURIComponent(this.returnUrl || ""));
            }
            this._setIsBusy(false);
        }
        catch (error) {
            this._error(error);
            this._setIsBusy(false);
        }
    }
    _authenticateExternal(e) {
        const key = typeof e === "string" ? e : e.model.provider.key;
        this._setIsBusy(true);
        setTimeout(() => {
            cookie("returnUrl", this.returnUrl, { expires: 1, force: true });
            this.service.signInExternal(key);
        }, 500);
    }
    async _forgot() {
        this._setIsBusy(true);
        try {
            const result = await this.service.forgotPassword(this.userName);
            this._setNotification({
                text: result.notification,
                type: result.notificationType
            });
            this._focusElement(this.$.password);
        }
        catch (error) {
            this._error(error);
        }
        finally {
            this._setIsBusy(false);
        }
    }
    _getInitialSaveLabel(po) {
        if (!po)
            return null;
        let label;
        const endEdit = po.getAction("EndEdit") || po.getAction("Save");
        if (endEdit)
            label = endEdit.displayName;
        return label || this.translateMessage("Save");
    }
    _error(error) {
        this._setNotification(error ? {
            text: error,
            type: "Error"
        } : null);
    }
    _getProviders(providers) {
        return Object.keys(providers).filter(key => key !== "Vidyano").map(key => {
            return {
                key: key,
                name: key.toLowerCase(),
                parameters: this.service.providers[key]
            };
        });
    }
    _updateWidth(po) {
        if (po === null) {
            this.style.setProperty("--vi-sign-in-persistent-object-width", null);
            this.updateStyles();
            return;
        }
        const tab = po.tabs[0];
        tab.columnCount = tab.columnCount > 1 ? tab.columnCount : 1;
        const width = parseInt(window.getComputedStyle(this).getPropertyValue("--vi-sign-in-persistent-object-width-base")) * tab.columnCount;
        this.style.setProperty("--vi-sign-in-persistent-object-width", `${width}px`);
        this.updateStyles();
    }
    _tabInnerSizeChanged(e, detail) {
        e.stopPropagation();
        if (!detail.height)
            return;
        const tabPresenter = e.currentTarget;
        tabPresenter.style.height = `${detail.height}px`;
    }
};
SignIn = __decorate([
    WebComponent.register({
        properties: {
            returnUrl: {
                type: String,
                readOnly: true,
            },
            isBusy: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                value: false
            },
            step: {
                type: String,
                observer: "_stepChanged"
            },
            hasVidyano: {
                type: Boolean,
                readOnly: true
            },
            userName: {
                type: String,
                value: ""
            },
            password: {
                type: String,
                value: ""
            },
            staySignedIn: {
                type: Boolean
            },
            twoFactorCode: {
                type: String,
                notify: true,
                value: ""
            },
            canAuthenticate: {
                type: Boolean,
                computed: "_computeCanAuthenticate(isBusy, userName, password, twoFactorCode)"
            },
            hasOther: {
                type: Boolean,
                readOnly: true
            },
            hasForgot: {
                type: Boolean,
                readOnly: true,
                value: false
            },
            hasRegister: {
                type: Boolean,
                readOnly: true,
                value: false
            },
            register: {
                type: Object,
                readOnly: true,
                value: null
            },
            initial: {
                type: Object,
                readOnly: true,
                value: null
            },
            logo: {
                type: String,
                value: ""
            },
            label: {
                type: String,
                value: null
            },
            description: {
                type: String,
                readOnly: true
            },
            notification: {
                type: Object,
                readOnly: true,
                value: null
            }
        },
        listeners: {
            "app-route-activate": "_activate",
            "app-route-deactivate": "_deactivate"
        },
        mediaQueryAttributes: true,
        forwardObservers: [
            "register.isBusy",
            "initial.isBusy"
        ]
    })
], SignIn);

let SignOut = class SignOut extends WebComponent {
    static get template() { return html$3 `<vi-spinner></vi-spinner>`; }
    async _activate(e) {
        e.preventDefault();
        const signInUsingDefaultCredentials = !this.service.isUsingDefaultCredentials && !!this.service.defaultUserName;
        await this.service.signOut();
        let path;
        if (!signInUsingDefaultCredentials)
            path = decodeURIComponent(this.parentNode.parameters.returnUrl || "SignIn");
        else {
            await this.service.signInUsingDefaultCredentials();
            path = "";
        }
        this.app.changePath(path, true);
    }
};
SignOut = __decorate([
    WebComponent.register({
        listeners: {
            "app-route-activate": "_activate"
        }
    })
], SignOut);

let Spinner = class Spinner extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  position: relative;
  width: var(--vi-spinner-size, var(--theme-h2));
  height: var(--vi-spinner-size, var(--theme-h2));
}
:host(:not([block])) {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(calc(var(--vi-spinner-size, var(--theme-h2)) / -2), calc(var(--vi-spinner-size, var(--theme-h2)) / -2));
}
:host .box {
  width: 45%;
  height: 45%;
  background: var(--vi-spinner-color, rgb(127, 127, 127));
  opacity: 0.1;
  animation: loadAnimation 1s linear infinite;
}
:host .box:nth-of-type(1) {
  position: absolute;
  top: 2.5%;
  left: 2.5%;
  animation-delay: -0.75s;
}
:host .box:nth-of-type(2) {
  position: absolute;
  top: 2.5%;
  right: 2.5%;
  animation-delay: -0.5s;
}
:host .box:nth-of-type(3) {
  position: absolute;
  bottom: 2.5%;
  right: 2.5%;
  animation-delay: -0.25s;
}
:host .box:nth-of-type(4) {
  position: absolute;
  bottom: 2.5%;
  left: 2.5%;
}
:host([hidden]) {
  display: none !important;
}

@keyframes loadAnimation {
  0% {
    opacity: 0.1;
  }
  30% {
    opacity: 1;
  }
  90% {
    opacity: 0.1;
  }
  100% {
    opacity: 0.1;
  }
}</style>

<div class="box"></div>
<div class="box"></div>
<div class="box"></div>
<div class="box"></div>`; }
    _updateColor(color, isConnected) {
        if (!isConnected)
            return;
        this.style.setProperty("--vi-spinner-color", color);
    }
};
Spinner = __decorate([
    WebComponent.register({
        properties: {
            color: {
                type: String,
                reflectToAttribute: true
            }
        },
        observers: [
            "_updateColor(color, isConnected)"
        ]
    })
], Spinner);

function ascending$1(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}

function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending$1;
    compare2 = (d, x) => ascending$1(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending$1 || f === descending ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return {left, center, right};
}
function zero$1() {
  return 0;
}

function number$1(x) {
  return x === null ? NaN : +x;
}

const ascendingBisect = bisector(ascending$1);
const bisectRight = ascendingBisect.right;
bisector(number$1).center;
var bisect = bisectRight;

const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

var noop = {value: () => {}};
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}
function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}

function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

function empty() {
  return [];
}
function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selection_selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

var find$1 = Array.prototype.find;
function childFind(match) {
  return function() {
    return find$1.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : childMatcher(match)));
}

var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$1(x) {
  return function() {
    return x;
  };
}

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;
  if (typeof value !== "function") value = constant$1(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data
    : Array.from(data);
}

function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}

function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  return Array.from(this);
}

function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

function selection_size() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }
  return this.each((value == null
      ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView)
      || (node.document && node)
      || node.defaultView;
}

function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove$1 : typeof value === "function"
            ? styleFunction$1
            : styleConstant$1)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction$1
          : textConstant$1)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

function dispatchEvent$1(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent$1(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent$1(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
      : new Selection$1([[selector]], root);
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend$1(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m)
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff)
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff)
      : null)
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4])
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4])
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4])
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend$1(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend$1(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var constant = x => () => x;

function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);
  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
})(1);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;
  for (i = 0; i < na; ++i) x[i] = interpolate$1(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate$1(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      am,
      bm,
      bs,
      i = -1,
      s = [],
      q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolate$1(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? interpolateNumber
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : isNumberArray(b) ? numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;
var identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$2 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity$2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360;
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [],
        q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var frame = 0,
    timeout$1 = 0,
    interval = 0,
    pokeDelay = 1000,
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call =
  this._time =
  this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    group: group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}
function create(node, id, self) {
  var schedules = node.__transition,
      tween;
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }
  function start(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;
      if (o.state === STARTED) return timeout(start);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}
function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}
function transition_delay(value) {
  var id = this._id;
  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}
function transition_duration(value) {
  var id = this._id;
  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}
function transition_ease(value) {
  var id = this._id;
  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    set(this, id).ease = v;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function transition_on(name, listener) {
  var id = this._id;
  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = selector(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = selectorAll(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id);
}

var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};
    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

var id = 0;
function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id,
      timing;
  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }
  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

function identity$1(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];
function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));
    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim(value);
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero) value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }
      return numerals(value);
    }
    format.toString = function() {
      return specifier + "";
    };
    return format;
  }
  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function constants(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];
function identity(x) {
  return x;
}
function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x) {
    var i = bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}
function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}
function transformer() {
  var domain = unit,
      range = unit,
      interpolate = interpolate$1,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }
  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity, identity);
}

function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null) count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Transform.prototype;

let Profiler = class Profiler extends WebComponent {
    constructor() {
        super(...arguments);
        this._boundMousehweel = this._onMousewheel.bind(this);
    }
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  background-color: #444;
  --vi-profiler-entry-height: var(--theme-h2);
  --vi-profiler-entry-level-gap: var(--theme-h5);
  --vi-profiler-header-height: var(--theme-h3);
  z-index: 100;
}
:host vi-icon {
  fill: white;
  margin-left: var(--theme-h5);
  margin-right: var(--theme-h4);
  height: var(--theme-h1);
  line-height: var(--theme-h1);
  --vi-icon-height: var(--theme-h3);
  --vi-icon-width: var(--theme-h3);
}
:host vi-popup {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host vi-popup [slot=header] {
  color: white;
  height: var(--theme-h1);
  line-height: var(--theme-h1);
  padding-left: var(--theme-h4);
}
:host vi-popup [slot=header] #lastRequest {
  line-height: normal;
}
:host vi-popup [slot=header] #lastRequest > div {
  display: flex;
  flex-direction: column;
  justify-content: center;
  margin-right: var(--theme-h3);
}
:host vi-popup [slot=header] #lastRequest > div label {
  font-size: 9px;
  line-height: 9px;
  text-transform: uppercase;
}
:host vi-popup [slot=header] #lastRequest > div h1 {
  font-size: 15px;
  line-height: 15px;
  font-weight: bolder;
  margin: 0;
}
:host vi-popup:not([disabled]) [slot=header], :host vi-popup:not([disabled]) label {
  cursor: pointer !important;
}
:host vi-popup main {
  height: calc(15 * var(--theme-h1));
  max-height: 40vh;
  background-color: #e7e7e7;
  box-shadow: var(--theme-box-shadow);
  padding: 6px;
}
:host vi-popup main > * {
  overflow: hidden;
  background-color: white;
}
:host vi-popup main > *:first-child {
  width: 40%;
  z-index: 1;
  box-shadow: var(--theme-box-shadow);
}
:host vi-popup main > *:first-child .request {
  background-color: #FAFAFA;
  color: #333;
  border-radius: var(--theme-h5);
  margin: var(--theme-h5) var(--theme-h4);
  padding: var(--theme-h5);
  cursor: pointer !important;
  border: 1px solid #EAEAEA;
  transition: all 0.2s ease;
}
:host vi-popup main > *:first-child .request[selected] {
  background-color: var(--color);
  color: white;
  margin-right: 0;
  border-radius: var(--theme-h5) 0 0 var(--theme-h5);
  border-right-width: 0;
}
:host vi-popup main > *:first-child .request[selected] h3 {
  margin-right: calc(var(--theme-h4) + 2px);
}
:host vi-popup main > *:first-child .request[has-warnings] {
  background-color: #a00;
  color: white;
}
:host vi-popup main > *:first-child .request[has-warnings][selected] {
  background-color: #800;
}
:host vi-popup main > *:first-child .request h1, :host vi-popup main > *:first-child .request h2, :host vi-popup main > *:first-child .request h3 {
  margin: 0;
}
:host vi-popup main > *:first-child .request h1 {
  font-size: 16px;
  margin-right: var(--theme-h5);
}
:host vi-popup main > *:first-child .request h2 {
  font-size: 13px;
}
:host vi-popup main > *:first-child .request h3 {
  font-size: 10px;
  font-weight: 300;
  transition: margin-right 0.2s ease;
}
:host vi-popup main > *:first-child .request .method > div {
  line-height: 20px;
}
:host vi-popup main > *:first-child .request .extra {
  font-size: 12px;
  padding-top: var(--theme-h5);
  letter-spacing: 0.5px;
}
:host vi-popup main > *:first-child .request .extra > div {
  margin-right: var(--theme-h4);
}
:host vi-popup main > *:first-child .request .extra > div label {
  font-weight: 400;
}
:host vi-popup main > *:first-child .request .extra > div span {
  font-weight: bold;
}
:host vi-popup main > div {
  border: 1px solid #C7C7C7;
  border-left-width: 0;
  margin-top: 1px;
  margin-bottom: 1px;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.xaxis {
  font-size: 10px;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.xaxis line {
  stroke: #eee;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.xaxis g.tick:first-child {
  display: none;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry {
  cursor: default;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry rect {
  fill: #63b08a;
  stroke: white;
  stroke-width: 1px;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry.has-details {
  cursor: pointer;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry.has-details rect {
  fill: #008042;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry.has-details .text {
  cursor: pointer !important;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry.has-sql rect {
  fill: #7e007e;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry.has-sql.has-n-plus-one rect {
  fill: #a00;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry.has-exception rect {
  fill: #a00;
}
:host vi-popup main > div:nth-child(2) vi-scroller svg g.entries .entry .text {
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 6px;
  font-size: 12px;
  line-height: var(--vi-profiler-entry-height);
  box-sizing: border-box;
}
:host vi-popup main #hoveredEntry {
  position: absolute;
  left: var(--theme-h5);
  top: var(--vi-profiler-header-height);
  background-color: rgba(255, 255, 255, 0.5);
  font-size: 13px;
  padding: var(--theme-h4);
}
:host vi-popup main #hoveredEntry table td {
  font-size: 13px;
}
:host vi-popup main #hoveredEntry table td:first-child {
  font-weight: bold;
}
:host vi-popup main #hoveredEntry table tr:first-child td:last-child {
  font-weight: bold;
}
:host vi-popup main #selectedEntry header {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  border-bottom: 1px solid var(--theme-light-border);
  box-sizing: border-box;
}
:host vi-popup main #selectedEntry header h1 {
  margin: 0;
  font-size: 13px;
  font-weight: normal;
  padding: 0 var(--theme-h5);
  color: var(--color);
}
:host vi-popup main #selectedEntry vi-scroller {
  top: var(--theme-h2);
}
:host vi-popup main #selectedEntry #selectedEntryInfo {
  padding-left: var(--theme-h5);
}
:host vi-popup main #selectedEntry #selectedEntryInfo table tr td {
  line-height: 1.2em;
  padding: 0 var(--theme-h3) var(--theme-h5) 0;
  vertical-align: top;
  font-size: 13px;
}
:host vi-popup main #selectedEntry #selectedEntryInfo table tr td:first-of-type {
  font-weight: bold;
}
:host vi-popup main #selectedEntry #selectedEntryInfo pre {
  font-family: monospace !important;
}
:host vi-popup main #selectedEntry #selectedEntryInfo h2 {
  font-size: var(--theme-h3);
  margin: var(--theme-h4) 0;
  font-weight: 400;
  color: var(--color);
}</style>

<vi-popup sticky disabled$="[[!lastRequest]]" auto-width>
    <div slot="header" class="flex layout horizontal">
        <vi-icon source="Profiler"></vi-icon>
        <div class="flex" hidden$="[[op_isNotNull(lastRequest)]]">[[awaiting]]</div>
        <div class="flex layout horizontal" hidden$="[[op_isNull(lastRequest)]]" id="lastRequest">
            <div>
                <label>Method</label>
                <h1>[[lastRequest.method]]</h1>
            </div>
            <dom-repeat items="[[lastRequest.parameters]]" as="parameter">
                <template>
                    <div>
                        <label>[[parameter.key]]</label>
                        <h1>[[parameter.value]]</h1>
                    </div>
                </template>
            </dom-repeat>
            <div>
                <label>Server</label>
                <h1>[[lastRequest.profiler.elapsedMilliseconds]]ms</h1>
            </div>
            <div>
                <label>Transport</label>
                <h1>+[[lastRequest.transport]]ms</h1>
            </div>
        </div>
        <vi-button icon="Remove" type="light-monochrome" inverse on-tap="_close"></vi-button>
    </div>
    <main class="layout horizontal">
        <vi-scroller no-horizontal align-vertical-scrollbar="left">
            <div>
                <dom-repeat items="[[profiledRequests]]" as="request">
                    <template>
                        <div class="request" selected$="[[op_areSame(request, selectedRequest)]]" has-warnings$="[[_requestHasWarnings(request)]]" on-tap="_selectRequest">
                            <div class="layout horizontal-reverse method">
                                <h3>[[_requestDate(request.when)]]</h3>
                                <div class="flex layout horizontal wrap">
                                    <h1>[[request.method]]</h1>
                                    <h2>[[_requestParameters(request)]]</h2>
                                </div>
                            </div>
                            <div class="layout horizontal wrap extra">
                                <div>
                                    <label>Server:</label>
                                    <span>[[_ms(request.profiler.elapsedMilliseconds)]]</span>
                                </div>
                                <div>
                                    <label>Transport:</label>
                                    <span>+[[_ms(request.transport)]]</span>
                                </div>
                                <div>
                                    <label>DB:</label>
                                    <span>[[_requestSQL(request)]]</span>
                                </div>
                                <div>
                                    <label>#DB:</label>
                                    <span>[[_requestSharpSQL(request)]]</span>
                                </div>
                            </div>
                        </div>
                    </template>
                </dom-repeat>
            </div>
        </vi-scroller>
        <div class="flex relative" hidden$="[[op_isNotNull(selectedEntry)]]">
            <vi-size-tracker size="{{timelineSize}}"></vi-size-tracker>
            <vi-scroller id="timelineScroller" class="fit" no-vertical>
                <svg id="timeline" on-mousewheel="_onMousewheel">
                    <g class="xaxis"></g>
                </svg>
            </vi-scroller>
            <div id="hoveredEntry" hidden$="[[!hoveredEntry]]">
                <table>
                    <tr>
                        <td>Method</td>
                        <td>[[hoveredEntry.methodName]]</td>
                    </tr>
                    <tr>
                        <td>Total time</td>
                        <td>[[_ms(hoveredEntry.elapsedMilliseconds)]]</td>
                    </tr>
                    <tr>
                        <td>DB statements</td>
                        <td>[[hoveredEntry.sql.length]]</td>
                    </tr>
                </table>
            </div>
        </div>
        <div class="flex relative" hidden$="[[op_isNull(selectedEntry)]]" id="selectedEntry">
            <header class="horizontal layout">
                <h1 class="flex">[[selectedEntry.methodName]]</h1>
                <vi-button icon="Remove" inverse on-tap="_closeSelectedEntry"></vi-button>
            </header>
            <vi-scroller class="fit">
                <div id="selectedEntryInfo"></div>
            </vi-scroller>
        </div>
    </main>
</vi-popup>`; }
    connectedCallback() {
        super.connectedCallback();
        this.$.timeline.addEventListener("DOMMouseScroll", this._boundMousehweel);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.$.timeline.removeEventListener("DOMMouseScroll", this._boundMousehweel);
    }
    _requestSQL(request) {
        return request.profiler.sql ? this._ms(request.profiler.sql.reduce((current, entry) => current + entry.elapsedMilliseconds, 0)) : "0ms";
    }
    _requestSharpSQL(request) {
        return (request.profiler.sql ? request.profiler.sql.length : 0).toString();
    }
    _requestHasWarnings(request) {
        return request.hasNPlusOne || (request.profiler.exceptions && request.profiler.exceptions.length > 0);
    }
    _hasNPlusOne(request, entries = request.profiler.entries) {
        if (!entries)
            return false;
        let hasNPlusOne = false;
        entries.forEach(entry => {
            const counts = entry.sql.groupBy(commandId => request.profiler.sql.find(s => s.commandId === commandId).commandText);
            if (counts.find(c => c.value.length > 1))
                entry.hasNPlusOne = hasNPlusOne = true;
            if (entry.entries && entry.entries.length > 0)
                hasNPlusOne = this._hasNPlusOne(request, entry.entries) || hasNPlusOne;
        });
        return hasNPlusOne;
    }
    _onMousewheel(e) {
        const scroller = this.$.timelineScroller;
        const rect = scroller.getBoundingClientRect();
        const offsetX = e.pageX - rect.left - window.pageXOffset;
        const mousePctg = 1 / scroller.outerWidth * offsetX;
        const isZoomIn = (e.wheelDelta || -e.detail) > 0;
        const newZoom = Math.max(isZoomIn ? this.zoom * 1.1 : this.zoom / 1.1, 1);
        const newInnerWidth = (this.timelineSize.width - 2) * newZoom;
        this._setZoom(newZoom);
        scroller.horizontalScrollOffset = (newInnerWidth - scroller.outerWidth) * mousePctg;
    }
    _selectRequest(e) {
        this._setSelectedRequest(e.model.request);
    }
    _selectedRequestChanged() {
        this._setZoom(1);
        this._setSelectedEntry(null);
    }
    _profiledRequestsChanged(profiledRequests = []) {
        profiledRequests.forEach(request => {
            if (request.hasNPlusOne === undefined)
                request.hasNPlusOne = this._hasNPlusOne(request);
            if (request.parameters === undefined) {
                request.parameters = [];
                switch (request.method) {
                    case "GetPersistentObject": {
                        if (request.response.result != null) {
                            request.parameters.push({ key: "Type", value: request.response.result.type });
                            request.parameters.push({ key: "Id", value: request.response.result.objectId });
                        }
                        break;
                    }
                    case "GetQuery": {
                        if (request.response.result != null)
                            request.parameters.push({ key: "Name", value: request.response.query.name });
                        break;
                    }
                    case "ExecuteAction": {
                        request.parameters.push({ key: "Name", value: request.request.action });
                        break;
                    }
                    case "ExecuteQuery": {
                        request.parameters.push({ key: "Name", value: request.request.query.name });
                        request.parameters.push({ key: "PageSize", value: request.request.query.pageSize });
                        if (request.request.query.top)
                            request.parameters.push({ key: "Top", value: request.request.query.top });
                        if (request.request.query.skip)
                            request.parameters.push({ key: "Skip", value: request.request.query.skip });
                        break;
                    }
                }
            }
        });
        this._setSelectedRequest(profiledRequests[0]);
        this._setLastRequest(profiledRequests[0]);
    }
    _renderRequestTimeline(request, size, zoom) {
        const width = (size.width - 2) * zoom;
        const style = getComputedStyle(this);
        parseInt(style.getPropertyValue("--vi-profiler-header-height"));
        const entryHeight = parseInt(style.getPropertyValue("--vi-profiler-entry-height"));
        const entryLevelGap = parseInt(style.getPropertyValue("--vi-profiler-entry-level-gap"));
        const scale = linear().domain([0, request.profiler.elapsedMilliseconds]).range([0, width]);
        const svg = select(this.$.timeline).
            attr("width", width).
            attr("height", size.height);
        let entriesGroup = svg.select(".entries");
        if (entriesGroup.empty())
            entriesGroup = svg.append("g").classed("entries", true);
        const entryGroupSelection = entriesGroup.selectAll("g.entry").data(request.flattenedEntries || (request.flattenedEntries = this._flattenEntries(request.profiler.entries)));
        const entryGroup = entryGroupSelection.enter()
            .append("g")
            .attr("class", e => this._computeEntryClassName(e.entry))
            .on("click", (_, e) => this._setSelectedEntry(e.entry));
        entryGroup.append("rect")
            .attr("x", e => scale(e.entry.started || 0))
            .attr("y", e => size.height - (e.level * entryHeight) - (e.level * entryLevelGap))
            .attr("width", e => e.entry.elapsedMilliseconds ? scale(e.entry.elapsedMilliseconds) : 1)
            .attr("height", entryHeight);
        entryGroup
            .append("foreignObject")
            .attr("x", e => scale(e.entry.started || 0))
            .attr("y", e => size.height - (e.level * entryHeight) - (e.level * entryLevelGap))
            .attr("width", e => e.entry.elapsedMilliseconds ? scale(e.entry.elapsedMilliseconds) : 1)
            .attr("height", entryHeight)
            .html(e => `<div class="text" style="width: ${e.entry.elapsedMilliseconds ? scale(e.entry.elapsedMilliseconds) : 1}px;">` + e.entry.methodName + "</div>")
            .on("mouseenter", (_, e) => this._setHoveredEntry(e.entry))
            .on("mouseleave", (_, e) => this._setHoveredEntry(null));
        const entryGroupTransition = entryGroupSelection.transition().duration(0)
            .attr("class", e => this._computeEntryClassName(e.entry));
        entryGroupTransition
            .select("rect")
            .attr("x", e => scale(e.entry.started || 0))
            .attr("y", e => size.height - (e.level * entryHeight) - (e.level * entryLevelGap))
            .attr("width", e => e.entry.elapsedMilliseconds ? scale(e.entry.elapsedMilliseconds) : 1)
            .attr("height", entryHeight);
        entryGroupTransition.select("foreignObject")
            .attr("x", e => scale(e.entry.started || 0))
            .attr("y", e => size.height - (e.level * entryHeight) - (e.level * entryLevelGap))
            .attr("width", e => e.entry.elapsedMilliseconds ? scale(e.entry.elapsedMilliseconds) : 1)
            .attr("height", entryHeight)
            .select(".text")
            .attr("style", e => `width: ${e.entry.elapsedMilliseconds ? scale(e.entry.elapsedMilliseconds) : 1}px;`)
            .text(e => e.entry.methodName);
        entryGroupSelection.exit().remove();
    }
    _flattenEntries(entries = [], level = 1, flattenedEntries = []) {
        entries.forEach(entry => {
            flattenedEntries.push({
                entry: entry,
                level: level
            });
            this._flattenEntries(entry.entries, level + 1, flattenedEntries);
        });
        return flattenedEntries;
    }
    _computeEntryClassName(e) {
        let className = "entry";
        let hasDetails = false;
        if (e.sql && e.sql.length > 0) {
            className = `${className} has-sql`;
            if (e.hasNPlusOne)
                className = `${className} has-n-plus-one`;
            hasDetails = true;
        }
        if (e.exception)
            className = `${className} has-exception`;
        if (e.arguments)
            hasDetails = true;
        if (hasDetails)
            className = `${className} has-details`;
        return className;
    }
    _requestParameters(request) {
        if (!request || !request.parameters)
            return "";
        return `(${request.parameters.map(p => p.value).join(", ")})`;
    }
    _ms(ms) {
        return `${ms || 0}ms`;
    }
    _requestDate(date) {
        return String.format(`{0:${CultureInfo.currentCulture.dateFormat.shortDatePattern} ${CultureInfo.currentCulture.dateFormat.shortTimePattern}}`, date);
    }
    _selectedEntryChanged(entry) {
        const info = document.createDocumentFragment();
        this.empty(this.$.selectedEntryInfo);
        if (!entry)
            return;
        const createTableCell = (content, colspan) => {
            const td = document.createElement("td");
            if (content instanceof HTMLElement)
                td.appendChild(content);
            else
                td.textContent = content;
            if (colspan)
                td.setAttribute("colspan", colspan.toString());
            return td;
        };
        const createTableRow = (...contents) => {
            const row = document.createElement("tr");
            if (contents)
                contents.forEach(content => row.appendChild(createTableCell(content)));
            return row;
        };
        if (entry.arguments && entry.arguments.length > 0) {
            const title = document.createElement("h2");
            title.textContent = "Arguments";
            info.appendChild(title);
            const argumentNames = entry.methodName.replace(")", "").split("(")[1].split(", ");
            const table = document.createElement("table");
            table.className = "arguments";
            argumentNames.forEach((argName, argIndex) => {
                let row = table.appendChild(document.createElement("tr"));
                row.appendChild(createTableCell(argName));
                if (typeof (entry.arguments[argIndex]) === "object") {
                    let first = true;
                    for (let p in entry.arguments[argIndex]) {
                        if (!first) {
                            row = table.appendChild(document.createElement("tr"));
                            row.appendChild(createTableCell());
                        }
                        else
                            first = false;
                        row.appendChild(createTableCell(p));
                        row.appendChild(createTableCell(entry.arguments[argIndex][p]));
                    }
                }
                else
                    row.appendChild(createTableCell(entry.arguments[argIndex], 2));
            });
            info.appendChild(table);
        }
        if (entry.sql && entry.sql.length > 0) {
            const title = document.createElement("h2");
            title.textContent = "DB Statements";
            info.appendChild(title);
            entry.sql.forEach(sqlCommandId => {
                const sql = this.selectedRequest.profiler.sql.find(s => s.commandId === sqlCommandId);
                if (!sql)
                    return;
                const table = document.createElement("table");
                table.className = "sql-statement";
                const commandText = document.createElement("pre");
                commandText.textContent = sql.commandText;
                table.appendChild(createTableRow("CommandText", commandText));
                if (sql.parameters) {
                    const parametersRow = table.appendChild(createTableRow("Parameters"));
                    const parametersTable = document.createElement("table");
                    parametersRow.appendChild(createTableCell(parametersTable));
                    sql.parameters.forEach(sqlParam => parametersTable.appendChild(createTableRow(sqlParam.name, sqlParam.value, sqlParam.type)));
                    table.appendChild(parametersRow);
                }
                if (sql.recordsAffected)
                    table.appendChild(createTableRow("Records affected", sql.recordsAffected));
                table.appendChild(createTableRow("Total time", `${sql.elapsedMilliseconds || 0}ms`));
                if (sql.taskId)
                    table.appendChild(createTableRow("Task id", sql.taskId));
                if (entry.hasNPlusOne)
                    table.appendChild(createTableRow("Warning", "Possible N+1 detected"));
                info.appendChild(table);
            });
        }
        if (entry.exception) {
            const title = document.createElement("h2");
            title.textContent = "Exception";
            info.appendChild(title);
            const exception = this.selectedRequest.profiler.exceptions.find(e => e.id === entry.exception);
            if (exception) {
                const exceptionPre = document.createElement("pre");
                exceptionPre.textContent = exception.message;
                info.appendChild(exceptionPre);
            }
        }
        this.$.selectedEntryInfo.appendChild(info);
    }
    _closeSelectedEntry() {
        this._setSelectedEntry(null);
    }
    _close(e) {
        this.service.profile = false;
        e.stopPropagation();
    }
};
Profiler = __decorate([
    WebComponent.register({
        properties: {
            service: Object,
            awaiting: {
                type: String,
                value: "Awaiting next request..."
            },
            profiledRequests: {
                type: Array,
                computed: "service.profiledRequests",
                observer: "_profiledRequestsChanged"
            },
            lastRequest: {
                type: Object,
                readOnly: true,
                value: null
            },
            selectedRequest: {
                type: Object,
                readOnly: true,
                observer: "_selectedRequestChanged"
            },
            hoveredEntry: {
                type: Object,
                readOnly: true,
                value: null
            },
            selectedEntry: {
                type: Object,
                readOnly: true,
                value: null,
                observer: "_selectedEntryChanged"
            },
            timelineSize: Object,
            zoom: {
                type: Number,
                readOnly: true,
                value: 1
            }
        },
        forwardObservers: [
            "service.profile",
            "service.profiledRequests"
        ],
        observers: [
            "_renderRequestTimeline(selectedRequest, timelineSize, zoom)"
        ]
    })
], Profiler);

function guid() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}

var _QueryGridCell__observeOnConnected, _QueryGridCell__lastMeasuredColumn, _QueryGridCell__isObserved;
let resizeObserver$1;
resizeObserver$1 = new ResizeObserver(allEntries => {
    window.requestAnimationFrame(() => {
        const parents = new Map();
        allEntries.forEach(e => {
            const parent = parents.get(e.target.parentElement) || parents.set(e.target.parentElement, []).get(e.target.parentElement);
            parent.push(e);
        });
        parents.forEach((entries, parent) => {
            try {
                parent?.dispatchEvent(new CustomEvent("column-width-changed", {
                    detail: {
                        type: "cell",
                        entries: entries.map(e => {
                            let width = e["borderBoxSize"] != null ? e["borderBoxSize"][0].inlineSize : e.target.offsetWidth;
                            return [e.target.column.name, width];
                        }),
                    },
                    bubbles: true,
                    cancelable: true,
                    composed: true
                }));
            }
            finally {
                entries.forEach(e => e.target._unobserve());
            }
        });
    });
});
let QueryGridCell = class QueryGridCell extends WebComponent {
    constructor() {
        super(...arguments);
        _QueryGridCell__observeOnConnected.set(this, void 0);
        _QueryGridCell__lastMeasuredColumn.set(this, void 0);
        _QueryGridCell__isObserved.set(this, void 0);
    }
    connectedCallback() {
        super.connectedCallback();
        if (__classPrivateFieldGet(this, _QueryGridCell__observeOnConnected, "f")) {
            __classPrivateFieldSet(this, _QueryGridCell__observeOnConnected, false, "f");
            this._observe();
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        if (__classPrivateFieldGet(this, _QueryGridCell__isObserved, "f")) {
            this._unobserve();
            __classPrivateFieldSet(this, _QueryGridCell__observeOnConnected, true, "f");
        }
    }
    get isObserved() {
        return __classPrivateFieldGet(this, _QueryGridCell__isObserved, "f");
    }
    _queueMeasure(value, isConnected) {
        if (!isConnected)
            return;
        if (__classPrivateFieldGet(this, _QueryGridCell__lastMeasuredColumn, "f") && __classPrivateFieldGet(this, _QueryGridCell__lastMeasuredColumn, "f").query === this.column?.query && __classPrivateFieldGet(this, _QueryGridCell__lastMeasuredColumn, "f").name === this.column.name)
            return;
        const row = this.parentElement;
        if (!(row.item instanceof QueryResultItem))
            return;
        const rowContainer = row.parentElement;
        const firstQueryGridRow = rowContainer.querySelector("vi-query-grid-row:not([is-group])");
        if (firstQueryGridRow !== row)
            return;
        __classPrivateFieldSet(this, _QueryGridCell__lastMeasuredColumn, this.column, "f");
        this._observe();
    }
    _observe() {
        __classPrivateFieldSet(this, _QueryGridCell__isObserved, true, "f");
        resizeObserver$1.observe(this, { box: "border-box" });
    }
    _unobserve() {
        resizeObserver$1.unobserve(this);
        __classPrivateFieldSet(this, _QueryGridCell__isObserved, false, "f");
    }
    static registerCellType(type, constructor) {
        registeredQueyGridCellTypes[type] = constructor;
    }
    static getCellTypeConstructor(type) {
        return registeredQueyGridCellTypes[type];
    }
};
_QueryGridCell__observeOnConnected = new WeakMap();
_QueryGridCell__lastMeasuredColumn = new WeakMap();
_QueryGridCell__isObserved = new WeakMap();
QueryGridCell = __decorate([
    WebComponent.register({
        properties: {
            column: Object,
            value: Object,
            sensitive: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            }
        },
        observers: [
            "_queueMeasure(value, isConnected)"
        ]
    })
], QueryGridCell);
const registeredQueyGridCellTypes = {};

var _QueryGridCellDefault_typeHints, _QueryGridCellDefault_textNode, _QueryGridCellDefault_textNodeValue;
let QueryGridCellDefault = class QueryGridCellDefault extends QueryGridCell {
    constructor() {
        super(...arguments);
        _QueryGridCellDefault_typeHints.set(this, void 0);
        _QueryGridCellDefault_textNode.set(this, void 0);
        _QueryGridCellDefault_textNodeValue.set(this, void 0);
        this._foreground = { currentValue: null };
        this._tag = { currentValue: null };
        this._textAlign = { currentValue: null };
    }
    static get template() { return html$3 `<style>:host {
  padding: 0 var(--theme-h5);
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
  min-width: var(--theme-h2);
}
:host #text {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
:host([is-app-sensitive][sensitive]) #text {
  filter: blur(5px);
}
:host([tag]) {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
}
:host([tag]) #text {
  border-radius: var(--theme-h5);
  background-color: var(--tag-background);
  color: var(--foreground, white);
  line-height: var(--theme-h3);
  padding: 0 var(--theme-h5);
}</style>
<div id="text"></div>`; }
    _valueChanged(itemValue) {
        this._setSensitive(itemValue?.column.isSensitive);
        if (!itemValue) {
            this._clearCell();
            return;
        }
        let value = null;
        __classPrivateFieldSet(this, _QueryGridCellDefault_typeHints, Object.assign({}, itemValue.item.typeHints, itemValue ? itemValue.typeHints : undefined), "f");
        value = itemValue.item.getValue(itemValue.column.name);
        if (value != null && (itemValue.column.type === "Boolean" || itemValue.column.type === "NullableBoolean"))
            value = itemValue.item.query.service.getTranslatedMessage(value ? this._getTypeHint(itemValue.column, "truekey", "True") : this._getTypeHint(itemValue.column, "falsekey", "False"));
        else if (itemValue.column.type === "YesNo")
            value = itemValue.item.query.service.getTranslatedMessage(value ? this._getTypeHint(itemValue.column, "truekey", "Yes") : this._getTypeHint(itemValue.column, "falsekey", "No"));
        else if (itemValue.column.type === "Time" || itemValue.column.type === "NullableTime") {
            if (typeof value === "string") {
                value = value.trimEnd("0").trimEnd(".");
                if (value.startsWith("0:"))
                    value = value.substr(2);
                if (value.endsWith(":00"))
                    value = value.substr(0, value.length - 3);
            }
        }
        if (value != null) {
            let format = this._getTypeHint(itemValue.column, "displayformat", null);
            if (format == null || format === "{0}") {
                switch (itemValue.column.type) {
                    case "Date":
                    case "NullableDate":
                        format = null;
                        value = value.localeFormat(CultureInfo.currentCulture.dateFormat.shortDatePattern, true);
                        break;
                    case "DateTime":
                    case "NullableDateTime":
                    case "DateTimeOffset":
                    case "NullableDateTimeOffset":
                        format = null;
                        value = value.localeFormat(CultureInfo.currentCulture.dateFormat.shortDatePattern + " " + CultureInfo.currentCulture.dateFormat.shortTimePattern, true);
                        break;
                }
            }
            if (String.isNullOrEmpty(format))
                value = value.localeFormat ? value.localeFormat() : value.toLocaleString();
            else
                value = String.format(format, value);
        }
        else
            value = "";
        const foreground = this._getTypeHint(itemValue.column, "foreground", null);
        if (foreground !== this._foreground.currentValue)
            this.style.color = this._foreground.currentValue = foreground || this._foreground.originalValue || null;
        const textAlign = this._getTypeHint(itemValue.column, "horizontalcontentalignment", DataType.isNumericType(itemValue.column.type) ? "right" : null);
        if (textAlign !== this._textAlign.currentValue)
            this.style.textAlign = this._textAlign.currentValue = textAlign || this._textAlign.originalValue || null;
        const tag = this._getTypeHint(itemValue.column, "tag", null);
        if (tag !== this._tag.currentValue) {
            this.style.setProperty("--tag-background", this._tag.currentValue = tag || this._tag.originalValue || null);
            this.tag = !!tag;
        }
        const extraClass = itemValue.column.getTypeHint("extraclass", undefined, value && itemValue.typeHints, true);
        if (extraClass !== this._extraClass) {
            if (!String.isNullOrEmpty(this._extraClass))
                this.classList.remove(...this._extraClass.split(" "));
            this._extraClass = extraClass;
            if (!String.isNullOrEmpty(extraClass))
                this.classList.add(...this._extraClass.split(" "));
        }
        this._updateCell(value);
    }
    _clearCell() {
        if (__classPrivateFieldGet(this, _QueryGridCellDefault_textNode, "f") && __classPrivateFieldGet(this, _QueryGridCellDefault_textNodeValue, "f") !== "")
            __classPrivateFieldGet(this, _QueryGridCellDefault_textNode, "f").nodeValue = __classPrivateFieldSet(this, _QueryGridCellDefault_textNodeValue, "", "f");
    }
    _updateCell(value) {
        if (__classPrivateFieldGet(this, _QueryGridCellDefault_textNode, "f")) {
            if (__classPrivateFieldGet(this, _QueryGridCellDefault_textNodeValue, "f") !== value)
                __classPrivateFieldGet(this, _QueryGridCellDefault_textNode, "f").nodeValue = __classPrivateFieldSet(this, _QueryGridCellDefault_textNodeValue, value, "f");
        }
        else
            this.$.text.appendChild(__classPrivateFieldSet(this, _QueryGridCellDefault_textNode, document.createTextNode(__classPrivateFieldSet(this, _QueryGridCellDefault_textNodeValue, value, "f")), "f"));
    }
    _getTypeHint(column, name, defaultValue) {
        return column.getTypeHint(name, defaultValue, __classPrivateFieldGet(this, _QueryGridCellDefault_typeHints, "f"), true);
    }
};
_QueryGridCellDefault_typeHints = new WeakMap();
_QueryGridCellDefault_textNode = new WeakMap();
_QueryGridCellDefault_textNodeValue = new WeakMap();
QueryGridCellDefault = __decorate([
    WebComponent.register({
        properties: {
            value: {
                type: Object,
                observer: "_valueChanged"
            },
            column: Object,
            right: {
                type: Boolean,
                reflectToAttribute: true
            },
            tag: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        sensitive: true
    })
], QueryGridCellDefault);

let QueryGridColumnMeasure = class QueryGridColumnMeasure extends WebComponent {
    static get template() {
        return html$3 `
            <style>:host { height: 0; }</style>
            <div style="position: relative; height: 1px;">
                <vi-size-tracker size="{{size}}"></vi-size-tracker>
            </div>`;
    }
    _report(grid, column, size) {
        if (this._reported)
            return;
        this.fire("column-size-changed", { column, size });
        this._reported = true;
    }
};
QueryGridColumnMeasure = __decorate([
    WebComponent.register({
        properties: {
            grid: Object,
            column: Object,
            key: String
        },
        observers: [
            "_report(grid, column, size)"
        ]
    })
], QueryGridColumnMeasure);

let Checkbox = class Checkbox extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  box-sizing: border-box;
}
:host(:not([disabled])) {
  cursor: pointer;
}
:host div > span:not([empty]) {
  padding: 0 1px 0 3px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
:host div > vi-icon:not([hidden]) + span:not([empty]) {
  margin-left: calc(var(--theme-h5) - 1px);
}
:host(:focus) {
  outline: 0;
}
:host(:focus:not([disabled])) vi-icon[source=SelectedRadio] ::content #box {
  fill: var(--color-light);
  opacity: 0.75;
}
:host(:focus:not([disabled])) vi-icon[source=Selected] + span {
  outline: 1px dotted var(--color-light);
}</style>

<div class="layout horizontal center">
    <vi-icon disabled$="[[disabled]]" source="[[icon]]" is-selected$="[[checked]]" part="icon"></vi-icon>
    <span hidden$="[[noLabel]]" part="label">[[label]]</span>
</div>`; }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("tabindex", "0");
    }
    toggle() {
        if (this.disabled)
            return;
        if (!this.radio)
            this.checked = !this.checked;
        else
            this.fire("changed", null);
    }
    _keyToggle(e) {
        if (this.app.activeElement !== this)
            return true;
        this.toggle();
    }
    _computeIcon(radio) {
        return !radio ? "Selected" : "SelectedRadio";
    }
    _computeNoLabel(label) {
        return !label;
    }
};
Checkbox = __decorate([
    WebComponent.register({
        properties: {
            checked: {
                type: Boolean,
                reflectToAttribute: true,
                notify: true
            },
            label: {
                type: String,
                value: null
            },
            noLabel: {
                type: Boolean,
                computed: "_computeNoLabel(label)"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            },
            radio: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            icon: {
                type: String,
                computed: "_computeIcon(radio)"
            }
        },
        listeners: {
            "tap": "toggle"
        },
        keybindings: {
            "space": "_keyToggle"
        }
    })
], Checkbox);

let QueryGridColumnFilter = class QueryGridColumnFilter extends WebComponent {
    static get template() { return html$3 `<style>:host {
  position: relative;
  display: block;
  border-top: 1px solid var(--theme-light-border);
  box-sizing: border-box;
  line-height: var(--vi-query-grid-row-height);
  cursor: pointer;
}
:host vi-input-search {
  height: var(--theme-h2);
  border-top: 1px solid var(--theme-light-border);
  border-right: 1px solid var(--theme-light-border);
  border-bottom: 1px solid var(--theme-light-border);
  border-left: 1px solid var(--theme-light-border);
  box-sizing: border-box;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: var(--theme-h5);
  margin-left: calc(var(--theme-h2) + var(--theme-h5));
}
:host vi-input-search::part(input) {
  padding-left: 8px;
  color: #333;
}
:host vi-input-search::part(search) {
  width: var(--theme-h2);
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  padding-left: 0;
  fill: var(--theme-light-border);
}
:host([disabled]) {
  cursor: default;
  background-color: #F9F9F9;
}
:host([disabled]) #filter button {
  display: none;
}
:host([disabled]) #filter [toggle] {
  cursor: default;
}
:host(:not([disabled])[query-filtering]) {
  background-color: var(--color-faint);
}
:host #preRender {
  display: flex;
}
:host vi-button[slot=header], :host #preRender {
  justify-content: start;
  box-sizing: border-box;
  overflow: hidden;
  text-align: left;
  font-weight: 500;
  width: 100%;
  padding: 0;
}
:host vi-button[slot=header] span, :host #preRender span {
  overflow: hidden;
}
:host #label {
  display: none;
  padding: 0 var(--vi-query-grid-cell-padding, var(--theme-h5));
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  pointer-events: none;
}
:host vi-icon[source=Filter] {
  display: inline-block;
  fill: #eee;
  height: var(--vi-query-grid-row-height);
  padding: 0 0 0 var(--vi-query-grid-cell-padding, var(--theme-h5));
}
:host([filtered]) #label {
  display: block;
}
:host([filtered]) vi-icon[source=Filter] {
  display: none;
}
:host #filterContentHost {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host #filterContentHost #filterContent {
  position: relative;
  height: 25em;
  min-height: 25em;
  min-width: 20em;
  max-width: 100%;
}
:host #filterContentHost #filterContent .left {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: var(--theme-h2);
  background-color: #F7F7F7;
}
:host #filterContentHost .menuItem {
  position: relative;
  cursor: pointer;
  text-align: left;
  line-height: var(--theme-h2);
  font-weight: normal;
  overflow: hidden;
  padding-right: var(--theme-h5);
}
:host #filterContentHost .menuItem vi-icon {
  text-align: center;
  min-width: var(--theme-h2);
  height: var(--theme-h2);
}
:host #filterContentHost .menuItem[disabled] {
  opacity: 0.25;
  cursor: default;
}
:host #filterContentHost .menuItem span {
  margin-left: var(--theme-h5);
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
:host #filterContentHost .split {
  border-top: 1px solid var(--theme-light-border);
  margin: 0 0 var(--theme-h5) calc(var(--theme-h2) + var(--theme-h5));
}
:host #filterContentHost .advanced {
  padding: 0 var(--vi-query-grid-cell-padding, var(--theme-h5)) var(--vi-query-grid-cell-padding, var(--theme-h5)) 0;
  position: relative;
}
:host #filterContentHost .advanced > div {
  padding-left: var(--theme-h2);
}
:host #filterContentHost .advanced > div button#inverse {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  left: 0;
  width: var(--theme-h2);
  height: var(--theme-h3);
  cursor: pointer;
  background-color: transparent;
  color: var(--color);
  fill: #595959;
  -moz-transition-property: fill, color, background-color;
  -o-transition-property: fill, color, background-color;
  -webkit-transition-property: fill, color, background-color;
  transition-property: fill, color, background-color;
  -moz-transition-duration: 0.1s;
  -o-transition-duration: 0.1s;
  -webkit-transition-duration: 0.1s;
  transition-duration: 0.1s;
  -moz-transition-timing-function: ease-out;
  -o-transition-timing-function: ease-out;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
:host #filterContentHost .advanced > div button#inverse:hover {
  background-color: var(--color-faint);
}
:host #filterContentHost .advanced > div button#inverse:active {
  background-color: var(--color-dark);
  fill: white !important;
  color: white !important;
}
:host #filterContentHost .advanced > div button#inverse[disabled] {
  fill: var(--color-faint);
  color: fadeout(black, 50%);
}
:host #filterContentHost .advanced > div button#inverse[inversed]:not(:active) {
  fill: darkred !important;
}
:host #filterContentHost .advanced > div button#inverse:not(:active) {
  fill: #aaa !important;
}
:host #filterContentHost .advanced > div button#inverse vi-icon svg {
  width: var(--theme-h4);
  height: var(--theme-h4);
}
:host #filterContentHost #distincts {
  border: 1px solid var(--theme-light-border);
  margin-left: var(--theme-h5);
  box-sizing: border-box;
  cursor: default;
  font-weight: normal;
}
:host #filterContentHost #distincts .item {
  cursor: pointer;
}
:host #filterContentHost #distincts .item:hover {
  background-color: var(--vi-query-grid-column-filter-distinct-hover-color, var(--color-faint));
}
:host #filterContentHost #distincts .item vi-checkbox {
  display: flex;
  flex-direction: row;
  line-height: var(--theme-h3);
  height: var(--theme-h3);
  padding: 0 var(--theme-h5);
  pointer-events: none;
}
:host #filterContentHost #distincts .item vi-checkbox[checked] {
  --vi-checkbox-checked-color: green;
}
:host #filterContentHost #distincts .item[inversed] vi-checkbox[checked] {
  --vi-checkbox-checked-color: darkred;
}
:host #filterContentHost #distincts .item > span {
  display: -webkit-box;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: top;
  line-height: var(--theme-h3);
  height: var(--theme-h3);
  -webkit-line-clamp: 1;
  -webkit-box-orient: vertical;
}
:host #filterContentHost #distincts .item > span[distinct-type=remaining] {
  color: var(--vi-query-grid-column-filter-distinct-remaining-color, #aaa);
}
:host #filterContentHost #distincts .item > span .match {
  color: var(--color);
  font-weight: 600;
}
:host #filterContentHost #distincts div.hasMore {
  text-align: left;
  cursor: default;
  opacity: 0.25;
}
:host #filterContentHost #distincts div.hasMore vi-icon {
  display: inline-block;
  line-height: var(--theme-h3);
  height: var(--theme-h3);
  padding: 0 var(--theme-h5);
  box-sizing: border-box;
}
:host #filterContentHost #distincts div.hasMore vi-icon:first-of-type ::content svg #check {
  display: none;
}
:host #filterContentHost #distincts div.hasMore vi-icon:last-of-type {
  padding-left: 0;
}
:host #filterContentHost #resizehandle {
  position: absolute;
  bottom: 0;
  right: 0;
  border-width: 0 var(--theme-h5) var(--theme-h5) 0;
  border-style: solid;
  border-color: #EAEAEA;
  width: var(--theme-h4);
  height: var(--theme-h4);
  cursor: nwse-resize;
}
:host([loading]) #distincts {
  opacity: 0.5;
}
:host([sensitive]) vi-checkbox[distinct-type=matching], :host([sensitive]) vi-checkbox[distinct-type=remaining] {
  --at-apply: --vi-app--sensitive;
}</style>

<dom-if if="[[!render]]">
    <template>
        <vi-button id="preRender" class="flex" inverse on-tap="_render">
            <span id="label">[[label]]</span>
            <vi-icon source="Filter"></vi-icon>
        </vi-button>
    </template>
</dom-if>

<dom-if if="[[render]]">
    <template>
        <vi-popup id="filter" on-popup-opening="_popupOpening" class="flex" disabled="[[!column.canFilter]]">
            <vi-button slot="header" class="flex" inverse>
                <span id="label">[[label]]</span>
                <vi-icon source="Filter"></vi-icon>
            </vi-button>
            <div id="filterContentHost" class="relative" on-click="_catchClick">
                <div id="filterContent" class="vertical layout">
                    <div class="left"></div>
                    <div class="menuItem horizontal layout" disabled$="[[!filtered]]" on-tap="_clear">
                        <vi-icon source="Filter_Reset"></vi-icon>
                        <span flex>[[translateMessage('ClearFilterFrom', column.label, isConnected)]]</span>
                    </div>
                    <div class="split"></div>
                    <div class="flex advanced vertical layout">
                        <vi-input-search id="search" value="{{searchText}}" on-search="_search"></vi-input-search>
                        <div class="relative flex horizontal layout">
                            <button id="inverse" on-tap="_inverse" inversed$="[[inversed]]">
                                <vi-icon source="Filter_Inverse"></vi-icon>
                            </button>
                            <dom-if if="[[loading]]">
                                <template>
                                    <vi-spinner></vi-spinner>
                                </template>
                            </dom-if>
                            <vi-list class="flex" id="distincts" items="[[_getFilteredDistincts(distincts, searchText)]]" as="distinct">
                                <template>
                                    <div>
                                        <dom-if if="[[distinct.type]]">
                                            <template>
                                                <div class="layout horizontal item" on-tap="_distinctClick">
                                                    <vi-checkbox checked="{{distinct.checked}}"></vi-checkbox>
                                                    <span distinct-type$="[[distinct.type]]" inner-h-t-m-l="[[_getHighlightedDistinctDisplayValue(distinct.displayValue, searchText)]]"></span>
                                                </div>
                                            </template>
                                        </dom-if>
                                        <dom-if if="[[!distinct.type]]">
                                            <template>
                                                <div class="hasMore">
                                                    <vi-icon source="Selected"></vi-icon>
                                                    <vi-icon source="Ellipsis"></vi-icon>
                                                </div>
                                            </template>
                                        </dom-if>
                                    </div>
                                </template>
                            </vi-list>
                        </div>
                    </div>
                </div>
                <div id="resizehandle" on-track="_onResize"></div>
            </div>
        </vi-popup>
    </template>
</dom-if>`; }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.searchText = "";
    }
    _render(e) {
        e.stopPropagation();
        this._setRender(true);
        flush$1();
        microTask.run(() => {
            this.shadowRoot.querySelector("#filter").popup();
            this.removeAttribute("open");
        });
    }
    _update() {
        if (this.filtered = !!this.queryColumn && this.queryColumn.selectedDistincts.length > 0) {
            const objects = [];
            const textSearch = [];
            this.queryColumn.selectedDistincts.forEach(value => {
                if (value && value.startsWith("1|@"))
                    textSearch.push(value);
                else
                    objects.push(value);
            });
            let label = "";
            if (objects.length > 0)
                label += objects.map(o => this._getDistinctDisplayValue(o)).join(", ");
            if (textSearch.length > 0) {
                if (label.length > 0)
                    label += ", ";
                label += textSearch.map(t => this._getDistinctDisplayValue(t)).join(", ");
            }
            this.label = (!this.inversed ? "= " : "≠ ") + label;
        }
        else
            this.label = "=";
    }
    _getDistinctDisplayValue(value) {
        if (!String.isNullOrWhiteSpace(value) && value !== "|") {
            const indexOfPipe = value.indexOf("|");
            if (indexOfPipe === 0)
                return value.substr(1);
            if (indexOfPipe > 0)
                return value.substr(indexOfPipe + parseInt(value.substr(0, indexOfPipe), 10) + 1);
        }
        return value == null ? this.service?.getTranslatedMessage("DistinctNullValue") : this.service?.getTranslatedMessage("DistinctEmptyValue");
    }
    async _popupOpening(e) {
        if (!this.column.canFilter)
            return;
        const search = this.$.search || (this.$.search = this.shadowRoot.querySelector("#search"));
        this._focusElement(search);
        const filter = this.$.filter || (this.$.filter = this.shadowRoot.querySelector("#filter"));
        filter.closeDelay = parseInt(this.app.configuration.getSetting("vi-query-grid-column-filter.close-delay", "750"));
        if (this.column.canListDistincts && (!this.queryColumn.distincts || this.column.distincts.isDirty)) {
            this._setLoading(true);
            try {
                await this.queryColumn.refreshDistincts();
                this._setLoading(false);
            }
            catch (e) {
                this._setLoading(false);
                this.app.showAlert(e, "Error");
            }
        }
        else {
            const distinctsList = this.$.distincts || (this.$.distincts = this.shadowRoot.querySelector("#distincts"));
            distinctsList.scrollTop = 0;
        }
    }
    _searchTextChanged(searchText, oldSearchText) {
        if (!searchText && !oldSearchText)
            return;
        if (this.queryColumn && this.queryColumn.distincts && this.queryColumn.distincts.hasMore) {
            this._setLoading(true);
            this._searchTextDebouncer = Debouncer.debounce(this._searchTextDebouncer, timeOut.after(250), async () => {
                if (this.searchText !== searchText)
                    return;
                try {
                    await this.queryColumn.refreshDistincts(searchText);
                    if (this.searchText === searchText)
                        this._renderDistincts();
                }
                finally {
                    if (this.searchText === searchText)
                        this._setLoading(false);
                }
            });
        }
    }
    _getFilteredDistincts(distincts, searchText) {
        if (!searchText)
            return distincts;
        searchText = searchText.toLowerCase();
        return distincts.filter(d => {
            if (!d.displayValue)
                return false;
            return d.displayValue.toLowerCase().contains(searchText);
        });
    }
    _distinctClick(e) {
        const distinctValue = e.model.distinct.value;
        if (this.queryColumn.selectedDistincts.indexOf(distinctValue) === -1)
            this.queryColumn.selectedDistincts = this.queryColumn.selectedDistincts.concat([distinctValue]);
        else
            this.queryColumn.selectedDistincts = this.queryColumn.selectedDistincts.filter(d => d !== distinctValue);
        this._updateFilters();
        this._updateDistincts();
        e.stopPropagation();
    }
    async _updateFilters() {
        if (!this.column.query.filters)
            return;
        if (this.queryColumn.selectedDistincts.length > 0 && !this.column.query.filters.currentFilter) {
            const filter = await this.queryColumn.query.filters.createNew();
            this.column.query.filters.currentFilter = filter;
        }
    }
    async _updateDistincts() {
        this._setLoading(true);
        try {
            await this.column.query.search();
            await this.queryColumn.refreshDistincts(this.searchText);
        }
        finally {
            this._setLoading(false);
        }
    }
    _renderDistincts() {
        if (!this.queryColumn)
            return;
        const distinctType = !this.inversed ? "include" : "exclude";
        let distincts = this.queryColumn.selectedDistincts.map(v => ({
            type: distinctType,
            value: v,
            displayValue: this._getDistinctDisplayValue(v),
            checked: true
        }));
        if (this.queryColumn.distincts) {
            distincts = distincts.concat(this.queryColumn.distincts.matching.filter(v => this.queryColumn.selectedDistincts.indexOf(v) === -1).map(v => {
                return {
                    type: "matching",
                    value: v,
                    displayValue: this._getDistinctDisplayValue(v),
                    checked: false
                };
            })).concat(this.queryColumn.distincts.remaining.filter(v => this.queryColumn.selectedDistincts.indexOf(v) === -1).map(v => {
                return {
                    type: "remaining",
                    value: v,
                    displayValue: this._getDistinctDisplayValue(v),
                    checked: false
                };
            }));
            this.distincts = (this.queryColumn.distincts.hasMore ? distincts.concat([{}]) : distincts);
        }
        else
            this.distincts = distincts;
    }
    _getHighlightedDistinctDisplayValue(displayValue, searchText) {
        if (!searchText)
            return displayValue;
        searchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        const exp = new RegExp(`(${searchText})`, "gi");
        return displayValue.replace(exp, "<span class='match'>$1</span>");
    }
    async _search() {
        if (this.searchText) {
            this.queryColumn.selectedDistincts = this.queryColumn.selectedDistincts.concat(["1|@" + this.searchText]);
            this.searchText = "";
        }
        this._renderDistincts();
        if (!await this.column.query.search())
            return;
        this._renderDistincts();
        this._updateFilters();
        this._updateDistincts();
    }
    _inverse(e) {
        e.stopPropagation();
        this.queryColumn.selectedDistinctsInversed = !this.queryColumn.selectedDistinctsInversed;
        if (this.queryColumn.selectedDistincts.length > 0)
            this._updateDistincts();
    }
    _clear(e) {
        if (!this.filtered) {
            e.stopPropagation();
            return;
        }
        this.queryColumn.selectedDistincts = [];
        this._updateDistincts();
        Popup.closeAll();
    }
    _onResize(e) {
        const filterContent = this.$.filterContent || (this.$.filterContent = this.shadowRoot.querySelector("#filterContent"));
        const filter = this.$.filter || (this.$.filter = this.shadowRoot.querySelector("#filter"));
        if (e.detail.state === "start") {
            this.app.isTracking = true;
            filter.sticky = true;
            this._resizeStart = { width: filterContent.offsetWidth, height: filterContent.offsetHeight };
        }
        else if (e.detail.state === "track") {
            filterContent.style.width = `${this._resizeStart.width + e.detail.dx}px`;
            filterContent.style.height = `${this._resizeStart.height + e.detail.dy}px`;
        }
        else if (e.detail.state === "end") {
            filter.sticky = false;
            this._resizeStart = null;
            this.app.isTracking = false;
            const distinctsList = this.$.distincts || (this.$.distincts = this.shadowRoot.querySelector("#distincts"));
            distinctsList.dispatchEvent(new CustomEvent("iron-resize"));
        }
    }
    _catchClick(e) {
        e.stopPropagation();
    }
};
QueryGridColumnFilter = __decorate([
    WebComponent.register({
        properties: {
            column: Object,
            queryColumn: {
                type: Object,
                computed: "column.column"
            },
            distincts: Array,
            filtered: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            queryFiltering: {
                type: Boolean,
                computed: "queryColumn.query.isFiltering",
                reflectToAttribute: true
            },
            inversed: {
                type: Boolean,
                computed: "queryColumn.selectedDistinctsInversed"
            },
            loading: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            searchText: {
                type: String,
                observer: "_searchTextChanged"
            },
            disabled: {
                type: Boolean,
                computed: "!column.canFilter",
                reflectToAttribute: true
            },
            sensitive: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "queryColumn.isSensitive"
            },
            render: {
                type: Boolean,
                readOnly: true,
                value: false
            }
        },
        observers: [
            "_update(queryColumn.selectedDistincts, queryColumn.selectedDistinctsInversed, isConnected)",
            "_renderDistincts(queryColumn.selectedDistincts, queryColumn.distincts)"
        ],
        forwardObservers: [
            "queryColumn.selectedDistincts",
            "queryColumn.selectedDistinctsInversed",
            "queryColumn.distincts",
            "queryColumn.query.isFiltering"
        ]
    })
], QueryGridColumnFilter);

var _QueryGridColumnHeader__lastMeasuredColumn, _QueryGridColumnHeader__minimumColumnWidth, _QueryGridColumnHeader__calculatedWidth, _QueryGridColumnHeader__resizingRAF;
let resizeObserver;
resizeObserver = new ResizeObserver(allEntries => {
    window.requestAnimationFrame(() => {
        const parents = new Map();
        allEntries.forEach(e => {
            const parent = parents.get(e.target.parentElement) || parents.set(e.target.parentElement, []).get(e.target.parentElement);
            parent.push(e);
        });
        parents.forEach((entries, parent) => {
            try {
                parent?.dispatchEvent(new CustomEvent("column-width-changed", {
                    detail: {
                        type: "column",
                        entries: entries.map(e => {
                            const header = e.target;
                            let width = e["borderBoxSize"] != null ? e["borderBoxSize"][0].inlineSize : header.offsetWidth;
                            return [header.column.name, width];
                        }),
                    },
                    bubbles: true,
                    cancelable: true,
                    composed: true
                }));
            }
            finally {
                entries.forEach(e => resizeObserver.unobserve(e.target));
            }
        });
    });
});
let QueryGridColumnHeader = class QueryGridColumnHeader extends WebComponent {
    constructor() {
        super(...arguments);
        _QueryGridColumnHeader__lastMeasuredColumn.set(this, void 0);
        _QueryGridColumnHeader__minimumColumnWidth.set(this, void 0);
        _QueryGridColumnHeader__calculatedWidth.set(this, void 0);
        _QueryGridColumnHeader__resizingRAF.set(this, void 0);
    }
    static get template() { return html$3 `<style>:host {
  display: block;
  box-sizing: border-box;
  border-right: 1px solid var(--theme-light-border);
  background-color: white;
}
:host .label {
  display: flex;
  position: relative;
  padding: 0 var(--vi-query-grid-cell-padding, var(--theme-h5));
  position: relative;
  color: #808080;
  white-space: nowrap;
  overflow: hidden;
}
:host .label[can-sort] > * {
  cursor: pointer;
}
:host .label > label {
  display: block;
  line-height: var(--vi-query-grid-header-height, var(--vi-query-grid-row-height));
  white-space: nowrap;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding-right: var(--theme-h5);
  color: var(--color);
}
:host .label > vi-icon {
  fill: var(--color);
  line-height: var(--theme-h2);
  height: var(--theme-h2);
  --vi-icon-height: 12px;
}
:host vi-popup-menu vi-button {
  height: var(--vi-query-grid-header-height, var(--vi-query-grid-row-height));
}
:host vi-button[icon=CaretDown]::after {
  position: absolute;
  left: 0;
  top: 2px;
  bottom: 2px;
  width: 1px;
  content: " ";
  background-color: var(--theme-light-border);
}
:host .resizer {
  width: 0.5em;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  background-color: transparent;
  cursor: ew-resize;
  transform: translate3d(0.25em, 0, 0);
}
:host(.resizing) .resizer::after, :host .resizer:hover::after {
  position: absolute;
  left: calc(var(--theme-h5) / 2);
  top: 0;
  bottom: 0;
  width: 2px;
  background-color: #888;
  content: " ";
}</style>

<div class="relative">
    <div class="layout horizontal relative">
        <div class="label flex relative" on-tap="_sort" can-sort$="[[canSort]]">
            <label class="flex">[[column.label]]</label>
            <vi-icon id="sortingIcon" source="[[sortingIcon]]" hidden$="[[!sorting]]"></vi-icon>
        </div>
        <dom-if if="[[!renderPopupMenu]]">
            <template>
                <vi-button icon="CaretDown" inverse on-tap="_renderPopupMenu"></vi-button>
            </template>
        </dom-if>
        <dom-if if="[[renderPopupMenu]]">
            <template>
                <vi-popup-menu right-align id="menu">
                    <vi-button slot="header" icon="CaretDown" inverse></vi-button>
                    <vi-popup-menu-item label="[[translateMessage('SortAscending', isConnected)]]" icon="SortAsc" on-tap="_sort" hidden$="[[!canSort]]" on-tap="_sortAsc"></vi-popup-menu-item>
                    <vi-popup-menu-item label="[[translateMessage('SortDescending', isConnected)]]" icon="SortDesc" on-tap="_sort" hidden$="[[!canSort]]"  on-tap="_sortDesc"></vi-popup-menu-item>
                    <vi-popup-menu-item-separator hidden$="[[!canSort]]"></vi-popup-menu-item-separator>
                    <vi-popup-menu-item label="[[groupByLabel]]" icon="QueryGrid_Group" on-tap="_group" hidden$="[[!canGroupBy]]"></vi-popup-menu-item>
                    <vi-popup-menu-item label="[[pinLabel]]" icon="Pin" checked$="[[isPinned]]" on-tap="_togglePin"></vi-popup-menu-item>
                    <vi-popup-menu-item label="[[translateMessage('HideColumn', isConnected)]]" icon="Eye" on-tap="_hide"></vi-popup-menu-item>
                    <vi-popup-menu-item-separator></vi-popup-menu-item-separator>
                    <vi-popup-menu-item label="[[translateMessage('Manage', isConnected)]]" icon="Configure" on-tap="_configure"></vi-popup-menu-item>
                </vi-popup-menu>
            </template>
        </dom-if>
    </div>
    <vi-query-grid-column-filter column="[[column]]" part="filter"></vi-query-grid-column-filter>
    <div class="resizer" on-track="_resizeTrack"></div>
</div>

<vi-icon name="QueryGrid_Group">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 2 8 L 2 14 L 22 14 L 22 8 L 2 8 z M 10 18 L 10 24 L 30 24 L 30 18 L 10 18 z " />
        </g>
    </svg>
</vi-icon>`; }
    _renderPopupMenu(e) {
        e.stopPropagation();
        this._setRenderPopupMenu(true);
        flush$1();
        const menu = this.shadowRoot.querySelector("#menu");
        menu.popup();
    }
    _columnChanged(column, oldColumn) {
        if (!column)
            return;
        this._setCanSort(column.canSort);
        this._setCanGroupBy(column.canGroupBy);
        this._setIsPinned(column.isPinned);
    }
    _computeSortingIcon(direction) {
        return direction === "ASC" ? "SortAsc" : (direction === "DESC" ? "SortDesc" : null);
    }
    _computeGroupByLabel(label) {
        return this.translateMessage("GroupByColumn", label);
    }
    _computePinLabel(isPinned) {
        return isPinned ? this.translations.Unpin : this.translations.Pin;
    }
    _sort(eventOrDirection) {
        let newSortingDirection;
        let multiSort = false;
        if (!this.canSort)
            return;
        if (typeof eventOrDirection === "string")
            newSortingDirection = eventOrDirection;
        else {
            multiSort = eventOrDirection.detail.sourceEvent.ctrlKey;
            switch (this.column.sortDirection) {
                case "ASC": {
                    newSortingDirection = "DESC";
                    break;
                }
                case "DESC": {
                    newSortingDirection = multiSort && this.column.query.sortOptions.length > 1 ? "" : "ASC";
                    break;
                }
                case "": {
                    newSortingDirection = "ASC";
                    break;
                }
            }
        }
        this.column.column.sort(newSortingDirection, multiSort);
    }
    _onContextmenu(e) {
        this._renderPopupMenu(e);
        e.preventDefault();
    }
    _sortAsc(e) {
        e.stopPropagation();
        this._sort("ASC");
    }
    _sortDesc(e) {
        e.stopPropagation();
        this._sort("DESC");
    }
    _group() {
        this.column.query.group(this.column.column);
    }
    _togglePin() {
        this.column.isPinned = !this.column.isPinned;
        this._setIsPinned(this.column.isPinned);
        this.fire("query-grid-column:update");
    }
    _hide() {
        this.column.isHidden = !this.column.isHidden;
        this.fire("query-grid-column:update");
    }
    async _configure() {
        this.fire("query-grid-column:configure");
    }
    _queueMeasure(column, isConnected) {
        if (!column || !isConnected || __classPrivateFieldGet(this, _QueryGridColumnHeader__lastMeasuredColumn, "f") === column?.column)
            return;
        resizeObserver.observe(this, { box: "border-box" });
        __classPrivateFieldSet(this, _QueryGridColumnHeader__lastMeasuredColumn, column.column, "f");
    }
    _resizeTrack(e, detail) {
        if (detail.state === "start") {
            if (!__classPrivateFieldGet(this, _QueryGridColumnHeader__minimumColumnWidth, "f"))
                __classPrivateFieldSet(this, _QueryGridColumnHeader__minimumColumnWidth, parseInt(getComputedStyle(this).getPropertyValue("--vi-query-grid--minimum-column-width") || "50"), "f");
            __classPrivateFieldSet(this, _QueryGridColumnHeader__calculatedWidth, Math.max(this.getBoundingClientRect().width, __classPrivateFieldGet(this, _QueryGridColumnHeader__minimumColumnWidth, "f")), "f");
            this.app.isTracking = true;
            this.classList.add("resizing");
        }
        else if (detail.state === "track") {
            if (__classPrivateFieldGet(this, _QueryGridColumnHeader__resizingRAF, "f"))
                cancelAnimationFrame(__classPrivateFieldGet(this, _QueryGridColumnHeader__resizingRAF, "f"));
            __classPrivateFieldSet(this, _QueryGridColumnHeader__resizingRAF, requestAnimationFrame(() => {
                this._resize(Math.max(__classPrivateFieldGet(this, _QueryGridColumnHeader__calculatedWidth, "f") + detail.dx, __classPrivateFieldGet(this, _QueryGridColumnHeader__minimumColumnWidth, "f")));
            }), "f");
        }
        else if (detail.state === "end") {
            this.classList.remove("resizing");
            __classPrivateFieldSet(this, _QueryGridColumnHeader__calculatedWidth, Math.max(__classPrivateFieldGet(this, _QueryGridColumnHeader__calculatedWidth, "f") + detail.dx, __classPrivateFieldGet(this, _QueryGridColumnHeader__minimumColumnWidth, "f")), "f");
            this.column.width = `${__classPrivateFieldGet(this, _QueryGridColumnHeader__calculatedWidth, "f")}px`;
            this._resize(__classPrivateFieldGet(this, _QueryGridColumnHeader__calculatedWidth, "f"), true);
            this.app.isTracking = false;
        }
    }
    _resize(width, save) {
        this.dispatchEvent(new CustomEvent("column-width-changed", {
            detail: {
                type: "current",
                entries: [[this.column.name, width]],
                save: save
            },
            bubbles: true,
            cancelable: true,
            composed: true
        }));
    }
    _computeName(column) {
        let safeName = column.name.replace(/[\. ]/g, "_");
        if (/^\d/.test(safeName))
            safeName = "_" + safeName;
        return safeName;
    }
};
_QueryGridColumnHeader__lastMeasuredColumn = new WeakMap();
_QueryGridColumnHeader__minimumColumnWidth = new WeakMap();
_QueryGridColumnHeader__calculatedWidth = new WeakMap();
_QueryGridColumnHeader__resizingRAF = new WeakMap();
QueryGridColumnHeader = __decorate([
    WebComponent.register({
        properties: {
            column: {
                type: Object,
                observer: "_columnChanged"
            },
            canSort: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            sortingIcon: {
                type: String,
                computed: "_computeSortingIcon(column.column.sortDirection)"
            },
            canGroupBy: {
                type: Boolean,
                readOnly: true
            },
            isPinned: {
                type: Boolean,
                readOnly: true
            },
            groupByLabel: {
                type: String,
                computed: "_computeGroupByLabel(column.label, translations)"
            },
            pinLabel: {
                type: String,
                computed: "_computePinLabel(isPinned, translations)"
            },
            renderPopupMenu: {
                type: Boolean,
                readOnly: true,
                value: false
            },
            name: {
                type: String,
                reflectToAttribute: true,
                computed: "_computeName(column)"
            }
        },
        forwardObservers: [
            "column.column.sortDirection"
        ],
        listeners: {
            "contextmenu": "_onContextmenu"
        },
        observers: [
            "_queueMeasure(column, isConnected)"
        ]
    })
], QueryGridColumnHeader);

let QueryGridFilterDialogName = class QueryGridFilterDialogName extends WebComponent {
    static get template() { return html$3 `<style include="vi-reset-css-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host vi-icon {
  width: var(--theme-h2);
  height: var(--theme-h2);
}
:host input {
  padding: 0 var(--theme-h5);
}
:host #group:not([grouping]) > vi-persistent-object-attribute-edit, :host #group:not([grouping]) > vi-icon {
  display: none !important;
}
:host #group > vi-icon {
  width: var(--theme-h2);
  height: var(--theme-h2);
}</style>

<vi-persistent-object-attribute-edit attribute="[[attribute]]" class="flex" reverse>
    <vi-button slot="left" icon="Folder" on-tap="_toggleGrouping" inverse tabindex="-1"></vi-button>
    <div class="layout horizontal flex">
        <input class="flex group" value="{{group::input}}" hidden$="[[!grouping]]" />
        <vi-icon source="ChevronRight" hidden$="[[!grouping]]"></vi-icon>
        <input class="flex name" value="{{name::input}}" />
    </div>
</vi-persistent-object-attribute-edit>`; }
    _attributeChanged(attribute) {
        if (!attribute)
            return;
        try {
            this._blockUpdate = true;
            const name = attribute.value;
            this._setGrouping(name ? name.contains("\n") : false);
            if (!this.grouping)
                this.name = name;
            else {
                const parts = name.split("\n");
                this.group = parts[0];
                this.name = parts[1];
            }
        }
        finally {
            this._blockUpdate = false;
        }
    }
    _focusInput(grouping, isConnected) {
        if (!this.isConnected)
            return;
        const input = this.shadowRoot.querySelector(`input.${grouping ? "group" : "name"}`);
        this._focusElement(input);
    }
    _toggleGrouping() {
        this._setGrouping(!this.grouping);
        if (!this.grouping)
            this.group = "";
    }
    _updateAttributeValue(attribute, name, group, isConnected) {
        if (!this.isConnected || this._blockUpdate)
            return;
        attribute.setValue(name && group ? `${group}\n${name}` : name);
    }
};
QueryGridFilterDialogName = __decorate([
    WebComponent.register({
        properties: {
            attribute: {
                type: Object,
                observer: "_attributeChanged"
            },
            grouping: {
                type: String,
                readOnly: true
            },
            group: {
                type: String,
                notify: true,
                value: null
            },
            name: {
                type: String,
                notify: true,
                value: null
            }
        },
        observers: [
            "_focusInput(grouping, isConnected)",
            "_updateAttributeValue(attribute, name, group, isConnected)",
        ]
    })
], QueryGridFilterDialogName);

let QueryGridFilterDialog = class QueryGridFilterDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host dialog {
  min-width: 400px;
}
:host main {
  padding: var(--theme-h4) var(--theme-h4) 0 var(--theme-h4);
}</style>

<vi-notification service-object="[[persistentObject]]"></vi-notification>
<main id="main">
    <vi-persistent-object-attribute-presenter attribute="[[persistentObject.attributes.Name]]">
        <template>
            <vi-query-grid-filter-dialog-name class="flex" attribute="[[attribute]]"></vi-query-grid-filter-dialog-name>
        </template>
    </vi-persistent-object-attribute-presenter>
    <vi-persistent-object-attribute-presenter attribute="[[persistentObject.attributes.IsDefault]]"></vi-persistent-object-attribute-presenter>
</main>
<footer class="layout horizontal-reverse">
    <vi-button inverse on-tap="cancel" label="[[translations.Cancel]]" disabled$="[[persistentObject.isBusy]]"></vi-button>
    <vi-button on-tap="_save" action-type="Default" label="[[translations.Save]]" disabled$="[[persistentObject.isBusy]]"></vi-button>
</footer>`); }
    constructor(_filters, _filter) {
        super();
        this._filters = _filters;
        this._filter = _filter;
        this._setPersistentObject(_filter.persistentObject);
        this.persistentObject.beginEdit();
    }
    async _save() {
        this.persistentObject.isNew;
        if (await this._filters.save(this._filter)) {
            super.close();
            return;
        }
        this._setPersistentObject(this._filter.persistentObject);
    }
    close(result) {
        this._filter.persistentObject.cancelEdit();
        super.close();
    }
};
QueryGridFilterDialog = __decorate([
    WebComponent.register({
        properties: {
            persistentObject: {
                type: Object,
                readOnly: true
            }
        },
        forwardObservers: [
            "persistentObject.isBusy"
        ]
    })
], QueryGridFilterDialog);

let QueryGridFilters = class QueryGridFilters extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  width: var(--vi-query-grid-row-height);
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
  align-self: flex-end;
}
:host > vi-popup-menu vi-button[slot=header] {
  position: relative;
  flex: 1;
  min-height: 0;
  min-width: 0;
  z-index: 1;
  text-align: center;
  line-height: var(--vi-query-grid-row-height);
  height: var(--vi-query-grid-row-height);
  width: var(--vi-query-grid-row-height);
  padding: 0;
}
:host([hidden]) {
  display: block !important;
}
:host([hidden]) > vi-popup-menu {
  visibility: hidden;
}</style>

<vi-popup-menu disabled="[[disabled]]">
    <vi-button slot="header" inverse$="[[!isFiltering]]" icon="Filter_Menu" disabled$="[[disabled]]"></vi-button>
    <dom-if if="[[canReset]]">
        <template>
            <vi-popup-menu-item icon="Filter_Reset" label="[[translations.Reset]]" on-tap="_reset"></vi-popup-menu-item>
        </template>
    </dom-if>
    <dom-if if="[[canSave]]">
        <template>
            <vi-popup-menu-item icon="Filter_Save" label="[[saveCurrentLabel]]" on-tap="_save"></vi-popup-menu-item>
            <vi-popup-menu-item icon-space label="[[translations.SaveAs]]" on-tap="_saveAs"></vi-popup-menu-item>
        </template>
    </dom-if>
    <dom-if if="[[canSaveAs]]">
        <template>
            <vi-popup-menu-item icon="Filter_Save" label="[[translations.SaveAs]]" on-tap="_saveAs"></vi-popup-menu-item>
        </template>
    </dom-if>
    <dom-if if="[[userFilters]]">
        <template>
            <vi-popup-menu-item-separator hidden$="[[op_none(canReset, canSave, canSaveAs)]]"></vi-popup-menu-item-separator>
            <dom-repeat items="[[userFilters]]" as="filter" filter="_hasGroupName">
                <template>
                    <vi-popup-menu-item icon-space label="[[filter.groupName]]" icon="Folder" on-tap="_catchGroupTap">
                        <dom-repeat items="[[filter.children]]" as="filter">
                            <template>
                                <vi-popup-menu-item-with-actions icon-space label="[[_filterNonGroupName(filter.filter.name)]]" on-tap="_load">
                                    <vi-button slot="button" icon="Action_Edit" inverse on-tap="_edit"></vi-button>
                                    <vi-button slot="button" icon="Action_Delete" inverse on-tap="_delete"></vi-button>
                                </vi-popup-menu-item-with-actions>
                            </template>
                        </dom-repeat>
                    </vi-popup-menu-item>
                </template>
            </dom-repeat>
            <dom-repeat items="[[userFilters]]" as="filter" filter="_hasNoGroupName">
                <template>
                    <vi-popup-menu-item-with-actions icon-space label="[[filter.filter.name]]" on-tap="_load">
                        <vi-button slot="button" icon="Action_Edit" inverse on-tap="_edit"></vi-button>
                        <vi-button slot="button" icon="Action_Delete" inverse on-tap="_delete"></vi-button>
                    </vi-popup-menu-item-with-actions>
                </template>
            </dom-repeat>
        </template>
    </dom-if>
    <dom-if if="[[lockedFilters]]">
        <template>
            <vi-popup-menu-item-separator hidden$="[[op_none(canReset, canSave, canSaveAs, userFilters)]]"></vi-popup-menu-item-separator>
            <dom-repeat items="[[lockedFilters]]" as="filter">
                <template>
                    <dom-if if="[[filter.groupName]]">
                        <template>
                            <vi-popup-menu-item icon-space label="[[filter.groupName]]" icon="Folder">
                                <dom-repeat items="[[filter.children]]" as="filter">
                                    <template>
                                        <vi-popup-menu-item-split icon-space label="[[_filterNonGroupName(filter.filter.name)]]" on-tap="_load"></vi-popup-menu-item-split>
                                    </template>
                                </dom-repeat>
                            </vi-popup-menu-item>
                        </template>
                    </dom-if>
                    <dom-if if="[[!filter.groupName]]">
                        <template>
                            <vi-popup-menu-item-split icon-space label="[[_filterNonGroupName(filter.filter.name)]]" on-tap="_load"></vi-popup-menu-item-split>
                        </template>
                    </dom-if>
                </template>
            </dom-repeat>
        </template>
    </dom-if>
</vi-popup-menu>`; }
    _computeUserFilters(filters) {
        return this._computeFilters(filters, false);
    }
    _computeLockedFilters(filters) {
        return this._computeFilters(filters, true);
    }
    _computeFilters(filters, isLocked) {
        if (!filters)
            return null;
        const orderedFilters = filters.filter(f => f.isLocked === isLocked).orderBy(f => f.name.split("\n", 2)[0].toLowerCase());
        if (orderedFilters.length === 0)
            return null;
        const result = [];
        let group;
        orderedFilters.forEach(filter => {
            if (!filter.name)
                return;
            const nameParts = filter.name.split("\n", 2);
            if (nameParts.length === 1)
                result.push({ filter: filter });
            else {
                if (group && group.groupName === nameParts[0])
                    group.children.push({ filter: filter });
                else {
                    result.push(group = {
                        groupName: nameParts[0],
                        children: [{ filter: filter }]
                    });
                }
            }
        });
        return result;
    }
    _catchGroupTap(e) {
        e.stopPropagation();
    }
    _filterNonGroupName(name) {
        if (!name)
            return name;
        const nameParts = name.split("\n", 2);
        return nameParts.length === 1 ? nameParts[0] : nameParts[1];
    }
    _computeHidden(filters) {
        return !filters;
    }
    _computeDisabled(filters, currentFilter) {
        return (!filters || filters.length === 0) && !currentFilter;
    }
    _computeHasFilters(filters) {
        return !!filters && filters.length > 0;
    }
    _computeCanReset(currentFilter) {
        return !!currentFilter;
    }
    _computeCanSave(currentFilter, canSaveAs) {
        return !canSaveAs && !!currentFilter && !currentFilter.isLocked && !currentFilter.persistentObject.isNew;
    }
    _computeCurrentFilterSaveLabel(currentFilter) {
        return !!currentFilter ? `${this.translateMessage("Save")} '${currentFilter.name}'` : "";
    }
    _computeCanSaveAs(currentFilter) {
        return !!currentFilter && currentFilter.persistentObject.isNew;
    }
    _computeFilterEditLabel(filter) {
        return this.query.service.actionDefinitions["Edit"].displayName;
    }
    _reset() {
        Popup.closeAll();
        this.query.filters.currentFilter = null;
    }
    _load(e) {
        this.queryFilters.currentFilter = e.model.filter.filter;
    }
    async _saveAs() {
        this.app.showDialog(new QueryGridFilterDialog(this.query.filters, await this.query.filters.createNew()));
    }
    _save() {
        this.query.filters.save();
    }
    async _edit(e) {
        const filter = e.model.filter.filter;
        this.app.showDialog(new QueryGridFilterDialog(this.query.filters, filter));
    }
    async _delete(e) {
        const filter = e.model.filter.filter;
        const result = await this.app.showMessageDialog({
            title: this._nonGroupName(filter.name),
            titleIcon: "Action_Delete",
            message: this.translateMessage("AskForDeleteFilter", this._nonGroupName(filter.name)),
            actions: [this.translateMessage("Delete"), this.translateMessage("Cancel")],
            actionTypes: ["Danger"]
        });
        if (result === 0)
            await this.query.filters.delete(filter);
    }
    _showUserFilterSeparator(canReset, canSave, canSaveAs) {
        return canReset || canSave || canSaveAs;
    }
    _hasGroupName(filter) {
        return !!filter.groupName;
    }
    _hasNoGroupName(filter) {
        return !filter.groupName;
    }
    _nonGroupName(name) {
        if (!name)
            return name;
        const nameParts = name.split("\n", 2);
        return nameParts.length === 1 ? nameParts[0] : nameParts[1];
    }
};
QueryGridFilters = __decorate([
    WebComponent.register({
        properties: {
            query: Object,
            queryFilters: {
                type: Object,
                computed: "query.filters"
            },
            hidden: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHidden(query.filters)"
            },
            filters: {
                type: Array,
                computed: "query.filters.filters"
            },
            userFilters: {
                type: Array,
                computed: "_computeUserFilters(filters)"
            },
            lockedFilters: {
                type: Array,
                computed: "_computeLockedFilters(filters)"
            },
            hasFilters: {
                type: Boolean,
                computed: "_computeHasFilters(filters)"
            },
            currentFilter: {
                type: Object,
                computed: "query.filters.currentFilter"
            },
            isFiltering: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "query.isFiltering"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeDisabled(filters, currentFilter)"
            },
            canReset: {
                type: Boolean,
                computed: "_computeCanReset(currentFilter)"
            },
            canSave: {
                type: Boolean,
                computed: "_computeCanSave(currentFilter, canSaveAs)"
            },
            canSaveAs: {
                type: Boolean,
                computed: "_computeCanSaveAs(currentFilter)"
            },
            editLabel: {
                type: String,
                computed: "query.filters.actions.Edit.displayName"
            },
            saveCurrentLabel: {
                type: String,
                computed: "_computeCurrentFilterSaveLabel(currentFilter)"
            }
        },
        forwardObservers: [
            "query.isFiltering",
            "query.filters",
            "query.filters.filters",
            "query.filters.currentFilter"
        ]
    })
], QueryGridFilters);

let QueryGridFooter = class QueryGridFooter extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: grid;
  grid-template-columns: var(--vi-query-grid-columns);
}
:host .column {
  padding: 0 var(--theme-h5);
  line-height: var(--vi-query-grid-row-height);
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
:host .column[is-numeric] {
  text-align: right;
}</style>

<dom-repeat items="[[columns]]" as="column">
    <template>
        <div class="column" is-numeric$="[[_computeIsNumeric(column)]]">[[_computeItemValue(item, column)]]</div>
    </template>
</dom-repeat>`; }
    _computeIsNumeric(column) {
        return DataType.isNumericType(column.type);
    }
    _computeItemValue(item, column) {
        const value = item.getValue(column.name);
        if (value == null)
            return "";
        const format = item.getTypeHint("displayformat", column.column.getTypeHint("displayformat", null));
        return !String.isNullOrEmpty(format) ? String.format(format, value) : value;
    }
};
QueryGridFooter = __decorate([
    WebComponent.register({
        properties: {
            item: Object,
            columns: Array
        }
    })
], QueryGridFooter);

let QueryGridGrouping = class QueryGridGrouping extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
}
:host vi-button {
  width: var(--vi-query-grid-row-height);
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
}</style>

<vi-popup-menu disabled$="[[isBusy]]">
    <vi-button slot="header" icon="QueryGrid_Group" inverse disabled$="[[isBusy]]"></vi-button>
    <vi-popup-menu-item icon="QueryGrid_Group_Collapse" label="Collapse all" on-tap="_toggleCollapse"></vi-popup-menu-item>
    <vi-popup-menu-item icon="QueryGrid_Group_Expand" label="Expand all" on-tap="_toggleCollapse"></vi-popup-menu-item>
    <vi-popup-menu-item-separator></vi-popup-menu-item-separator>
    <vi-popup-menu-item icon="Remove" label="Remove grouping" on-tap="_remove"></vi-popup-menu-item>
</vi-popup-menu>

<vi-icon name="QueryGrid_Group_Collapse">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 10,3 H 22 L 16,9 Z" />
            <path d="m 6,11.666666 h 20 v 3 H 6 Z" />
            <path d="m 6,17.333333 h 20 v 3 H 6 Z" />
            <path d="m 16,23 -6,6 h 12 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="QueryGrid_Group_Expand">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 10,9 H 22 L 16,3 Z" />
            <path d="m 6,11.666666 h 20 v 3 H 6 Z" />
            <path d="m 6,17.333333 h 20 v 3 H 6 Z" />
            <path d="M 16,29 10,23 H 22 Z" />
        </g>
    </svg>
</vi-icon>`; }
    _toggleCollapse(e) {
        const collapse = e.currentTarget.icon === "QueryGrid_Group_Collapse";
        this.query.groupingInfo.groups.forEach(g => g.isCollapsed = collapse);
        this.fire("scroll-top");
    }
    _remove() {
        this.query.group("");
    }
};
QueryGridGrouping = __decorate([
    WebComponent.register({
        properties: {
            query: Object
        }
    })
], QueryGridGrouping);

var ActionButton_1;
let ActionButton = ActionButton_1 = class ActionButton extends ConfigurableWebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  box-sizing: border-box;
}
:host vi-button {
  justify-content: start;
  padding: 0 var(--theme-h5);
  text-align: left;
  height: var(--theme-h1);
  line-height: var(--theme-h1);
  min-width: 100%;
  white-space: nowrap;
  overflow: hidden;
}
:host vi-button vi-icon {
  height: var(--theme-h1);
}
:host vi-button vi-icon.action-icon, :host vi-button vi-icon.down-icon {
  width: var(--theme-h3);
}
:host vi-button .icon-space {
  height: var(--theme-h1);
  width: var(--theme-h2);
}
:host vi-button span {
  flex: 1;
  padding: 0 var(--theme-h5);
}
:host vi-popup-menu {
  min-width: 100%;
}
:host([inverse]) vi-popup[open] vi-button.groupActions, :host([inverse]) vi-popup-menu[open] vi-button:not(:hover) {
  background-color: var(--color-semi-faint);
}
:host([disabled]) vi-button[disabled] {
  opacity: 1;
}
:host([disabled]) vi-button span {
  opacity: 0.5;
}
:host([disabled]) vi-button vi-icon {
  opacity: 0.4;
}
:host([grouped]) vi-icon.down-icon {
  transform: rotate(-90deg);
}
:host([overflow]) vi-button, :host([grouped]) vi-button {
  padding: 0 !important;
}
:host([overflow]) vi-button vi-icon.action-icon, :host([grouped]) vi-button vi-icon.action-icon {
  width: var(--theme-h2);
}
:host([overflow]) vi-button span, :host([grouped]) vi-button span {
  padding: 0 var(--theme-h4);
}
:host([overflow]) vi-icon, :host([grouped]) vi-icon {
  vertical-align: top;
  width: var(--theme-h2);
}
:host([overflow]) vi-icon.down-icon, :host([grouped]) vi-icon.down-icon {
  transform: rotate(-90deg);
}
:host([overflow]) vi-icon.action-icon, :host([overflow]) .icon-space, :host([grouped]) vi-icon.action-icon, :host([grouped]) .icon-space {
  background-color: rgba(0, 0, 0, 0.04);
}
:host([no-label]:not([force-label])) vi-button span, :host([pinned]:not([force-label])) vi-button span {
  display: none;
}
:host(:focus) {
  outline: none;
}
:host([hidden]) {
  display: none !important;
}</style>

<dom-if if="[[!isGroup]]">
    <template>
        <dom-if if="[[!options]]">
            <template>
                <vi-button disabled="[[!canExecute]]" header on-tap="_onExecuteWithoutOptions" inverse="[[inverse]]">
                    <div class="layout horizontal">
                        <vi-icon class="action-icon" source="[[icon]]"></vi-icon>
                        <div class="icon-space" hidden$="[[!iconSpace]]"></div>
                        <span class="label">[[action.displayName]]</span>
                    </div>
                </vi-button>
            </template>
        </dom-if>
        <dom-if if="[[options]]">
            <template>
                <vi-popup-menu open-on-hover="[[_computeOpenOnHover(overflow, openOnHover)]]" disabled="[[!canExecute]]" placement="[[_getPlacement(overflow, grouped)]]" auto-width="[[!overflow]]">
                    <vi-button disabled="[[!canExecute]]" slot="header" header inverse="[[inverse]]" class="options">
                        <div class="layout horizontal flex">
                            <vi-icon class="action-icon" source="[[icon]]"></vi-icon>
                            <div class="icon-space" hidden$="[[!iconSpace]]"></div>
                            <span class="label flex">[[action.displayName]]</span>
                            <vi-icon class="down-icon" source="Down"></vi-icon>
                        </div>
                    </vi-button>
                    <dom-repeat items="[[options]]" as="option">
                        <template>
                            <vi-popup-menu-item label="[[option.value]]" on-tap="_onExecuteWithOption"></vi-popup-menu-item>
                        </template>
                    </dom-repeat>
                </vi-popup-menu>
            </template>
        </dom-if>
    </template>
</dom-if>
<dom-if if="[[isGroup]]">
    <template>
        <vi-popup disabled="[[!canExecute]]" open-on-hover="[[_computeOpenOnHover(overflow, openOnHover)]]" placement="[[_getPlacement(overflow, grouped)]]" auto-width="[[!overflow]]">
            <vi-button disabled="[[!canExecute]]" slot="header" inverse="[[inverse]]" class="groupActions">
                <div class="layout horizontal flex">
                    <vi-icon class="action-icon" source="[[icon]]"></vi-icon>
                    <div class="icon-space" hidden$="[[!iconSpace]]"></div>
                    <span class="label flex">[[action.displayName]]</span>
                    <vi-icon class="down-icon" source="Down"></vi-icon>
                </div>
            </vi-button>
            <div content>
                <dom-repeat items="[[action.actions]]" as="groupAction">
                    <template>
                        <vi-action-button grouped open-on-hover action="[[groupAction]]" inverse></vi-action-button>
                    </template>
                </dom-repeat>
            </div>
        </vi-popup>
    </template>
</dom-if>`; }
    constructor(item, action) {
        super();
        this.item = item;
        this.action = action;
        if (item && action)
            this._applyItemSelection(item, action);
    }
    async connectedCallback() {
        super.connectedCallback();
        if (this.grouped) {
            const groupParent = this.findParent(p => p instanceof ActionButton_1 && p.isGroup);
            if (groupParent && groupParent.item && this.action) {
                this.item = groupParent.item;
                this._applyItemSelection(groupParent.item, this.action);
            }
        }
    }
    _applyItemSelection(item, action) {
        const args = {
            name: action.name,
            isVisible: action.isVisible,
            canExecute: action.definition.selectionRule(1),
            options: action.options
        };
        action.service.hooks.onSelectedItemsActions(item.query, [item], args);
        this._setCanExecute(args.canExecute);
        this._setHidden(!args.isVisible);
        this._setOptions(args.options && args.options.length > 0 ? args.options.map((value, index) => {
            return {
                key: index,
                value: value
            };
        }) : null);
        this._skipObserver = true;
    }
    _onExecuteWithoutOptions(e) {
        if (!this.canExecute) {
            e.stopPropagation();
            return;
        }
        if (!this.options)
            this._execute();
        e.stopPropagation();
        e.preventDefault();
    }
    _onExecuteWithOption(e) {
        if (!this.canExecute) {
            e.stopPropagation();
            return;
        }
        this._execute(e.model.option.key);
    }
    _execute(option = -1) {
        if (!(this.action instanceof Action))
            return;
        if (this.canExecute) {
            if (!this.item)
                this.action.execute({
                    menuOption: option
                });
            else {
                this.action.execute({
                    menuOption: option,
                    parameters: this.options && option < this.options.length ? { MenuLabel: this.options[option].value } : null,
                    selectedItems: [this.item]
                });
            }
        }
    }
    _observeAction(canExecute, isVisible, options) {
        if (this._skipObserver)
            return;
        this._setCanExecute(this.item ? this.action.definition.selectionRule(1) : canExecute);
        this._setHidden(!this.action.isVisible);
        this._setOptions(this.action.options && this.action.options.length > 0 ? this.action.options.map((value, index) => {
            return {
                key: index,
                value: value
            };
        }) : null);
    }
    _computeDisabled(canExecute) {
        return !canExecute;
    }
    _computeIsGroup(action) {
        return action instanceof ActionGroup;
    }
    _computeTitle(action, pinned) {
        return pinned ? action.displayName : null;
    }
    _computeIcon(action) {
        if (!action)
            return "";
        return action.isPinned && !exists(action.definition.icon) ? "Action_Default$" : action.definition.icon;
    }
    _computeHasIcon(icon) {
        return !String.isNullOrEmpty(icon) && exists(icon);
    }
    _computeIconSpace(icon, siblingIcon, overflow, grouped) {
        return (overflow || grouped) && !exists(icon) && siblingIcon;
    }
    _computeSiblingIcon(overflow, grouped, isConnected) {
        const siblingIcon = (overflow || grouped) && isConnected && this.parentElement != null && Array.from(this.parentElement.children).find((c) => c.action && exists(this._computeIcon(c.action))) != null;
        this._setSiblingIcon(siblingIcon);
        if (siblingIcon) {
            Array.from(this.parentElement.children).forEach((ab) => {
                if (ab instanceof ActionButton_1 && ab !== this)
                    ab._setSiblingIcon(true);
            });
        }
    }
    _computeOpenOnHover(overflow, openOnHover) {
        return overflow || openOnHover;
    }
    _getPlacement(overflow, grouped) {
        return overflow || grouped ? "right-start" : "bottom-start";
    }
    _hiddenChanged() {
        this.fire("sizechanged", null);
    }
    _configure(e) {
        if (!(this.action instanceof Action))
            return;
        if ((this.action.parent && this.action.parent.isSystem) || (this.action.query && this.action.query.isSystem))
            return;
        e.detail.push({
            label: `Action: ${this.action.name}`,
            icon: "viConfigure",
            action: () => {
                this.app.changePath(`management/persistent-object.1bf5e50c-ee7d-4205-8ccf-46ab68e25d63/${this.action.name}`);
            }
        });
    }
};
ActionButton = ActionButton_1 = __decorate([
    ConfigurableWebComponent.register({
        properties: {
            action: Object,
            item: Object,
            icon: {
                type: String,
                computed: "_computeIcon(action)"
            },
            hasIcon: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasIcon(icon)"
            },
            siblingIcon: {
                type: Boolean,
                readOnly: true
            },
            iconSpace: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeIconSpace(icon, siblingIcon, overflow, grouped)"
            },
            pinned: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "action.isPinned"
            },
            noLabel: {
                type: Boolean,
                reflectToAttribute: true
            },
            forceLabel: {
                type: Boolean,
                reflectToAttribute: true
            },
            overflow: {
                type: Boolean,
                reflectToAttribute: true,
                value: null
            },
            canExecute: {
                type: Boolean,
                readOnly: true
            },
            disabled: {
                type: Boolean,
                computed: "_computeDisabled(canExecute)",
                reflectToAttribute: true
            },
            hidden: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                observer: "_hiddenChanged"
            },
            options: {
                type: Array,
                readOnly: true
            },
            openOnHover: {
                type: Boolean,
                reflectToAttribute: true,
                value: null
            },
            grouped: {
                type: Boolean,
                reflectToAttribute: true,
                value: null
            },
            title: {
                type: String,
                reflectToAttribute: true,
                computed: "_computeTitle(action, pinned)"
            },
            isGroup: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeIsGroup(action)"
            },
            inverse: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            }
        },
        listeners: {
            "vi:configure": "_configure"
        },
        observers: [
            "_observeAction(action.canExecute, action.isVisible, action.options)",
            "_computeSiblingIcon(overflow, grouped, isConnected)"
        ],
        forwardObservers: [
            "action.isPinned",
            "action.canExecute",
            "action.isVisible",
            "action.options"
        ]
    })
], ActionButton);

let Icon = class Icon extends WebComponent {
    constructor() {
        super(...arguments);
        this._aliases = [];
    }
    static get template() { return html$3 `<style>:host {
  position: relative;
  display: block;
  pointer-events: none;
}
:host([unresolved]) {
  display: none !important;
}
:host > div {
  display: grid;
  place-items: center;
  height: 100%;
}
:host svg {
  width: var(--vi-icon-width, 16px);
  height: var(--vi-icon-height, 16px);
  fill: var(--vi-icon-fill, inherit);
  color: var(--vi-icon-fill, inherit);
}
:host(.size-h1) svg {
  width: var(--theme-h1);
  height: var(--theme-h1);
}
:host(.size-h2) svg {
  width: var(--theme-h2);
  height: var(--theme-h2);
}
:host(.size-h3) svg {
  width: var(--theme-h3);
  height: var(--theme-h3);
}
:host(.size-h4) svg {
  width: var(--theme-h4);
  height: var(--theme-h4);
}
:host(.size-h5) svg {
  width: var(--theme-h5);
  height: var(--theme-h5);
}</style>

<div id="svgHost"></div>`; }
    connectedCallback() {
        super.connectedCallback();
        if (this.name && !exists(this.name))
            add(this);
    }
    get aliases() {
        return this._aliases;
    }
    addAlias(...alias) {
        this._aliases.push(...alias);
    }
    async _load(source, isConnected) {
        if (isConnected === undefined || source === undefined)
            return;
        if (this._source === source)
            return;
        if (this.$.svgHost.children.length > 0)
            this.$.svgHost.innerHTML = "";
        const resource = load(this._source = source);
        if (!resource && source?.indexOf(":") > 0) {
            const response = await fetch(`https://icons.vidyano.com/${source.replace(":", "/")}.svg`);
            if (response.ok) {
                const svgText = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgText, "image/svg+xml");
                let svgEl = doc.documentElement;
                if (svgEl.nodeName.toLowerCase() !== "svg") {
                    const container = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    container.appendChild(svgEl.cloneNode(true));
                    svgEl = container;
                }
                this.$.svgHost.appendChild(svgEl);
                this._setUnresolved(false);
                add(source, svgText);
                return;
            }
        }
        this._setUnresolved(!resource);
        if (this.unresolved)
            return;
        Array.from(resource.children).forEach((child) => {
            this.$.svgHost.appendChild(child.cloneNode(true));
        });
        this.$.svgHost.querySelectorAll("svg").forEach(svg => svg.setAttribute("part", "svg"));
    }
};
Icon = __decorate([
    WebComponent.register({
        properties: {
            name: {
                type: String,
                reflectToAttribute: true
            },
            source: {
                type: String,
                observer: "_load",
                reflectToAttribute: true
            },
            unresolved: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                value: true
            }
        },
        observers: [
            "_load(source, isConnected)"
        ]
    })
], Icon);
add(html$3 `<vi-icon name="Action_Default$">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 25.095139,2.6002179 24.640776,0 22.852563,1.9434153 20.241099,1.5722771 21.53446,3.8722102 20.374933,6.2418724 22.961656,5.7200294 24.860085,7.5588513 25.164868,4.9361402 27.497415,3.6978876 25.095139,2.6002179 Z m 3.569677,15.2402901 -0.20469,-1.405826 -0.993076,1.016694 -1.39908,-0.241802 0.661302,1.247249 -0.661302,1.241626 1.39908,-0.245175 0.993076,1.007696 0.20469,-1.405826 1.274241,-0.63206 -1.274241,-0.582576 z M 4.7128949,5.9978209 5.7790743,5.5794467 6.7282887,6.2193791 6.6585596,5.0800968 7.5605385,4.3749341 6.4527466,4.0870206 6.0602397,3.0107194 5.4450497,3.9768038 4.3012687,4.0172915 5.0278001,4.900151 4.7128949,5.9978209 Z M 10.919903,9.1839874 12.068182,7.9513582 13.733806,8.1976591 12.915052,6.7232276 13.665202,5.216181 12.013074,5.5400836 10.81081,4.3603134 10.606122,6.0349348 9.1125721,6.8132006 l 1.5272899,0.7119108 0.280041,1.658876 z m 7.642076,2.4945006 c -0.6613,-0.412752 -1.318104,-0.693917 -1.901804,-0.81988 -0.553333,-0.101213 -1.168522,-0.166449 -1.602643,0.420624 L 2.0609426,32 9.5736825,32 20.448036,14.661091 c 0.340773,-0.647806 0.0135,-1.170773 -0.318279,-1.626262 -0.365515,-0.473482 -0.905352,-0.943591 -1.567778,-1.356341 z m -4.072401,10.363757 c -0.285663,-0.445366 -0.832249,-0.960461 -1.54416,-1.410325 -0.710786,-0.445366 -1.414824,-0.714162 -1.941166,-0.773768 l 4.972129,-7.942361 c 0.07086,-0.01687 0.294663,-0.02363 0.610692,0.07198 0.389133,0.104593 0.882859,0.320529 1.37771,0.63206 0.566831,0.350894 1.021194,0.76252 1.274242,1.092046 0.127087,0.164201 0.200191,0.304783 0.219309,0.376761 0.0023,0.0067 0.0045,0.01237 0.0045,0.01687 l -4.973255,7.936737 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_BulkEdit">
    <svg viewBox="0 0 32 32">
        <g>
            <path style="fill:none;stroke-width:2;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
                  d="m 1.0024198,16.014565 c -0.1608928,7.226584 5.7144461,13.988806 12.8935162,14.850338 6.213085,0.9092 12.840028,-2.454963 15.554166,-8.162582 2.727101,-5.426499 1.816556,-12.494514 -2.4397,-16.88801 C 22.925671,1.386365 16.078282,-0.265778 10.483747,2.073448 5.1630126,4.1605 1.2329644,9.452561 1.0239062,15.197949 c -0.014637,0.27194 -0.021821,0.544283 -0.021486,0.816616 z" />
            <g transform="matrix(1.53421,0,0,1.53421,-2.410513,-2.41052)">
                <g transform="translate(-433.13094,-501.35006)">
                    <path d="m 437.79741,519.82082 c 1.33945,0.75933 2.67075,1.53336 4.00857,2.29597 -1.19117,0.56055 -2.39374,1.09664 -3.58327,1.66209 l -0.0358,0 c -0.13851,-1.31827 -0.26235,-2.63817 -0.38945,-3.95806 z m 5.90206,-12.76227 c 2.17701,1.23843 4.34587,2.48989 6.51963,3.73481 -1.66861,2.89726 -3.31277,5.80918 -5.00583,8.69178 -0.12058,-0.36664 -0.24605,-0.73164 -0.37479,-1.09339 -0.63713,-0.0652 -1.27427,-0.12711 -1.90977,-0.19719 -0.10755,-0.3976 -0.21998,-0.79519 -0.32427,-1.19278 -0.62573,-0.0326 -1.25146,-0.0408 -1.87719,-0.0717 -0.17272,-0.43507 -0.34382,-0.87016 -0.51655,-1.30523 -0.50025,0.0408 -0.99888,0.0913 -1.49751,0.13688 1.64742,-2.91029 3.32907,-5.7994 4.98628,-8.70317 z m 3.09605,-4.13731 0.0261,0 c 0.32264,0.0603 0.63061,0.18413 0.91415,0.34873 1.37204,0.80497 2.76201,1.57898 4.13405,2.38233 0.42204,0.2265 0.65342,0.72512 0.58173,1.19605 -0.0734,0.62247 -0.46767,1.14066 -0.76913,1.67024 -2.21123,-1.26938 -4.42409,-2.53225 -6.63207,-3.80652 0.41389,-0.72512 0.80009,-1.67187 1.7452,-1.79082 z" />
                </g>
            </g>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_AddReference">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 21.048828,0.734375 0,6.9746094 -7.107422,0 0,3.3222656 7.105469,0 0,6.972656 3.392578,0 0,-6.972656 7.103516,0 0,-3.3222656 -7.103516,0 0,-6.9746094 z m -20.59179675,12.792969 0,4.066406 15.47667275,0 0,-4.066406 z m 0,6.835937 0,4.072266 15.47667275,0 0,-4.072266 z m 0,6.841797 0,4.060547 15.47667275,0 0,-4.060547 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_Edit">
    <svg viewBox="0 0 32 32">
        <g>
            <path style="fill:none;stroke-width:2;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
                  d="m 1.0024198,16.014565 c -0.1608928,7.226584 5.7144461,13.988806 12.8935162,14.850338 6.213085,0.9092 12.840028,-2.454963 15.554166,-8.162582 2.727101,-5.426499 1.816556,-12.494514 -2.4397,-16.88801 C 22.925671,1.386365 16.078282,-0.265778 10.483747,2.073448 5.1630126,4.1605 1.2329644,9.452561 1.0239062,15.197949 c -0.014637,0.27194 -0.021821,0.544283 -0.021486,0.816616 z" />
            <g transform="matrix(1.53421,0,0,1.53421,-2.410513,-2.41052)">
                <g transform="translate(-433.13094,-501.35006)">
                    <path d="m 437.79741,519.82082 c 1.33945,0.75933 2.67075,1.53336 4.00857,2.29597 -1.19117,0.56055 -2.39374,1.09664 -3.58327,1.66209 l -0.0358,0 c -0.13851,-1.31827 -0.26235,-2.63817 -0.38945,-3.95806 z m 5.90206,-12.76227 c 2.17701,1.23843 4.34587,2.48989 6.51963,3.73481 -1.66861,2.89726 -3.31277,5.80918 -5.00583,8.69178 -0.12058,-0.36664 -0.24605,-0.73164 -0.37479,-1.09339 -0.63713,-0.0652 -1.27427,-0.12711 -1.90977,-0.19719 -0.10755,-0.3976 -0.21998,-0.79519 -0.32427,-1.19278 -0.62573,-0.0326 -1.25146,-0.0408 -1.87719,-0.0717 -0.17272,-0.43507 -0.34382,-0.87016 -0.51655,-1.30523 -0.50025,0.0408 -0.99888,0.0913 -1.49751,0.13688 1.64742,-2.91029 3.32907,-5.7994 4.98628,-8.70317 z m 3.09605,-4.13731 0.0261,0 c 0.32264,0.0603 0.63061,0.18413 0.91415,0.34873 1.37204,0.80497 2.76201,1.57898 4.13405,2.38233 0.42204,0.2265 0.65342,0.72512 0.58173,1.19605 -0.0734,0.62247 -0.46767,1.14066 -0.76913,1.67024 -2.21123,-1.26938 -4.42409,-2.53225 -6.63207,-3.80652 0.41389,-0.72512 0.80009,-1.67187 1.7452,-1.79082 z" />
                </g>
            </g>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_New">
    <svg viewBox="0 0 128 128">
        <g>
            <path d=" M 49.00 13.00 C 58.59 13.00 68.17 12.99 77.76 13.01 C 77.75 26.34 77.75 39.67 77.75 53.00 C 90.92 53.01 104.08 52.99 117.25 53.00 C 117.25 62.67 117.25 72.33 117.25 82.00 C 104.16 82.01 91.08 82.00 78.00 82.00 C 78.00 95.33 78.00 108.67 78.00 122.00 C 68.33 122.00 58.67 122.00 49.00 122.00 C 49.00 108.67 49.00 95.33 49.00 82.00 C 35.81 81.94 22.63 82.12 9.45 81.91 C 9.55 72.29 9.51 62.68 9.46 53.06 C 22.64 52.92 35.82 53.04 49.00 53.00 C 49.00 39.67 49.00 26.33 49.00 13.00 Z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_EndEdit">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M24.275 3.2h-17.875c-1.76 0-3.2 1.44-3.2 3.2v19.2c0 1.76 1.44 3.2 3.2 3.2h19.2c1.76 0 3.2-1.44 3.2-3.2v-17.397l-4.525-5.003zM22.4 12.8c0 0.88-0.72 1.6-1.6 1.6h-9.6c-0.88 0-1.6-0.72-1.6-1.6v-8h12.8v8zM20.8 6.4h-3.2v6.4h3.2v-6.4z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_Save">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M24.275 3.2h-17.875c-1.76 0-3.2 1.44-3.2 3.2v19.2c0 1.76 1.44 3.2 3.2 3.2h19.2c1.76 0 3.2-1.44 3.2-3.2v-17.397l-4.525-5.003zM22.4 12.8c0 0.88-0.72 1.6-1.6 1.6h-9.6c-0.88 0-1.6-0.72-1.6-1.6v-8h12.8v8zM20.8 6.4h-3.2v6.4h3.2v-6.4z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_Delete">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M5.422 12.659l1.763 15.534c0.094 0.738 3.656 3.163 8.814 3.166 5.158-0.003 8.722-2.429 8.816-3.166l1.763-15.534c-2.694 1.507-6.722 2.221-10.579 2.221s-7.885-0.714-10.578-2.221zM21.067 3.059l-1.374-1.525c-0.53-0.754-1.106-0.894-2.227-0.894h-2.931c-1.12 0-1.696 0.141-2.227 0.894l-1.373 1.525c-4.112 0.718-7.094 2.624-7.094 4.029v0.274c0 2.474 5.443 4.48 12.16 4.48s12.16-2.006 12.16-4.48v-0.274c0-1.405-2.981-3.31-7.093-4.029zM19.31 6.622l-2.003-2.142h-2.614l-2.003 2.142h-2.72c0 0 2.979-3.552 3.378-4.034 0.304-0.368 0.616-0.509 1.019-0.509h3.269c0.403 0 0.714 0.141 1.019 0.509 0.397 0.482 3.378 4.034 3.378 4.034h-2.722z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_ShowHelp">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M22.544 3.574c-1.826-1.317-4.115-1.974-6.874-1.974-2.099 0-3.869 0.464-5.307 1.389-2.283 1.45-3.496 3.91-3.643 7.382h5.29c0-1.011 0.294-1.986 0.885-2.923s1.592-1.406 3.005-1.406c1.435 0 2.426 0.381 2.966 1.141 0.542 0.763 0.813 1.606 0.813 2.531 0 0.805-0.403 1.541-0.89 2.211-0.267 0.39-0.621 0.749-1.058 1.078 0 0-2.869 1.84-4.13 3.318-0.731 0.858-0.797 2.141-0.861 3.982-0.005 0.131 0.045 0.402 0.504 0.402s3.707 0 4.115 0 0.493-0.302 0.499-0.435c0.029-0.67 0.104-1.013 0.227-1.4 0.232-0.731 0.859-1.37 1.566-1.918l1.456-1.005c1.314-1.024 2.363-1.864 2.826-2.523 0.79-1.085 1.346-2.419 1.346-4.002 0-2.584-0.914-4.533-2.736-5.848zM15.586 23.878c-1.824-0.054-3.328 1.206-3.386 3.184-0.058 1.976 1.373 3.282 3.197 3.336 1.904 0.056 3.368-1.165 3.426-3.141 0.056-1.978-1.333-3.323-3.237-3.379z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_viSearch">
    <svg viewBox="0 0 32 32">
        <path d="M28.072 24.749l-6.046-6.046c0.912-1.499 1.437-3.256 1.437-5.139 0-5.466-4.738-10.203-10.205-10.203-5.466 0-9.898 4.432-9.898 9.898 0 5.467 4.736 10.205 10.203 10.205 1.818 0 3.52-0.493 4.984-1.349l6.078 6.080c0.597 0.595 1.56 0.595 2.154 0l1.509-1.507c0.594-0.595 0.378-1.344-0.216-1.938zM6.406 13.258c0-3.784 3.067-6.853 6.851-6.853 3.786 0 7.158 3.373 7.158 7.158s-3.067 6.853-6.853 6.853-7.157-3.373-7.157-7.158z"></path>
    </svg>
</vi-icon>

<vi-icon name="Action_SynchronizeSchema">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M0 27.429v-3.036q2.125 1.5 5.804 2.268t7.911 0.768 7.911-0.768 5.804-2.268v3.036q0 1.232-1.839 2.286t-5 1.67-6.875 0.616-6.875-0.616-5-1.67-1.839-2.286zM0 20.571v-3.036q2.125 1.5 5.804 2.268t7.911 0.768 7.911-0.768 5.804-2.268v3.036q0 1.232-1.839 2.286t-5 1.67-6.875 0.616-6.875-0.616-5-1.67-1.839-2.286zM0 13.714v-3.036q2.125 1.5 5.804 2.268t7.911 0.768 7.911-0.768 5.804-2.268v3.036q0 1.232-1.839 2.286t-5 1.67-6.875 0.616-6.875-0.616-5-1.67-1.839-2.286zM0 6.857v-2.286q0-1.232 1.839-2.286t5-1.67 6.875-0.616 6.875 0.616 5 1.67 1.839 2.286v2.286q0 1.232-1.839 2.286t-5 1.67-6.875 0.616-6.875-0.616-5-1.67-1.839-2.286z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_ExportToExcel">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M23.22 12h-4.228l-2.992 4.407-2.992-4.407h-4.228l5.068 7.577-5.718 8.423h8.195v-2.862h-1.892l1.567-2.344 3.481 5.205h4.389l-5.718-8.423zM28.232 6.232l-4.465-4.464c-0.972-0.972-2.893-1.768-4.268-1.768h-15c-1.375 0-2.5 1.125-2.5 2.5v27c0 1.375 1.125 2.5 2.5 2.5h23c1.375 0 2.5-1.125 2.5-2.5v-19c0-1.375-0.796-3.296-1.768-4.268zM26.818 7.646c0.098 0.098 0.195 0.218 0.29 0.354h-5.108v-5.108c0.136 0.095 0.256 0.192 0.354 0.29l4.465 4.464zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-23c-0.271 0-0.5-0.229-0.5-0.5v-27c0-0.271 0.229-0.5 0.5-0.5h15c0.151 0 0.32 0.019 0.5 0.053v7.947h7.947c0.034 0.18 0.053 0.349 0.053 0.5v19z"></path>
        </g>
    </svg>
</vi-icon>

<!--User by Marek Polakovic from the Noun Project-->
<vi-icon name="Action_viImpersonate">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 20.599206,14.561598 C 22.659139,13.105438 24.008751,10.72586 24.008751,7.991121 24.044267,3.587125 20.457142,0 16.01763,0 11.578118,0 7.9909928,3.587125 7.9909928,8.026637 c 0,2.699223 1.349612,5.114317 3.4095452,6.570477 -5.1143172,1.882353 -8.7369592,6.748058 -8.7369592,12.501665 l 0,3.374029 C 2.6635788,31.325194 3.3383848,32 4.1907708,32 l 23.6182022,0 c 0.852386,0 1.527192,-0.674806 1.527192,-1.527192 l 0,-3.374029 c 0.03552,-5.753607 -3.622641,-10.654828 -8.736959,-12.537181 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="viConfigure">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M5.014 11.024c1.494-1.16 2.733-0.362 4.386 1.552 0.187 0.214 0.437-0.037 0.578-0.16 0.141-0.125 2.323-2.086 2.429-2.178 0.107-0.094 0.235-0.27 0.066-0.467s-0.79-1-1.189-1.52c-2.893-3.784 7.914-6.35 6.253-6.39-0.843-0.022-4.234-0.061-4.739-0.008-2.053 0.218-4.63 2.136-5.928 3.029-1.696 1.166-2.331 1.843-2.435 1.938-0.48 0.421-0.077 1.387-0.947 2.15-0.92 0.806-1.493 0.197-2.026 0.664-0.266 0.234-1.003 0.786-1.216 0.973-0.211 0.186-0.25 0.501-0.034 0.754 0 0 2.021 2.234 2.192 2.43 0.17 0.197 0.626 0.363 0.909 0.114 0.283-0.248 1.010-0.886 1.133-0.995 0.125-0.107-0.080-1.381 0.57-1.885zM14.149 11.85c-0.192-0.222-0.429-0.227-0.635-0.045l-2.296 2.002c-0.179 0.16-0.203 0.454-0.042 0.64l13.27 15.101c0.309 0.358 0.846 0.395 1.203 0.085l1.554-1.299c0.354-0.31 0.39-0.854 0.082-1.211l-13.136-15.272zM31.843 5.422c-0.118-0.79-0.528-0.624-0.741-0.288-0.21 0.334-1.154 1.762-1.541 2.406-0.384 0.643-1.328 1.906-3.094 0.659-1.837-1.299-1.197-2.206-0.878-2.816 0.322-0.613 1.309-2.328 1.453-2.544 0.141-0.216-0.026-0.843-0.594-0.581-0.571 0.264-4.037 1.642-4.518 3.616-0.491 2.011 0.413 3.806-1.36 5.59l-2.147 2.24 2.157 2.509 2.646-2.514c0.632-0.634 1.978-1.25 3.197-0.973 2.613 0.592 4.037-0.39 4.898-2.011 0.771-1.451 0.643-4.504 0.523-5.294zM4.384 27.282c-0.333 0.336-0.333 0.88 0 1.214l1.522 1.488c0.333 0.334 0.861 0.194 1.194-0.141l7.851-7.72-2.406-2.741-8.16 7.899z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Action_viQueryReorder">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 26.44353,5.271561 c -0.412107,-0.03158 -0.809872,0.277896 -0.809872,0.757898 v 2.357904 h -2.189483 c -3.166329,0 -6.197657,1.347637 -8.319771,3.638173 l 1.650665,2.290141 c 1.616849,-2.021061 4.075411,-3.200013 6.669106,-3.200013 h 2.189483 v 2.357904 c 0,0.640003 0.740924,0.97711 1.212505,0.606582 l 4.850678,-3.738832 c 0.404212,-0.303159 0.404212,-0.910003 0,-1.213162 L 26.846163,5.422877 C 26.719847,5.330247 26.580899,5.282087 26.44353,5.271561 Z M 1.3809267,8.387363 C 0.6398711,8.387363 0,8.99355 0,9.76829 c 0,0.77474 0.6061867,1.380927 1.3809267,1.380927 h 2.8296169 c 2.7621167,0 5.3897594,1.347768 7.0066074,3.60462 l 2.963828,4.14278 c 2.122114,2.964223 5.591734,4.715809 9.229644,4.715809 h 2.189482 v 2.357904 c 0,0.640003 0.740793,0.977109 1.246058,0.606582 l 4.850678,-3.705279 c 0.404212,-0.370528 0.404212,-0.977109 0,-1.280268 l -4.850678,-3.705279 c -0.505265,-0.370527 -1.246058,-0.03342 -1.246058,0.606582 v 2.357904 h -2.189482 c -2.762117,0 -5.389759,-1.347111 -7.006608,-3.603962 L 13.440187,13.103172 C 11.318073,10.138949 7.848453,8.387363 4.2105436,8.387363 Z m 9.5329343,9.263196 C 9.263328,19.637936 6.8042385,20.81702 4.2105436,20.81702 H 1.3809267 C 0.6398711,20.81702 0,21.423206 0,22.197946 c 0,0.741056 0.6061867,1.380927 1.3809267,1.380927 h 2.8296169 c 3.1663289,0 6.1976574,-1.346979 8.3197714,-3.637515 z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Menu_Collapse">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 13.755859 3.6875 C 12.825375 3.67775 11.793429 4.0328388 10.777344 4.9082031 C 7.51057 8.0563174 4.3474367 11.312284 1.1132812 14.494141 C -0.0884908 15.677354 0.00490112 16.73654 1.1445312 17.869141 C 4.2369709 20.943022 7.2941262 24.053786 10.40625 27.107422 C 13.653922 30.161156 19.188986 27.019482 15.460938 22.085938 C 14.015099 20.576552 12.534464 19.100448 11.029297 17.650391 C 9.934373 16.595115 9.94981 15.688666 11.070312 14.630859 C 12.849633 12.949953 14.574969 11.209304 16.253906 9.4277344 C 18.42894 7.0287647 16.547316 3.7166808 13.755859 3.6875 z M 28.304688 3.6875 C 27.374204 3.67775 26.342257 4.0328388 25.326172 4.9082031 C 22.059399 8.0563174 18.896265 11.312284 15.662109 14.494141 C 14.460336 15.677354 14.553731 16.73654 15.693359 17.869141 C 18.7858 20.943022 21.842955 24.053786 24.955078 27.107422 C 28.202751 30.161156 33.737814 27.019493 30.009766 22.085938 C 28.563927 20.576553 27.083292 19.100448 25.578125 17.650391 C 24.483202 16.595115 24.49862 15.688666 25.619141 14.630859 C 27.398462 12.949953 29.123796 11.209304 30.802734 9.4277344 C 32.977767 7.0287647 31.096141 3.7166808 28.304688 3.6875 z "></path>
        </g>
    </svg>
</vi-icon>

<!--House by Filip Malinowski from the Noun Project-->
<vi-icon name="ProgramUnit_Home">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16 1.1425781 L 0 14.857422 C 0 16.119782 1.0226122 17.142578 2.2851562 17.142578 L 2.2851562 30.857422 L 11.427734 30.857422 L 11.427734 21.714844 L 20.572266 21.714844 L 20.572266 30.857422 L 29.714844 30.857422 L 29.714844 17.142578 C 30.976194 17.142578 32 16.119792 32 14.857422 L 27.427734 10.939453 L 27.427734 3.4277344 L 22.857422 3.4277344 L 22.857422 7.0195312 L 16 1.1425781 z "></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="ProgramUnit_Vidyano">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16.001953 1.0488281 L 16.001953 1.0507812 C 7.7451231 1.0507812 1.0507812 7.7412169 1.0507812 15.998047 C 1.0507812 24.254877 7.7451231 30.951172 16.001953 30.951172 C 24.258783 30.951172 30.949219 24.254877 30.949219 15.998047 C 30.949219 11.252417 28.743142 7.0238863 25.294922 4.2851562 L 17.964844 25.666016 L 14.183594 25.666016 L 8.0058594 9.8027344 L 11.732422 9.796875 L 16.001953 20.697266 L 22.25 2.4140625 C 20.34855 1.5379825 18.232843 1.0488281 16.001953 1.0488281 z "></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="ProgramUnitGroup">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 0,3.072677 20.683717,16 0,28.927323 0,3.072677 Z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Grid">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 0 0 L 0 32 L 32 32 L 32 0 L 0 0 z M 2.1875 8.1503906 L 9.9375 8.1503906 L 10.705078 8.1503906 L 10.705078 12.691406 L 2.1875 12.691406 L 2.1875 8.1503906 z M 11.359375 8.1503906 L 12.125 8.1503906 L 19.875 8.1503906 L 20.640625 8.1503906 L 20.640625 12.691406 L 11.359375 12.691406 L 11.359375 8.1503906 z M 21.296875 8.1503906 L 22.0625 8.1503906 L 29.8125 8.1503906 L 29.8125 12.691406 L 21.296875 12.691406 L 21.296875 8.1503906 z M 2.1875 13.345703 L 10.705078 13.345703 L 10.705078 18.658203 L 2.1875 18.658203 L 2.1875 13.345703 z M 11.359375 13.345703 L 20.640625 13.345703 L 20.640625 18.658203 L 11.359375 18.658203 L 11.359375 13.345703 z M 21.296875 13.345703 L 29.8125 13.345703 L 29.8125 18.658203 L 21.296875 18.658203 L 21.296875 13.345703 z M 2.1875 19.3125 L 10.705078 19.3125 L 10.705078 24.617188 L 2.1875 24.617188 L 2.1875 19.3125 z M 11.359375 19.3125 L 20.640625 19.3125 L 20.640625 24.617188 L 11.359375 24.617188 L 11.359375 19.3125 z M 21.296875 19.3125 L 29.8125 19.3125 L 29.8125 24.617188 L 21.296875 24.617188 L 21.296875 19.3125 z M 2.1875 25.275391 L 10.705078 25.275391 L 10.705078 29.8125 L 2.1875 29.8125 L 2.1875 25.275391 z M 11.359375 25.275391 L 20.640625 25.275391 L 20.640625 29.8125 L 11.359375 29.8125 L 11.359375 25.275391 z M 21.296875 25.275391 L 29.8125 25.275391 L 29.8125 29.8125 L 21.296875 29.8125 L 21.296875 25.275391 z"></path>
        </g>
    </svg>
</vi-icon>

<!-- Line Graph by Kyle Tezak from the Noun Project -->
<vi-icon name="Chart_LineChart">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 0 0 L 0 32 L 32 32 L 32 28 L 4 28 L 4 0 L 0 0 z M 31.705078 1.5878906 L 19.90625 14.941406 L 14.955078 9.0371094 L 5.7851562 18.171875 L 5.7851562 23.828125 L 14.757812 14.962891 L 19.746094 21.058594 L 31.705078 7.5859375 L 31.705078 1.5878906 z "></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Filter">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M0 4l12 12v12l8-2v-10l12-12z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Filter_Reset">
    <svg viewBox="0 0 32 32">
        <g transform="matrix(0.87711864,0,0,0.87711864,0,0.49152542)">
            <path d="m 0,4 12,12 v 12 l 8,-2 V 16 L 32,4 z" />
        </g>
        <g transform="matrix(0.5593343,0,0,0.5593343,13.559127,13.694719)" style="fill:#d90000; fill-opacity:1">
            <path d="m 31.708,25.708 c 0,0 0,0 0,0 L 22,16 31.708,6.292 c 0,0 0,0 0,0 0.105,-0.105 0.18,-0.227 0.229,-0.357 C 32.07,5.579 31.994,5.164 31.708,4.878 L 27.122,0.292 C 26.836,0.006 26.42,-0.069 26.065,0.063 c -0.13,0.048 -0.252,0.124 -0.357,0.228 0,0 0,0 0,0 L 16,9.999 6.292,0.291 c 0,0 0,0 0,0 C 6.187,0.187 6.065,0.111 5.935,0.063 5.579,-0.07 5.164,0.006 4.878,0.292 L 0.292,4.878 C 0.006,5.164 -0.069,5.58 0.063,5.935 c 0.049,0.13 0.124,0.252 0.229,0.357 0,0 0,0 0,0 L 10,16 0.292,25.708 c 0,0 0,0 0,0 -0.104,0.105 -0.18,0.227 -0.229,0.357 -0.133,0.355 -0.057,0.771 0.229,1.057 l 4.586,4.586 c 0.286,0.286 0.702,0.361 1.057,0.229 0.13,-0.049 0.252,-0.124 0.357,-0.229 0,0 0,0 0,0 L 16,22 l 9.708,9.708 c 0,0 0,0 0,0 0.105,0.105 0.227,0.18 0.357,0.229 0.356,0.133 0.771,0.057 1.057,-0.229 l 4.586,-4.586 c 0.286,-0.286 0.362,-0.702 0.229,-1.057 -0.049,-0.13 -0.124,-0.252 -0.229,-0.357 z"
                  style="fill:#d90000; fill-opacity:1" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Filter_Save">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M24.275 3.2h-17.875c-1.76 0-3.2 1.44-3.2 3.2v19.2c0 1.76 1.44 3.2 3.2 3.2h19.2c1.76 0 3.2-1.44 3.2-3.2v-17.397l-4.525-5.003zM22.4 12.8c0 0.88-0.72 1.6-1.6 1.6h-9.6c-0.88 0-1.6-0.72-1.6-1.6v-8h12.8v8zM20.8 6.4h-3.2v6.4h3.2v-6.4z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Filter_Menu">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 0 5.2949219 L 9.4882812 14.783203 L 9.4882812 24.269531 L 15.8125 22.6875 L 15.8125 14.783203 L 25.300781 5.2949219 L 0 5.2949219 z M 18.755859 16.369141 L 25.378906 26.705078 L 32 16.369141 L 18.755859 16.369141 z " />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Filter_Inverse">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 19.021484 0 L 16.332031 8.5761719 L 0.81835938 8.5761719 L 0.81835938 12.570312 L 15.103516 12.570312 L 12.953125 19.429688 L 0.81835938 19.429688 L 0.81835938 23.423828 L 11.699219 23.423828 L 9.0371094 32 L 12.953125 32 L 15.615234 23.423828 L 31.181641 23.423828 L 31.181641 19.429688 L 16.871094 19.429688 L 18.996094 12.570312 L 31.181641 12.570312 L 31.181641 8.5761719 L 20.25 8.5761719 L 22.9375 0 L 19.021484 0 z "></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Folder">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 1.1914062 4.4257812 C 0.62732125 4.4257812 -2.9605947e-016 4.7132587 0 5.2773438 L 0 26.382812 C 0 26.946556 0.62732125 27.574219 1.1914062 27.574219 L 31.148438 27.574219 C 31.712523 27.574219 32 26.946557 32 26.382812 L 32 8.6816406 C 32 8.1175556 31.712522 7.8300781 31.148438 7.8300781 L 13.501953 7.8300781 L 10.048828 4.6914062 C 9.8609133 4.5205123 9.6152861 4.4257813 9.3613281 4.4257812 L 1.1914062 4.4257812 z "></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="SortAsc">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 22 2 L 22 6 L 28 6 L 28 2 L 22 2 z M 16 10 L 16 14 L 28 14 L 28 10 L 16 10 z M 10 18 L 10 22 L 28 22 L 28 18 L 10 18 z M 4 26 L 4 30 L 28 30 L 28 26 L 4 26 z " />
        </g>
    </svg>
</vi-icon>

<vi-icon name="SortDesc">
    <svg viewBox="0 0 18 32">
        <g>
            <path d="m 22,30 v -4 h 6 v 4 z m -6,-8 v -4 h 12 v 4 z m -6,-8 v -4 h 18 v 4 z M 4,6 V 2 h 24 v 4 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Search">
    <svg viewBox="0 0 32 32">
        <path d="M28.072 24.749l-6.046-6.046c0.912-1.499 1.437-3.256 1.437-5.139 0-5.466-4.738-10.203-10.205-10.203-5.466 0-9.898 4.432-9.898 9.898 0 5.467 4.736 10.205 10.203 10.205 1.818 0 3.52-0.493 4.984-1.349l6.078 6.080c0.597 0.595 1.56 0.595 2.154 0l1.509-1.507c0.594-0.595 0.378-1.344-0.216-1.938zM6.406 13.258c0-3.784 3.067-6.853 6.851-6.853 3.786 0 7.158 3.373 7.158 7.158s-3.067 6.853-6.853 6.853-7.157-3.373-7.157-7.158z"></path>
    </svg>
</vi-icon>

<vi-icon name="SearchReset">
    <svg viewBox="0 0 32 32">
        <path d="M 16 0 C 7.163444 0 0 7.16344 0 16 C 0 24.83656 7.163444 32 16 32 C 24.836556 32 32 24.83656 32 16 C 32 7.16344 24.836556 0 16 0 z M 10.353516 8.4707031 C 10.835252 8.4707031 11.316041 8.6539294 11.683594 9.0214844 L 16 13.337891 L 20.316406 9.0214844 C 21.051511 8.2863744 22.243411 8.2863744 22.978516 9.0214844 C 23.71362 9.7565844 23.71362 10.948484 22.978516 11.683594 L 18.662109 16 L 22.978516 20.316406 C 23.71362 21.051516 23.71362 22.243416 22.978516 22.978516 C 22.243411 23.713626 21.051511 23.713626 20.316406 22.978516 L 16 18.662109 L 11.683594 22.978516 C 10.948489 23.713626 9.7565894 23.713626 9.0214844 22.978516 C 8.2863804 22.243416 8.2863804 21.051516 9.0214844 20.316406 L 13.337891 16 L 9.0214844 11.683594 C 8.2863804 10.948484 8.2863804 9.7565844 9.0214844 9.0214844 C 9.3890369 8.6539294 9.871779 8.4707031 10.353516 8.4707031 z "></path>
    </svg>
</vi-icon>

<vi-icon name="Hamburger">
    <svg viewBox="0 0 32 32">
        <path d="m 2.0016823,21.980656 27.9966357,0 0,4.122792 -27.9966357,0 z m 0,-8.101765 27.9966357,0 0,4.122792 -27.9966357,0 z m 0,-7.8620691 27.9966357,0 0,4.1227921 -27.9966357,0 z"></path>
    </svg>
</vi-icon>

<vi-icon name="SignIn">
    <svg viewBox="0 0 32 32">
        <path d="M0 19.429v-6.857q0-0.464 0.339-0.804t0.804-0.339h8v-5.143q0-0.464 0.339-0.804t0.804-0.339 0.804 0.339l9.714 9.714q0.339 0.339 0.339 0.804t-0.339 0.804l-9.714 9.714q-0.339 0.339-0.804 0.339t-0.804-0.339-0.339-0.804v-5.143h-8q-0.464 0-0.804-0.339t-0.339-0.804zM15.973 26.027q0.009-0.188 0.054-0.42t0.179-0.348 0.366-0.116h5.714q1.179 0 2.018-0.839t0.839-2.018v-12.571q0-1.179-0.839-2.018t-2.018-0.839h-5.571t-0.205-0.018-0.205-0.054-0.143-0.098-0.125-0.161-0.036-0.241q0-0.071-0.018-0.357t-0.009-0.473 0.054-0.42 0.179-0.348 0.366-0.116h5.714q2.125 0 3.634 1.509t1.509 3.634v12.571q0 2.125-1.509 3.634t-3.634 1.509h-5.714q-0.232 0-0.402-0.17t-0.17-0.402q0-0.071-0.018-0.357t-0.009-0.473z"></path>
    </svg>
</vi-icon>

<vi-icon name="SignOut">
    <svg viewBox="0 0 32 32">
        <path d="M20 24h-8v-18l-8-4h16v6h2v-8h-22v26l12 6v-6h10v-10h-2v8zM32 12l-8-6v4h-8v4h8v4l8-6z"></path>
    </svg>
</vi-icon>

<!--Based on talking by Ed Gray from the Noun Project-->
<vi-icon name="UserFeedback">
    <svg viewBox="0 0 32 32">
        <path d="M 16 1.8476562 C 11.958236 1.8476562 7.9160209 2.2179833 5.3203125 2.9570312 C 2.8511657 3.7752802 1.1002382 6.0203922 0.51367188 8.5058594 C -0.17209562 11.885416 -0.17209563 15.376622 0.51367188 18.755859 C 1.1002382 21.241646 2.8508456 23.486439 5.3203125 24.304688 C 6.4838452 24.63589 7.9399498 24.89313 9.5546875 25.076172 C 9.5841275 25.929941 9.2224795 27.228406 7.5507812 28.902344 C 5.1885154 31.26749 10.395668 29.761465 12.349609 28.576172 C 13.964987 27.596002 15.533391 26.61391 16.998047 25.404297 C 20.697927 25.348617 24.297901 24.983094 26.679688 24.304688 C 29.149154 23.486438 30.899761 21.241646 31.486328 18.755859 C 32.171776 15.376622 32.171776 11.885416 31.486328 8.5058594 C 30.900081 6.0200722 29.149155 3.7752802 26.679688 2.9570312 C 24.08414 2.2179833 20.041764 1.8476563 16 1.8476562 z"></path>
    </svg>
</vi-icon>

<!--Settings by Mundo from the Noun Project-->
<vi-icon name="Configure">
    <svg viewBox="0 0 32 32">
        <path d="M 15.408203 1.2519531 C 14.100789 1.2519531 13.041016 2.3097725 13.041016 3.6171875 L 13.041016 5.2050781 C 12.091134 5.4646731 11.194392 5.84286 10.361328 6.328125 L 9 4.9667969 C 8.076668 4.0437599 6.5773339 4.0437599 5.6542969 4.9667969 L 4.8183594 5.8027344 C 3.8932575 6.7278364 3.8932575 8.2252887 4.8183594 9.1503906 L 6.2050781 10.537109 C 5.7543269 11.339493 5.4035265 12.204771 5.1601562 13.117188 L 3.6152344 13.117188 C 2.3078199 13.117188 1.25 14.175007 1.25 15.482422 L 1.25 16.666016 C 1.25 17.971366 2.3078199 19.03125 3.6152344 19.03125 L 5.1757812 19.03125 C 5.4297712 19.950747 5.7945597 20.821283 6.2597656 21.632812 L 4.8183594 23.074219 C 3.8932574 23.997256 3.8932574 25.49659 4.8183594 26.419922 L 5.6542969 27.257812 C 6.5776286 28.181144 8.0750099 28.181145 8.9980469 27.257812 L 10.451172 25.800781 C 11.257391 26.262152 12.126829 26.618213 13.041016 26.867188 L 13.041016 28.382812 C 13.041016 29.688457 14.098835 30.748047 15.40625 30.748047 L 16.591797 30.748047 C 17.897147 30.748047 18.957031 29.688457 18.957031 28.382812 L 18.957031 26.867188 C 19.869153 26.618212 20.739181 26.262152 21.546875 25.800781 L 22.996094 27.257812 C 23.919426 28.181144 25.41876 28.181145 26.341797 27.257812 L 27.179688 26.419922 C 28.103019 25.49659 28.103019 23.997256 27.179688 23.074219 L 25.736328 21.632812 C 26.197994 20.821283 26.565844 19.950747 26.818359 19.03125 L 28.382812 19.03125 C 29.688457 19.03125 30.749411 17.971071 30.75 16.666016 L 30.75 15.484375 C 30.75 14.176961 29.690411 13.117188 28.384766 13.117188 L 26.841797 13.117188 C 26.596657 12.204769 26.245307 11.339493 25.791016 10.537109 L 27.179688 9.1503906 C 28.103019 8.2252887 28.103019 6.7278364 27.179688 5.8027344 L 26.34375 4.9667969 C 25.420713 4.0437599 23.919426 4.0437599 22.996094 4.9667969 L 21.636719 6.328125 C 20.803655 5.84286 19.905438 5.4666263 18.957031 5.2070312 L 18.957031 3.6171875 C 18.957031 2.3097725 17.897146 1.2519531 16.591797 1.2519531 L 15.408203 1.2519531 z M 15.998047 9.6054688 C 19.591372 9.6054688 22.505859 12.517708 22.505859 16.111328 C 22.505859 19.706718 19.591372 22.617188 15.998047 22.617188 C 12.404722 22.617188 9.4941406 19.706718 9.4941406 16.111328 C 9.4941406 12.517708 12.404722 9.6054687 15.998047 9.6054688 z M 15.998047 13.080078 C 14.364369 13.080078 13.041016 14.403726 13.041016 16.037109 C 13.041016 17.671082 14.364369 18.992187 15.998047 18.992188 C 17.62966 18.992188 18.956736 17.670787 18.957031 16.037109 C 18.957031 14.403726 17.629955 13.080078 15.998047 13.080078 z "></path>
    </svg>
</vi-icon>

<vi-icon name="CaretDown">
    <svg viewBox="0 0 32 32">
        <path d="m 6.8569985,12.571 q 0,-0.464 0.339,-0.804 0.339,-0.34 0.804,-0.339 H 23.999999 q 0.464,0 0.804,0.339 0.34,0.339 0.339,0.804 -0.001,0.465 -0.339,0.804 l -8,8 q -0.339,0.339 -0.804,0.339 -0.465,0 -0.804,-0.339 l -8.0000005,-8 q -0.339,-0.339 -0.339,-0.804 z"></path>
    </svg>
</vi-icon>

<vi-icon name="ChevronRight">
    <svg viewBox="0 0 32 32">
        <path d="m 10.207627,24.441119 q 0,-0.290558 0.212283,-0.503467 L 16.357561,18 10.41991,12.062348 q -0.212283,-0.212282 -0.212283,-0.503466 0,-0.291185 0.212283,-0.503467 l 1.856064,-1.8560644 q 0.212282,-0.2122826 0.503467,-0.2122826 0.291184,0 0.503466,0.2122826 L 21.58009,17.496533 Q 21.792373,17.708816 21.792373,18 q 0,0.291184 -0.212283,0.503467 l -8.297183,8.297183 q -0.212282,0.212282 -0.503466,0.212282 -0.291185,0 -0.503467,-0.212282 L 10.41991,24.944586 q -0.212283,-0.212283 -0.212283,-0.503467 z" />
    </svg>
</vi-icon>

<vi-icon name="ChevronLeft">
    <svg viewBox="0 0 32 32">
        <path d="m 21.792373,24.441119 q 0,-0.290558 -0.212283,-0.503467 L 15.642439,18 21.58009,12.062348 q 0.212283,-0.212282 0.212283,-0.503466 0,-0.291185 -0.212283,-0.503467 L 19.724026,9.1993506 Q 19.511744,8.987068 19.220559,8.987068 q -0.291184,0 -0.503466,0.2122826 L 10.41991,17.496533 Q 10.207627,17.708816 10.207627,18 q 0,0.291184 0.212283,0.503467 l 8.297183,8.297183 q 0.212282,0.212282 0.503466,0.212282 0.291185,0 0.503467,-0.212282 l 1.856064,-1.856064 q 0.212283,-0.212283 0.212283,-0.503467 z" />
    </svg>
</vi-icon>

<vi-icon name="Unselected">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M0 0v32h32v-32h-32zM30 30h-28v-28h28v28z" id="box"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Selected">
    <style>
        :host {
            fill: var(--vi-icon-selected-unchecked-color, #bbb);
        }

        :host([is-selected]) #backdrop {
            opacity: 1 !important;
        }

        :host([is-selected]) #check {
            display: block;
            fill: white;
        }

        :host([is-selected]:not([disabled])) #box, :host([is-selected]:not([disabled])) #backdrop {
            fill: var(--vi-icon-selected-checked-color, var(--color));
        }

        :host([is-selected][disabled]) #box, :host([is-selected][disabled]) #backdrop {
            fill: var(--vi-icon-selected-disabled-color, #666);
        }

        :host(:not([is-selected])) #check {
            display: none;
        }
    </style>
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 0,1e-7 0,32 32,32 32,1e-7 Z" id="backdrop" style="opacity:0;" />
            <path d="M0 0v32h32v-32h-32zM30 30h-28v-28h28v28z" id="box"></path>
            <path d="m 23.849873,7 -10,10 -6.0000002,-6 -4,4 10.0000002,10 14,-14 -4,-4 z" id="check" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="SelectedRadio">
    <style>
        :host {
            fill: var(--vi-icon-selected-unchecked-color, var(--theme-dark-border));
        }

        :host([is-selected]) #check, :host([is-selected]) #box {
            fill: var(--color);
        }

        :host(:not([is-selected])) #check {
            display: none;
        }

        :host([disabled]) {
            fill: var(--vi-icon-selected-disabled-color, #666) !important;
        }

    </style>
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16 0 C 7.192804 0 -1.9567658e-007 7.1928041 0 16 C 0 24.807195 7.1928041 32 16 32 C 24.807195 32 32 24.807195 32 16 C 32 7.1928041 24.807195 0 16 0 z M 16 4.8925781 C 22.163409 4.8925781 27.107422 9.8365909 27.107422 16 C 27.107422 22.163409 22.163409 27.107422 16 27.107422 C 9.836591 27.107422 4.8925781 22.163409 4.8925781 16 C 4.8925779 9.8365909 9.836591 4.8925781 16 4.8925781 z " id="box" />
            <path d="M 16 8.5 A 7.5 7.5 0 0 0 8.5 16 A 7.5 7.5 0 0 0 16 23.5 A 7.5 7.5 0 0 0 23.5 16 A 7.5 7.5 0 0 0 16 8.5 z " id="check" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Check">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 23.849873,7 -10,10 -6.0000002,-6 -4,4 10.0000002,10 14,-14 -4,-4 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Ellipsis">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M16.002 12.48c-1.944 0-3.522 1.576-3.522 3.52s1.578 3.52 3.522 3.52c1.944 0 3.518-1.576 3.518-3.52s-1.574-3.52-3.518-3.52zM4.802 12.48c-1.944 0-3.522 1.576-3.522 3.52s1.578 3.52 3.522 3.52c1.944 0 3.518-1.578 3.518-3.52s-1.574-3.52-3.518-3.52zM27.202 12.48c-1.944 0-3.522 1.576-3.522 3.52s1.578 3.52 3.522 3.52c1.944 0 3.518-1.576 3.518-3.52s-1.574-3.52-3.518-3.52z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="EllipsisVertical">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16 1.2792969 C 14.056 1.2792969 12.480469 2.8587344 12.480469 4.8027344 C 12.480469 6.7467344 14.058 8.3203125 16 8.3203125 C 17.942 8.3203125 19.519531 6.7467344 19.519531 4.8027344 C 19.519531 2.8587344 17.944 1.2792969 16 1.2792969 z M 16 12.480469 C 14.056 12.480469 12.480469 14.057953 12.480469 16.001953 C 12.480469 17.945953 14.056 19.519531 16 19.519531 C 17.944 19.519531 19.519531 17.945953 19.519531 16.001953 C 19.519531 14.057953 17.944 12.480469 16 12.480469 z M 16 23.679688 C 14.056 23.679688 12.480469 25.257172 12.480469 27.201172 C 12.480469 29.145172 14.056 30.720703 16 30.720703 C 17.944 30.720703 19.519531 29.145172 19.519531 27.201172 C 19.519531 25.257172 17.944 23.679688 16 23.679688 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Add">
    <svg viewBox="0 0 32 32">
        <path d="m 27,14.5 0,3 q 0,0.625 -0.438,1.062 Q 26.124,18.999 25.5,19 l -6.5,0 0,6.5 q 0,0.625 -0.438,1.062 Q 18.124,26.999 17.5,27 l -3,0 Q 13.875,27 13.438,26.562 13.001,26.124 13,25.5 L 13,19 6.4999997,19 q -0.625,0 -1.062,-0.438 -0.437,-0.438 -0.438,-1.062 l 0,-3 q 0,-0.625 0.438,-1.062 0.438,-0.437 1.062,-0.438 L 13,13 13,6.5 Q 13,5.875 13.438,5.438 13.876,5.001 14.5,5 l 3,0 Q 18.125,5 18.562,5.438 18.999,5.876 19,6.5 l 0,6.5 6.5,0 q 0.625,0 1.062,0.438 0.437,0.438 0.438,1.062 z" />
    </svg>
</vi-icon>

<vi-icon name="Remove">
    <svg viewBox="0 0 32 32">
        <path d="M19.587 16.001l6.096 6.096c0.396 0.396 0.396 1.039 0 1.435l-2.151 2.151c-0.396 0.396-1.038 0.396-1.435 0l-6.097-6.096-6.097 6.096c-0.396 0.396-1.038 0.396-1.434 0l-2.152-2.151c-0.396-0.396-0.396-1.038 0-1.435l6.097-6.096-6.097-6.097c-0.396-0.396-0.396-1.039 0-1.435l2.153-2.151c0.396-0.396 1.038-0.396 1.434 0l6.096 6.097 6.097-6.097c0.396-0.396 1.038-0.396 1.435 0l2.151 2.152c0.396 0.396 0.396 1.038 0 1.435l-6.096 6.096z"></path>
    </svg>
</vi-icon>

<vi-icon name="Calendar">
    <svg viewBox="0 0 32 32">
        <path d="M10 12h4v4h-4zM16 12h4v4h-4zM22 12h4v4h-4zM4 24h4v4h-4zM10 24h4v4h-4zM16 24h4v4h-4zM10 18h4v4h-4zM16 18h4v4h-4zM22 18h4v4h-4zM4 18h4v4h-4zM26 0v2h-4v-2h-14v2h-4v-2h-4v32h30v-32h-4zM28 30h-26v-22h26v22z"></path>
    </svg>
</vi-icon>

<vi-icon name="Clock">
    <svg viewBox="0 0 32 32">
        <path d="M20.586 23.414l-6.586-6.586v-8.828h4v7.172l5.414 5.414zM16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 28c-6.627 0-12-5.373-12-12s5.373-12 12-12c6.627 0 12 5.373 12 12s-5.373 12-12 12z"></path>
    </svg>
</vi-icon>

<vi-icon name="Sphere">
    <svg viewBox="0 0 32 32">
        <path d="M15 2c-8.284 0-15 6.716-15 15s6.716 15 15 15c8.284 0 15-6.716 15-15s-6.716-15-15-15zM23.487 22c0.268-1.264 0.437-2.606 0.492-4h3.983c-0.104 1.381-0.426 2.722-0.959 4h-3.516zM6.513 12c-0.268 1.264-0.437 2.606-0.492 4h-3.983c0.104-1.381 0.426-2.722 0.959-4h3.516zM21.439 12c0.3 1.28 0.481 2.62 0.54 4h-5.979v-4h5.439zM16 10v-5.854c0.456 0.133 0.908 0.355 1.351 0.668 0.831 0.586 1.625 1.488 2.298 2.609 0.465 0.775 0.867 1.638 1.203 2.578h-4.852zM10.351 7.422c0.673-1.121 1.467-2.023 2.298-2.609 0.443-0.313 0.895-0.535 1.351-0.668v5.854h-4.852c0.336-0.94 0.738-1.803 1.203-2.578zM14 12v4h-5.979c0.059-1.38 0.24-2.72 0.54-4h5.439zM2.997 22c-0.533-1.278-0.854-2.619-0.959-4h3.983c0.055 1.394 0.224 2.736 0.492 4h-3.516zM8.021 18h5.979v4h-5.439c-0.3-1.28-0.481-2.62-0.54-4zM14 24v5.854c-0.456-0.133-0.908-0.355-1.351-0.668-0.831-0.586-1.625-1.488-2.298-2.609-0.465-0.775-0.867-1.638-1.203-2.578h4.852zM19.649 26.578c-0.673 1.121-1.467 2.023-2.298 2.609-0.443 0.312-0.895 0.535-1.351 0.668v-5.854h4.852c-0.336 0.94-0.738 1.802-1.203 2.578zM16 22v-4h5.979c-0.059 1.38-0.24 2.72-0.54 4h-5.439zM23.98 16c-0.055-1.394-0.224-2.736-0.492-4h3.516c0.533 1.278 0.855 2.619 0.959 4h-3.983zM25.958 10h-2.997c-0.582-1.836-1.387-3.447-2.354-4.732 1.329 0.636 2.533 1.488 3.585 2.54 0.671 0.671 1.261 1.404 1.766 2.192zM5.808 7.808c1.052-1.052 2.256-1.904 3.585-2.54-0.967 1.285-1.771 2.896-2.354 4.732h-2.997c0.504-0.788 1.094-1.521 1.766-2.192zM4.042 24h2.997c0.583 1.836 1.387 3.447 2.354 4.732-1.329-0.636-2.533-1.488-3.585-2.54-0.671-0.671-1.261-1.404-1.766-2.192zM24.192 26.192c-1.052 1.052-2.256 1.904-3.585 2.54 0.967-1.285 1.771-2.896 2.354-4.732h2.997c-0.504 0.788-1.094 1.521-1.766 2.192z"></path>
    </svg>
</vi-icon>

<vi-icon name="ArrowUpRight">
    <svg viewBox="0 0 32 32">
        <path d="M26.001 4c-0 0-0.001 0-0.001 0h-11.999c-1.105 0-2 0.895-2 2s0.895 2 2 2h7.172l-16.586 16.586c-0.781 0.781-0.781 2.047 0 2.828 0.391 0.391 0.902 0.586 1.414 0.586s1.024-0.195 1.414-0.586l16.586-16.586v7.172c0 1.105 0.895 2 2 2s2-0.895 2-2v-14h-1.999z"></path>
    </svg>
</vi-icon>

<vi-icon name="Pin">
    <svg viewBox="0 0 32 32">
        <path d="M17 0l-3 3 3 3-7 8h-7l5.5 5.5-8.5 11.269v1.231h1.231l11.269-8.5 5.5 5.5v-7l8-7 3 3 3-3-15-15zM14 17l-2-2 7-7 2 2-7 7z"></path>
    </svg>
</vi-icon>

<!-- eyes by Creative Stall from the Noun Project -->
<vi-icon name="Eye">
    <svg viewBox="0 0 32 32">
        <path d="M 15.679688 7.9042969 C 6.2854931 7.9042969 0.51188154 15.108077 0.1484375 15.574219 C 0.1484375 15.574219 0.14648438 15.576172 0.14648438 15.576172 C 0.14315037 15.581472 0.13743312 15.589137 0.13476562 15.591797 C 0.11542642 15.617137 0.10975485 15.647158 0.09375 15.673828 C 0.06774207 15.720508 0.03810863 15.765729 0.0234375 15.816406 C 0.01076697 15.857756 0.013099975 15.899392 0.009765625 15.941406 C 0.005764425 15.984756 -0.002714965 16.025013 0.001953125 16.068359 C 0.007288085 16.119039 0.02629701 16.166159 0.04296875 16.214844 C 0.05363867 16.245524 0.0549745 16.278584 0.0703125 16.308594 C 0.23636308 16.626691 4.2699752 24.095703 16.320312 24.095703 C 25.714507 24.095703 31.489452 16.891256 31.851562 16.425781 C 31.851562 16.425781 31.851562 16.423828 31.851562 16.423828 C 31.855563 16.419128 31.862564 16.410863 31.865234 16.408203 C 31.884574 16.382863 31.89158 16.351559 31.90625 16.324219 C 31.93226 16.278869 31.961883 16.236229 31.976562 16.185547 C 31.989902 16.144867 31.986904 16.102555 31.990234 16.060547 C 31.994234 16.017197 32.002087 15.973697 31.998047 15.929688 C 31.992747 15.880337 31.974324 15.837028 31.958984 15.791016 C 31.946984 15.757676 31.945018 15.722086 31.929688 15.691406 C 31.762969 15.373309 27.730026 7.9042969 15.679688 7.9042969 z M 16 8.6230469 C 20.067238 8.6230469 23.376953 11.932761 23.376953 16 C 23.376953 20.067239 20.067905 23.375 16 23.375 C 11.934094 23.375 8.6269531 20.067239 8.6269531 16 C 8.6269531 11.932761 11.934094 8.6230469 16 8.6230469 z M 16 12.402344 C 14.016062 12.402344 12.404297 14.016062 12.404297 16 C 12.404297 17.98327 14.016062 19.597656 16 19.597656 C 17.981937 19.597656 19.595703 17.98327 19.595703 16 C 19.596369 14.016062 17.982603 12.402344 16 12.402344 z "></path>
    </svg>
</vi-icon>

<vi-icon name="Up">
    <svg viewBox="0 0 32 32">
        <path d="M 6,24 16,8 26,24 6,24 Z"></path>
    </svg>
</vi-icon>

<vi-icon name="Down">
    <svg viewBox="0 0 32 32">
        <path d="M 26,8 16,24 6,8 26,8 Z"></path>
    </svg>
</vi-icon>

<vi-icon name="Forward">
    <svg viewBox="0 0 32 32">
        <path d="M 8,6 24,16 8,26 8,6 Z"></path>
    </svg>
</vi-icon>

<vi-icon name="Backward">
    <svg viewBox="0 0 32 32">
        <path d="M 24,6 8,16 24,26 24,6 Z"></path>
    </svg>
</vi-icon>

<vi-icon name="FastForward">
    <svg viewBox="0 0 32 32">
        <path d="M 4,24 16,16 4,8 4,24 Z M 28,16 16,8 16,24 28,16 Z"></path>
    </svg>
</vi-icon>

<vi-icon name="FastBackward">
    <svg viewBox="0 0 32 32">
        <path d="M 16,16 28,24 28,8 16,16 Z M 4,16 16,24 16,8 4,16 Z"></path>
    </svg>
</vi-icon>

<vi-icon name="Design">
    <svg viewBox="0 0 32 32">
        <g transform="translate(-3.5664062,-1016.601)">
            <path d="m 3.5664062,1016.601 0,1.8058 0,29.8977 32.0000018,0 -13.298335,-13.1754 10.562554,-10.3402 -0.308812,-2.6781 -2.697549,-2.6047 -2.66696,0.1024 -10.06669,10.3914 -13.5242098,-13.3989 z m 1.5058271,3.6116 10.9707737,10.8684 -1.7417,1.7982 -5.781553,-5.7275 0,1.8059 0,14.323 16.280579,0 -5.397449,-5.3469 1.788758,-1.7511 10.715489,10.6161 -26.8348977,0 0,-3.8258 1.5940592,0 0,-1.5211 -1.5940592,0 0,-2.9158 1.5940592,0 0,-1.5211 -1.5940592,0 0,-3.0434 1.5940592,0 0,-1.5211 -1.5940592,0 0,-3.014 1.5940592,0 0,-1.5212 -1.5940592,0 0,-7.7026 z m 24.1532317,0.8617 1.825815,1.7629 0.15823,1.3776 -1.550532,1.4923 -3.175177,-3.1834 1.352303,-1.3958 1.389361,-0.054 z m -3.865152,2.6088 3.135767,3.144 -11.857212,11.4148 -2.938128,0.058 0.0547,-2.6382 11.604869,-11.9789 z m -15.334732,7.0797 3.227529,3.1981 -1.028786,1.0623 -0.0065,0.3035 -0.0947,4.5463 5.399214,-0.098 0.804676,-0.7876 2.813426,2.7875 -11.114886,0 0,-11.0119 z"></path>
        </g>
    </svg>
</vi-icon>

<vi-icon name="Notification_Error">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 15.994999,4.88602 c -2.137014,0 -4.274093,9.3e-4 -6.411382,0.003 C 7.459021,8.57864 5.348877,12.2782 3.2,15.95347 c 0.084984,0.21081 0.1975943,0.40951 0.3167924,0.60375 2.0296786,3.51745 4.0525976,7.03931 6.0833796,10.55676 4.265747,-0.004 8.531494,10e-4 12.797241,-0.002 C 24.52532,23.40139 26.664367,19.69731 28.8,15.99114 26.665471,12.29268 24.530976,8.59323 22.406381,4.88926 c -2.137289,-0.002 -4.27437,-0.003 -6.411382,-0.003 z m -1.194051,3.14378 2.398104,0 -0.278337,11.55094 -1.819874,0 L 14.800948,8.0298 Z m 0.107092,13.68123 2.18392,0 0,2.25876 -2.18392,0 0,-2.25876 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Notification_Notice">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 15.781256,3.2001664 c -0.464328,0.0081 -0.928171,0.04251 -1.389066,0.103125 -2.313031,0.272831 -4.5347793,1.220623 -6.3562641,2.668756 -1.5729496,1.260343 -2.854452,2.889167 -3.6906335,4.7250106 -1.2515113,2.732776 -1.4867216,5.913056 -0.6593764,8.801583 0.7334541,2.628946 2.3553078,4.993758 4.5203223,6.648452 1.9750257,1.536493 4.4156637,2.454443 6.9109537,2.623444 2.737198,0.19441 5.530576,-0.524037 7.828143,-2.02188 1.512196,-0.989713 2.831087,-2.281268 3.803134,-3.807821 1.634807,-2.470996 2.310453,-5.538531 1.962504,-8.473457 -0.34574,-2.996777 -1.812657,-5.8430056 -4.040634,-7.8765796 -2.369919,-2.23654 -5.638781,-3.447555 -8.889083,-3.390633 z m 0.96094,4.459385 c 0.242684,0.01897 0.480564,0.09126 0.693752,0.221876 0.873738,0.44294 1.140207,1.696716 0.562501,2.4765676 -0.553405,0.864902 -1.861944,0.976772 -2.603131,0.287501 -0.481608,-0.494861 -0.696761,-1.2703536 -0.406251,-1.9187546 0.255991,-0.707491 1.025077,-1.124091 1.753129,-1.06719 z M 16.52657,12.581437 c 0.328895,-0.0092 0.653984,0.05312 0.940627,0.235938 0.342423,0.252951 0.465687,0.722285 0.364063,1.126566 -0.615261,2.732776 -1.685859,5.354764 -2.107816,8.13283 0.67491,-0.518051 1.292447,-1.1053 1.918754,-1.679691 0.37446,0.354581 0.727078,0.732036 1.120315,1.065627 -0.94885,0.853852 -1.857478,1.772504 -2.942194,2.456256 -0.568869,0.322541 -1.236597,0.608229 -1.901567,0.454689 -0.531312,-0.114881 -0.925487,-0.614457 -0.971877,-1.146878 -0.08064,-0.752231 0.127928,-1.493579 0.259375,-2.22813 0.436318,-2.002645 0.993097,-3.976747 1.553129,-5.948451 -0.579916,0.453991 -1.093611,0.985715 -1.617192,1.501566 -0.403178,-0.319231 -0.814927,-0.626731 -1.220314,-0.943752 1.028381,-1.145473 2.157803,-2.299298 3.63907,-2.832819 0.304317,-0.102721 0.636733,-0.184502 0.965627,-0.193751 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Notification_Warning">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 15.381463,4.8294215 c 0.655097,-0.20327 1.416247,-0.0685 1.939883,0.38223 0.289436,0.23421 0.48939,0.55236 0.669459,0.87273 3.500849,5.9919905 6.998384,11.9861805 10.499233,17.9770705 0.341358,0.58108 0.422002,1.32897 0.134776,1.94872 -0.322578,0.74347 -1.100299,1.25164 -1.912266,1.25054 -7.111065,0.003 -14.222131,0 -21.3320912,0.002 -0.621956,0.007 -1.257169,-0.2331 -1.6592856,-0.71917 -0.6429455,-0.67167 -0.6749823,-1.76645 -0.1844878,-2.53312 3.5251534,-6.04501 7.0569346,-12.08782 10.5854016,-18.1306205 0.275074,-0.48608 0.715857,-0.89151 1.259378,-1.05059 m -0.21542,6.4736505 c -0.141404,2.80156 -0.258504,5.60312 -0.392175,8.40579 0.815281,10e-4 1.631667,0 2.448054,0 -0.132567,-2.80377 -0.262923,-5.60644 -0.386652,-8.41021 -0.556777,0.002 -1.113555,-0.003 -1.669227,0.004 m -0.385547,10.16008 c -0.01105,0.70812 -0.0055,1.41735 -0.0033,2.12548 0.814177,0.001 1.628353,0.001 2.44253,0.001 0.0011,-0.70923 -0.0066,-1.41846 0.0044,-2.12658 -0.815281,-0.001 -1.629458,0 -2.443635,0 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Notification_OK">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 15.874957,3.1983988 c -0.493903,0.006 -0.987764,0.0406 -1.478297,0.10614 -3.387486,0.38546 -6.5496197,2.25548 -8.6017707,4.96591 -2.03227,2.6463702 -2.9323644,6.1177902 -2.480626,9.4213402 0.340184,2.64195 1.542841,5.16783 3.387347,7.08965 1.724117,1.85113 4.0203607,3.15675 6.4889067,3.70678 2.680609,0.6141 5.557887,0.32027 8.061776,-0.81404 2.079764,-0.91784 3.876811,-2.43327 5.193369,-4.27888 1.700922,-2.36804 2.531467,-5.33682 2.322718,-8.24385 -0.172301,-3.00202 -1.473362,-5.9267902 -3.587365,-8.0673002 -2.386123,-2.51852 -5.848735,-3.92494 -9.306058,-3.88575 z m 5.569587,6.77401 c 0.796341,0.8073802 1.600379,1.6071002 2.405555,2.4067602 -3.21187,3.22623 -6.4459,6.42926 -9.646726,9.66433 -1.953851,-1.9152 -3.86687,-3.86912 -5.8118857,-5.79204 -0.09499,-0.0884 -0.168849,-0.19001 -0.22297,-0.30598 0.839416,-0.74554 1.576011,-1.60031 2.4010677,-2.36241 1.208318,1.21273 2.416635,2.4255 3.633788,3.63051 1.85776,-1.92624 3.786208,-3.784 5.660536,-5.69367 0.536784,-0.50586 1.021761,-1.06484 1.580635,-1.5475002 z" />
        </g>
    </svg>
</vi-icon>

<!--Lock by Convoy from the Noun Project-->
<vi-icon name="Lock">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16 0 C 10.305913 0 5.1367188 4.6145073 5.1367188 10.308594 L 5.1367188 12.507812 L 3.8574219 12.507812 C 3.1544482 12.507812 2.5800781 13.084135 2.5800781 13.787109 L 2.5800781 26.441406 C 2.5800781 29.303468 5.6780316 32 8.5429688 32 L 24.005859 32 C 26.870796 32 29.419922 29.303468 29.419922 26.441406 L 29.419922 13.787109 C 29.419922 13.084135 28.845552 12.507813 28.142578 12.507812 L 26.863281 12.507812 L 26.863281 10.308594 C 26.863281 4.6145074 21.694087 3.5527137e-015 16 0 z M 16 4.2089844 C 19.368841 4.2089844 22.070312 6.9397524 22.070312 10.308594 L 22.070312 12.507812 L 9.9296875 12.507812 L 9.9296875 10.308594 C 9.9296875 6.9397525 12.631159 4.2089844 16 4.2089844 z " />
        </g>
    </svg>
</vi-icon>

<!-- Information by dw from the Noun Project -->
<vi-icon name="Info">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16.001953 0 C 7.1653304 0 0.001953125 7.1633777 0.001953125 16 C 0.001953125 24.836622 7.1653304 32 16.001953 32 C 24.838931 32 31.998047 24.836622 31.998047 16 C 31.998047 7.1633777 24.838931 2.3684758e-015 16.001953 0 z M 17.623047 3.9199219 C 18.400647 3.9199219 19.064654 4.1781545 19.617188 4.6972656 C 20.170077 5.2160212 20.445312 5.9571889 20.445312 6.6875 C 20.445312 7.4178111 20.170077 8.0968392 19.617188 8.6113281 C 19.064298 9.1243948 18.400291 9.4960938 17.623047 9.4960938 C 16.84438 9.4960938 16.177008 9.1243948 15.619141 8.6113281 C 15.062341 8.0968392 14.783203 7.4178111 14.783203 6.6875 C 14.783203 5.9571889 15.062341 5.2749705 15.619141 4.7558594 C 16.177008 4.2374594 16.84438 3.9199219 17.623047 3.9199219 z M 14.84375 11.433594 C 16.066506 11.433594 17.314162 11.728492 17.976562 12.318359 C 18.637541 12.90787 19.462891 13.860688 19.462891 14.804688 C 19.462891 14.999177 19.439158 15.342783 19.392578 15.835938 C 19.347418 16.328737 19.262405 16.779853 19.138672 17.189453 L 17.076172 21.298828 C 16.97235 21.659361 16.880606 22.069028 16.798828 22.53125 C 16.717048 22.993117 16.675781 23.949458 16.675781 24.185547 C 16.675781 24.780747 16.80915 25.186877 17.076172 25.402344 C 17.342483 25.618166 17.617794 25.970703 18.273438 25.970703 C 19.161971 25.970703 19.108827 26.121249 19.978516 25.710938 L 19.640625 27.095703 C 18.625514 27.495703 18.183991 27.3703 17.578125 27.580078 C 16.972969 27.790567 16.270347 27.896484 15.470703 27.896484 C 14.239058 27.896484 13.281565 27.595205 12.599609 26.996094 C 11.916943 26.39556 11.177734 25.632717 11.177734 24.708984 C 11.177734 24.665254 11.078472 22.921935 11.652344 21.730469 L 13.416016 17.605469 C 13.529083 17.174536 13.624372 16.767168 13.701172 16.382812 C 13.777972 15.997746 13.816406 15.954941 13.816406 15.636719 C 13.816406 15.062497 13.453241 14.660258 13.216797 14.435547 C 12.979641 14.209413 11.9726 14.097656 11.302734 14.097656 C 10.974911 14.097656 10.637503 14.14831 10.292969 14.25 C 9.94808 14.352756 9.5768336 14.450524 9.3300781 14.542969 L 9.4238281 12.849609 C 10.256184 12.510765 11.926611 12.036344 12.6875 11.794922 C 13.447322 11.554922 14.16535 11.433594 14.84375 11.433594 z " />
        </g>
    </svg>
</vi-icon>

<vi-icon name="User">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 20.599206,14.561598 C 22.659139,13.105438 24.008751,10.72586 24.008751,7.991121 24.044267,3.587125 20.457142,0 16.01763,0 11.578118,0 7.9909928,3.587125 7.9909928,8.026637 c 0,2.699223 1.349612,5.114317 3.4095452,6.570477 -5.1143172,1.882353 -8.7369592,6.748058 -8.7369592,12.501665 l 0,3.374029 C 2.6635788,31.325194 3.3383848,32 4.1907708,32 l 23.6182022,0 c 0.852386,0 1.527192,-0.674806 1.527192,-1.527192 l 0,-3.374029 c 0.03552,-5.753607 -3.622641,-10.654828 -8.736959,-12.537181 z" />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Visible">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 16.003906 6.7617188 C 8.6134996 6.7617188 2.3882063 12.919777 0.32421875 15.216797 C -0.10855285 15.682857 -0.10855285 16.414799 0.32421875 16.880859 C 2.3882063 19.144589 8.6467896 25.238281 16.003906 25.238281 C 23.327733 25.238281 29.553113 19.213036 31.650391 16.916016 C 32.116452 16.449956 32.116452 15.682857 31.650391 15.216797 C 29.453243 12.919777 22.861671 6.7617188 16.003906 6.7617188 z M 16.037109 9.6582031 C 19.565862 9.6582031 22.429688 12.520078 22.429688 16.048828 C 22.429688 19.577588 19.532572 22.441406 16.037109 22.441406 C 12.508356 22.441406 9.6464844 19.577588 9.6464844 16.048828 C 9.6464844 12.520078 12.508356 9.6582031 16.037109 9.6582031 z M 16.037109 13.953125 A 2.0972778 2.0972778 0 0 0 13.939453 16.048828 A 2.0972778 2.0972778 0 0 0 16.037109 18.146484 A 2.0972778 2.0972778 0 0 0 18.134766 16.048828 A 2.0972778 2.0972778 0 0 0 16.037109 13.953125 z " />
        </g>
    </svg>
</vi-icon>

<vi-icon name="Invisible">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 28.6875 2.4511719 L 22.195312 8.9414062 C 20.231204 8.0425764 18.134465 7.4433594 16.003906 7.4433594 C 8.6135299 7.4433594 2.3881979 13.603381 0.32421875 15.900391 C -0.10855107 16.366451 -0.10855107 17.098403 0.32421875 17.564453 C 1.5226583 18.896053 4.186279 21.526124 7.6484375 23.490234 L 3.453125 27.685547 L 5.3183594 29.548828 L 30.552734 4.3144531 L 28.6875 2.4511719 z M 16.070312 10.306641 C 17.435203 10.306641 18.667229 10.740373 19.699219 11.439453 L 16.503906 14.634766 C 16.370746 14.634766 16.20356 14.601563 16.037109 14.601562 C 14.87196 14.601562 13.939453 15.534069 13.939453 16.699219 C 13.939453 16.865669 13.939369 17.030904 13.972656 17.164062 L 10.810547 20.328125 C 10.111457 19.296135 9.6796875 18.064109 9.6796875 16.699219 C 9.6796875 13.170479 12.541576 10.306641 16.070312 10.306641 z M 26.490234 11.439453 L 22.296875 15.632812 C 22.363455 15.999003 22.396484 16.366232 22.396484 16.732422 C 22.396484 20.261162 19.532645 23.123047 16.003906 23.123047 C 15.637716 23.123047 15.27244 23.090036 14.90625 23.023438 L 12.441406 25.488281 C 13.573266 25.787891 14.772177 25.953125 16.003906 25.953125 C 23.327703 25.953125 29.553121 19.927869 31.650391 17.630859 C 32.116449 17.098219 32.116449 16.366536 31.650391 15.867188 C 30.684981 14.868488 28.820533 13.070663 26.490234 11.439453 z " />
        </g>
    </svg>
</vi-icon>`);

let QueryGridCellBoolean = class QueryGridCellBoolean extends QueryGridCell {
    static get template() { return html$3 `<style>:host {
  --vi-icon-selected-checked-color: var(--vi-query-grid-cell-boolean-checked-color, #555);
  display: block;
}
:host > * {
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
}
:host > vi-icon {
  position: unset;
}
:host([is-app-sensitive][sensitive]) {
  filter: blur(5px);
}</style>`; }
    _valueChanged(value, oldValue) {
        this._setOldValue(oldValue == null ? null : oldValue);
    }
    _update(value, oldValue) {
        this._setSensitive(value?.column.isSensitive);
        if (!!value && !!oldValue && value.getValue() === oldValue.getValue()) {
            const oldHints = oldValue.column.typeHints;
            const hints = value.column.typeHints;
            if ((!oldHints && !hints) || (hints && oldHints && JSON.stringify(value.column.typeHints) === JSON.stringify(oldValue.column.typeHints)))
                return;
        }
        if (!value) {
            if (this._icon) {
                this._icon.setAttribute("hidden", "");
                this._isHidden = true;
            }
            if (this._textNode && this._textNode.nodeValue)
                this._textNode.nodeValue = "";
        }
        else {
            const displayValue = value.getValue();
            if (displayValue == null) {
                if (this._icon) {
                    this._icon.setAttribute("hidden", "");
                    this._isHidden = true;
                }
                if (!this._textNode)
                    this._textNode = this.shadowRoot.appendChild(document.createTextNode(value.column.typeHints["nullkey"] || "—"));
                else
                    this._textNode.nodeValue = value.column.typeHints["nullkey"] || "—";
            }
            else if (!value.column.typeHints || ((!value.column.typeHints["falsekey"] && !displayValue) || (!value.column.typeHints["truekey"] && displayValue))) {
                if (this._isHidden) {
                    this._icon.removeAttribute("hidden");
                    this._isHidden = false;
                }
                if (this._textNode && this._textNode.nodeValue)
                    this._textNode.nodeValue = "";
                if (!this._icon) {
                    const icon = new Icon();
                    icon.source = "Selected";
                    this._icon = this.shadowRoot.appendChild(icon);
                }
                if (!value.getValue())
                    this._icon.removeAttribute("is-selected");
                else
                    this._icon.setAttribute("is-selected", "");
            }
            else {
                const displayTextKey = value.column.typeHints[displayValue ? "truekey" : "falsekey"];
                const displayTextValue = this.translations[displayTextKey] || displayTextKey;
                if (!this._textNode)
                    this._textNode = this.shadowRoot.appendChild(document.createTextNode(displayTextValue));
                else
                    this._textNode.nodeValue = displayTextValue;
            }
        }
    }
};
QueryGridCellBoolean = __decorate([
    WebComponent.register({
        properties: {
            value: {
                type: Object,
                observer: "_valueChanged"
            },
            oldValue: {
                type: Object,
                readOnly: true
            }
        },
        observers: [
            "_update(value, oldValue, isConnected)"
        ],
        sensitive: true
    })
], QueryGridCellBoolean);
QueryGridCell.registerCellType("Boolean", QueryGridCellBoolean);
QueryGridCell.registerCellType("NullableBoolean", QueryGridCellBoolean);
QueryGridCell.registerCellType("YesNo", QueryGridCellBoolean);

var _QueryGridCellCommonMark_asmarkdown, _QueryGridCellCommonMark_textNode, _QueryGridCellCommonMark_textNodeValue, _QueryGridCellCommonMark_markdownValue;
let QueryGridCellCommonMark = class QueryGridCellCommonMark extends QueryGridCellDefault {
    constructor() {
        super(...arguments);
        _QueryGridCellCommonMark_asmarkdown.set(this, void 0);
        _QueryGridCellCommonMark_textNode.set(this, void 0);
        _QueryGridCellCommonMark_textNodeValue.set(this, void 0);
        _QueryGridCellCommonMark_markdownValue.set(this, void 0);
    }
    static get template() { return html$3 `<style>:host {
  padding: 0 var(--theme-h5);
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
  min-width: var(--theme-h2);
}
:host #text {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
:host([is-app-sensitive][sensitive]) #text {
  filter: blur(5px);
}
:host([tag]) {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
}
:host([tag]) #text {
  border-radius: var(--theme-h5);
  background-color: var(--tag-background);
  color: var(--foreground, white);
  line-height: var(--theme-h3);
  padding: 0 var(--theme-h5);
}</style>
<style>p {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

p, ol {
  margin: 0;
  padding: 0;
}

a, a:visited {
  display: inline-block;
  line-height: var(--vi-query-grid-row-height);
  color: var(--theme-color);
}

vi-icon {
  display: inline-block;
  pointer-events: all;
  vertical-align: -2px;
}</style>
<div id="text" on-click="_onClick"></div>`; }
    _clearCell() {
        super._clearCell();
        if (__classPrivateFieldGet(this, _QueryGridCellCommonMark_asmarkdown, "f") && __classPrivateFieldGet(this, _QueryGridCellCommonMark_markdownValue, "f")) {
            this.$.text.innerHTML = "";
            __classPrivateFieldSet(this, _QueryGridCellCommonMark_markdownValue, null, "f");
        }
    }
    _updateCell(value) {
        const asmarkdown = this._getTypeHint(this.value.column, "displayingrid", null);
        __classPrivateFieldSet(this, _QueryGridCellCommonMark_asmarkdown, Boolean.parse(asmarkdown), "f");
        if (__classPrivateFieldGet(this, _QueryGridCellCommonMark_asmarkdown, "f")) {
            if (__classPrivateFieldGet(this, _QueryGridCellCommonMark_textNode, "f")) {
                this.$.text.removeChild(__classPrivateFieldGet(this, _QueryGridCellCommonMark_textNode, "f"));
                __classPrivateFieldSet(this, _QueryGridCellCommonMark_textNode, __classPrivateFieldSet(this, _QueryGridCellCommonMark_textNodeValue, null, "f"), "f");
            }
            if (__classPrivateFieldGet(this, _QueryGridCellCommonMark_markdownValue, "f") !== value) {
                this.$.text.innerHTML = getMarkdown(__classPrivateFieldSet(this, _QueryGridCellCommonMark_markdownValue, value, "f"), {
                    addTags: "VI-ICON"
                });
            }
            return;
        }
        if (__classPrivateFieldGet(this, _QueryGridCellCommonMark_markdownValue, "f")) {
            this.$.text.innerHTML = "";
            __classPrivateFieldSet(this, _QueryGridCellCommonMark_markdownValue, null, "f");
        }
        super._updateCell(value);
    }
    _onClick(e) {
        if (e.target instanceof HTMLAnchorElement) {
            e.stopPropagation();
            if (!e.ctrlKey && e.target.href.startsWith(Path.routes.root || "") && !(e.target.getAttribute("rel") || "").contains("external")) {
                e.preventDefault();
                let path = e.target.href.slice(Path.routes.root.length);
                if (path.startsWith("#!/"))
                    path = path.substring(3);
                this.app.changePath(path);
            }
        }
    }
};
_QueryGridCellCommonMark_asmarkdown = new WeakMap();
_QueryGridCellCommonMark_textNode = new WeakMap();
_QueryGridCellCommonMark_textNodeValue = new WeakMap();
_QueryGridCellCommonMark_markdownValue = new WeakMap();
QueryGridCellCommonMark = __decorate([
    WebComponent.register({
        properties: {
            value: {
                type: Object,
                observer: "_valueChanged"
            },
            column: Object,
            right: {
                type: Boolean,
                reflectToAttribute: true
            },
            tag: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        sensitive: true
    })
], QueryGridCellCommonMark);
QueryGridCell.registerCellType("CommonMark", QueryGridCellCommonMark);

let QueryGridCellImage = class QueryGridCellImage extends QueryGridCell {
    static get template() { return html$3 `<style>:host {
  display: block;
  padding: 0 1px;
  overflow: hidden;
}
:host .image {
  height: var(--vi-query-grid-row-height);
  background-position: center center;
  background-size: contain;
  background-repeat: no-repeat;
}
:host([is-app-sensitive][sensitive]) {
  filter: blur(5px);
}</style>`; }
    _valueChanged(value) {
        this._setSensitive(value?.column.isSensitive);
        if (!value || !value.value) {
            if (this._image && !this._image.hasAttribute("hidden")) {
                this._image.style.backgroundImage = "";
                this._image.setAttribute("hidden", "");
                this._isHidden = true;
            }
            return;
        }
        if (!this._image) {
            this.shadowRoot.appendChild(this._image = document.createElement("div"));
            this._image.classList.add("image");
        }
        if (this._isHidden) {
            this._image.removeAttribute("hidden");
            this._isHidden = false;
        }
        this._image.style.backgroundImage = "url(" + value.value.asDataUri() + ")";
    }
};
QueryGridCellImage = __decorate([
    WebComponent.register({
        properties: {
            value: {
                type: Object,
                observer: "_valueChanged"
            }
        },
        sensitive: true
    })
], QueryGridCellImage);
QueryGridCell.registerCellType("Image", QueryGridCellImage);

let QueryGridRowGroup = class QueryGridRowGroup extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  box-sizing: border-box;
  border-bottom: 1px solid var(--theme-light-border);
  cursor: pointer;
  background-color: #f5f5f5;
  min-width: 100%;
}
:host(:not([first])) {
  border-top: 1px solid var(--theme-light-border);
}
:host([collapsed]) vi-icon {
  transform: rotate(-45deg);
}
:host vi-icon {
  height: var(--vi-query-grid--row-height, var(--theme-h2));
  width: var(--theme-h2);
  transition: transform 0.2s ease;
}
:host label {
  line-height: var(--vi-query-grid--row-height, var(--theme-h2));
}
:host > div {
  transform: translateX(var(--vi-query-grid-horizontal));
}</style>

<div class="layout horizontal">
    <vi-icon source="QueryGrid_Group_Row"></vi-icon>
    <label>[[group.name]] ([[group.items.length]])</label>
</div>

<vi-icon name="QueryGrid_Group_Row">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 24 8 L 8 24 L 24 24 L 24 8 z "></path>
        </g>
    </svg>
</vi-icon>`; }
    _computeFirst(group) {
        return !!group && group.start === 0;
    }
    _tap() {
        this.group.isCollapsed = !this.group.isCollapsed;
    }
};
QueryGridRowGroup = __decorate([
    WebComponent.register({
        properties: {
            group: Object,
            first: {
                type: Boolean,
                computed: "_computeFirst(group)"
            },
            collapsed: {
                type: Boolean,
                computed: "group.isCollapsed",
                reflectToAttribute: true
            }
        },
        forwardObservers: [
            "group.isCollapsed"
        ],
        listeners: {
            "tap": "_tap"
        }
    })
], QueryGridRowGroup);

let QueryGridRow = class QueryGridRow extends WebComponent {
    constructor() {
        super(...arguments);
        this._invisibleCellValues = [];
    }
    static get template() { return html$3 `<style>:host {
  display: grid;
  position: relative;
  width: initial;
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
  min-width: 100%;
  overflow: visible;
  white-space: nowrap;
  background-color: white;
}
:host(:nth-of-type(even)) > ::slotted(.column), :host(:nth-of-type(even)) > .pinned {
  background-color: var(--vi-query-grid-row-even-color, white);
}
:host(:nth-of-type(odd)), :host(:nth-of-type(odd)) ::slotted(.column), :host(:nth-of-type(odd)) .pinned {
  background-color: var(--vi-query-grid-row-odd-color, #FAFAFA);
}
:host(:nth-of-type(odd).loading), :host(:nth-of-type(odd).loading) ::slotted(.column), :host(:nth-of-type(odd).loading) .pinned {
  background-color: var(--vi-query-grid-row-odd-color, #FCFCFC);
}
:host(:not(.loading):hover) {
  cursor: pointer;
}
:host(:not(.loading):hover), :host(:not(.loading):hover) ::slotted(.column), :host(:not(.loading):hover) .pinned {
  background-color: var(--color-semi-faint);
}
:host .pinned {
  transform: translateX(var(--vi-query-grid-horizontal));
  z-index: 0;
}
:host .reorder {
  pointer-events: all;
  cursor: grabbing;
}
:host .selector:hover > vi-icon, :host .actions:hover > vi-icon, :host .reorder:hover > vi-icon {
  background-color: rgba(0, 0, 0, 0.05) !important;
}
:host .selector > vi-icon, :host .actions > vi-icon, :host .reorder > vi-icon {
  width: var(--vi-query-grid-row-height);
  height: var(--vi-query-grid-row-height);
}
:host(.loading) .selector, :host(.loading) .actions, :host(.loading) ::slotted(.column) {
  visibility: hidden;
}
:host(.hidden) {
  display: none !important;
}
:host(.disabled) .selector, :host(.disabled) .actions, :host(.readonly) .selector, :host(.readonly) .actions {
  visibility: hidden;
  pointer-events: none;
}
:host(.disabled) {
  cursor: default;
}
:host([initializing][is-group]), :host([initializing]) .pinned {
  display: none !important;
}
:host([is-group]) {
  grid-template-columns: 1fr !important;
}
:host([is-group]) ::slotted(.column), :host([is-group]) .pinned {
  display: none;
}
:host(:not([is-group])) ::slotted([slot=group]) {
  display: none;
}
:host [part=groupspacer], :host [part=filter] {
  display: none;
  width: var(--vi-query-grid-row-height);
}
:host vi-popup[open] {
  z-index: 10;
}

:host-context([has-grouping]) [part=groupspacer] {
  display: block;
}</style>

<dom-if if="[[!initializing]]">
    <template>
        <slot name="group"></slot>

        <div part="groupspacer" class="pinned"></div>

        <dom-if if="[[canReorder]]">
            <template>
                <div class="reorder pinned sort-handle" on-tap="_catchTap" part="reorder">
                    <vi-icon source="Hamburger"></vi-icon>
                </div>
            </template>
        </dom-if>

        <div class="selector pinned" on-tap="_onSelect" part="selector">
            <vi-icon source="Selected" is-selected$="[[item.isSelected]]"></vi-icon>
        </div>

        <vi-popup id="actions" class="actions pinned" part="actions" on-popup-opening="_onActionsOpening" on-popup-closed="_onActionsClosed" on-tap="_preventOpen">
            <vi-icon slot="header" source="EllipsisVertical"></vi-icon>
        </vi-popup>

        <div part="filter" class="pinned"></div>
    </template>
</dom-if>

<slot id="columns"></slot>`; }
    _columnsChanged(columns) {
        const existingCells = Array.from(this.$.columns.assignedElements());
        for (let i = 0; i < columns.length; i++) {
            const column = columns[i];
            let cell = existingCells.find(c => c.column.name === column.name);
            if (!cell) {
                cell = new (QueryGridCell.getCellTypeConstructor(column.type) || QueryGridCellDefault)();
                cell.classList.add("column");
                cell.value = this.item instanceof QueryResultItem ? this.item.getFullValue(column.name) : undefined;
            }
            else
                existingCells.remove(cell);
            cell.column = column;
            this.appendChild(cell);
        }
        existingCells.forEach(cell => {
            this.removeChild(cell);
        });
    }
    _itemChanged(item, oldItem) {
        if (item != null) {
            this.classList.toggle("loading", !(item instanceof QueryResultItem || item instanceof QueryResultItemGroup));
            this.classList.remove("hidden");
        }
        else if (item === null)
            this.classList.add("hidden");
        const cells = this.$.columns.assignedElements();
        if (item instanceof QueryResultItem || oldItem instanceof QueryResultItem) {
            const extraclass = item instanceof QueryResultItem ? item.getTypeHint("extraclass", "") : "";
            if (this._extraclass && this._extraclass !== extraclass) {
                this.classList.remove(...this._extraclass.split(" "));
                this._extraclass = null;
            }
            if (extraclass) {
                this.classList.add(...(extraclass.split(" ")));
                this._extraclass = extraclass;
            }
            this._invisibleCellValues = [];
            cells.forEach((cell, index) => {
                if (!this._visibleCells || this._visibleCells.indexOf(cell) >= 0)
                    cell.value = this.item instanceof QueryResultItem ? this.item.getFullValue(cell.column.name) : null;
                else
                    this._invisibleCellValues.push([cell, this.item instanceof QueryResultItem ? this.item.getFullValue(cell.column.name) : null]);
            });
        }
        if (oldItem instanceof QueryResultItemGroup) {
            this._groupElement.group = null;
            this._setIsGroup(false);
        }
        if (item instanceof QueryResultItemGroup) {
            if (!this._groupElement) {
                this._groupElement = new QueryGridRowGroup();
                this.appendChild(this._groupElement);
            }
            this._groupElement.slot = "group";
            this._setIsGroup(true);
            this._groupElement.group = item;
            this._groupElement.style.gridColumn = `1 / span ${this.columns.length + 3}`;
        }
    }
    _flush(offsets, visibleRange) {
        const cells = this.$.columns.assignedElements();
        this._visibleCells = cells.filter((cell, index) => {
            const visible = this.columns[index].isPinned || !(offsets[index][1] < visibleRange[0] || offsets[index][0] > visibleRange[1] - 64);
            if (visible && this._visibleCells && this._visibleCells.indexOf(cell) < 0) {
                const invisibleCellIndex = this._invisibleCellValues.findIndex(cellValue => cellValue[0] === cell);
                if (invisibleCellIndex >= 0) {
                    const update = this._invisibleCellValues.splice(invisibleCellIndex, 1)[0];
                    update[0].value = update[1];
                }
            }
            return visible;
        });
    }
    _preventOpen(e) {
        e.stopPropagation();
    }
    async _onTap(e) {
        if (!(this.item instanceof QueryResultItem))
            return;
        if (this.item.getTypeHint("extraclass", "").split(" ").some(c => c.toUpperCase() === "DISABLED"))
            return;
        if (this.fire("item-tap", { item: this.item }, { bubbles: true, composed: true, cancelable: true }).defaultPrevented)
            return;
        let openaction = this.item.getTypeHint("openaction", null);
        if (openaction) {
            const action = this.item.query.actions.find(a => a.name === openaction) || Action.get(this.item.service, openaction, this.item.query);
            if (action)
                await action.execute({ selectedItems: [this.item] });
            else
                console.warn(`Unknown openaction '${openaction}'.`);
            return;
        }
        if (this.item.query.canRead && !this.item.query.asLookup) {
            if (e.detail.sourceEvent && (e.detail.sourceEvent.ctrlKey || e.detail.sourceEvent.shiftKey) && this.app instanceof App) {
                window.open(Path.routes.root + this.app.getUrlForPersistentObject(this.item.query.persistentObject.id, this.item.id));
                e.stopPropagation();
                return;
            }
            const grid = this.getRootNode().host;
            grid["_itemOpening"] = this.item;
            const po = await this.item.getPersistentObject();
            if (!po)
                return;
            if (grid["_itemOpening"] === this.item) {
                grid["_itemOpening"] = undefined;
                this.item.query.service.hooks.onOpen(po);
            }
        }
    }
    async _onContextmenu(e) {
        if (!(this.item instanceof QueryResultItem) || this.item.query.asLookup)
            return;
        if (this.item.getTypeHint("extraclass", "").split(" ").map(c => c.toUpperCase()).some(c => c === "DISABLED" || c === "READONLY"))
            return;
        const grid = this.findParent(e => e instanceof QueryGrid);
        if (e.button !== 2 || e.shiftKey || e.ctrlKey || grid.asLookup)
            return true;
        let [x, y] = [e.pageX, e.pageY];
        const actionsPopup = new Popup();
        actionsPopup.style.position = "fixed";
        actionsPopup.style.left = `${x}px`;
        actionsPopup.style.top = `${y}px`;
        const anchor = document.createElement("div");
        anchor.style.width = `1px`;
        anchor.style.height = `1px`;
        anchor.setAttribute("slot", "header");
        actionsPopup.appendChild(anchor);
        actionsPopup.addEventListener("popup-opening", this._onActionsOpening.bind(this));
        actionsPopup.addEventListener("popup-closed", this._onActionsClosed.bind(this));
        this.shadowRoot.appendChild(actionsPopup);
        grid.shadowRoot.appendChild(actionsPopup);
        e.preventDefault();
        try {
            await actionsPopup.popup();
        }
        finally {
            grid.shadowRoot.removeChild(actionsPopup);
        }
    }
    _onSelect(e) {
        e.stopPropagation();
        const mouse = e.detail.sourceEvent instanceof MouseEvent ? e.detail.sourceEvent : null;
        this.fire("item-select", {
            item: this.item,
            shift: mouse ? mouse.shiftKey : false,
            ctrl: this.app.configuration.getSetting("vi-query-grid.single-click", "true").toLowerCase() === "true" || (mouse ? mouse.ctrlKey : true)
        }, { bubbles: true });
    }
    async _onActionsOpening(e) {
        if (this.item.query.selectedItems.length > 0 && this.item.query.selectedItems.indexOf(this.item) < 0) {
            this.item.query.selectAll.allSelected = this.item.query.selectAll.inverse = false;
            this.item.query.selectedItems = [this.item];
        }
        const actions = (this.item.query.actions || []).filter(a => a.isVisible && a.definition.selectionRule !== ExpressionParser.alwaysTrue && a.selectionRule(Math.max(1, this.item.query.selectedItems.length)));
        if (actions.length === 0)
            return;
        const actionGroups = {};
        actions.forEach(action => {
            let actionOrGroup;
            if (action.group) {
                if (!!actionGroups[action.group.name])
                    return;
                actionOrGroup = actionGroups[action.group.name] = action.group;
            }
            else
                actionOrGroup = action;
            const button = new ActionButton(this.item.query.selectedItems.length === 0 ? this.item : null, actionOrGroup);
            button.forceLabel = true;
            button.inverse = true;
            button.openOnHover = true;
            button.setAttribute("overflow", "");
            e.target.appendChild(button);
        });
        this.style.zIndex = "1";
        e.stopPropagation();
    }
    _onActionsClosed(e) {
        const actions = e.target;
        Array.from(actions.children).filter(c => !c.hasAttribute("slot")).forEach(c => actions.removeChild(c));
        this.style.zIndex = "auto";
        e.stopPropagation();
    }
    _catchTap(e) {
        e.stopPropagation();
    }
    refresh() {
        this._itemChanged(this.item, this.item);
    }
};
QueryGridRow = __decorate([
    WebComponent.register({
        properties: {
            item: {
                type: Object,
                observer: "_itemChanged"
            },
            index: Number,
            columns: {
                type: Array,
                observer: "_columnsChanged"
            },
            isGroup: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            offsets: Array,
            visibleRange: Array,
            initializing: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            canReorder: Boolean
        },
        forwardObservers: [
            "item.isSelected"
        ],
        listeners: {
            "tap": "_onTap",
            "contextmenu": "_onContextmenu"
        },
        observers: [
            "_flush(offsets, visibleRange)"
        ]
    })
], QueryGridRow);

let QueryGridSelectAll = class QueryGridSelectAll extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  position: relative;
  width: var(--vi-query-grid-row-height);
  box-sizing: border-box;
  align-self: flex-end;
  cursor: pointer;
}
:host > vi-icon {
  height: var(--vi-query-grid-row-height);
  width: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
}
:host([partial]) > * {
  opacity: 0.5;
}
:host(:not([partial]):not([can-select-all])) {
  cursor: default;
}
:host(:not([partial]):not([can-select-all])) > * {
  visibility: hidden;
}</style>

<paper-ripple></paper-ripple>
<vi-icon source="Selected" is-selected$="[[selected]]"></vi-icon>`; }
    _toggle() {
        if (!this.query)
            return;
        if (this.query.selectAll.isAvailable && !this.partial)
            this.query.selectAll.allSelected = !this.query.selectAll.allSelected;
        else {
            if (this.query.selectAll.isAvailable)
                this.query.selectAll.allSelected = false;
            this.query.selectedItems = [];
        }
    }
    _computePartial(selectedItems, allSelected, inverse) {
        return inverse || (!allSelected && selectedItems != null && selectedItems.length > 0);
    }
    _computeSelected(partial, allSelected) {
        return partial || allSelected;
    }
};
QueryGridSelectAll = __decorate([
    WebComponent.register({
        properties: {
            query: Object,
            canSelectAll: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "query.selectAll.isAvailable"
            },
            selected: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeSelected(partial, query.selectAll.allSelected)"
            },
            partial: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computePartial(query.selectedItems, query.selectAll.allSelected, query.selectAll.inverse)"
            }
        },
        forwardObservers: [
            "query.selectedItems",
            "query.selectAll.allSelected",
            "query.selectAll.inverse",
            "query.selectAll.isAvailable"
        ],
        listeners: {
            "tap": "_toggle"
        }
    })
], QueryGridSelectAll);

let QueryGridConfigureDialogColumn = class QueryGridConfigureDialogColumn extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  min-width: 20em;
  margin-bottom: 4px;
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  font-size: 15px;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
:host > vi-icon {
  width: var(--theme-h2);
  height: var(--theme-h2);
  fill: #888;
  pointer-events: none;
}
:host label {
  flex: 1;
  min-height: 0;
  min-width: 0;
  background-color: #f9f9f9;
  margin-left: var(--theme-h4);
  padding-left: var(--theme-h4);
  padding-right: var(--theme-h1);
  pointer-events: none;
  overflow: hidden;
  text-overflow: ellipsis;
}
:host .buttons {
  background-color: #f9f9f9;
}
:host .buttons vi-button {
  fill: var(--color);
}
:host(:not([is-pinned])) .buttons vi-button:nth-child(1) {
  opacity: 0.5;
}
:host([is-hidden]) .buttons vi-button:nth-child(2) {
  opacity: 0.5;
}</style>

<vi-icon source="Hamburger"></vi-icon>
<label>[[column.column.label]]</label>
<div class="buttons layout horizontal">
    <vi-button inverse icon="Pin" on-tap="_togglePin"></vi-button>
    <vi-button inverse icon="Eye" on-tap="_toggleVisible"></vi-button>
</div>`; }
    constructor(column) {
        super();
        this.column = column;
        if (!column)
            return;
        this.offset = this.column.offset;
        this.isPinned = this.column.isPinned;
        this.isHidden = this.column.isHidden;
    }
    _togglePin() {
        this.isPinned = !this.isPinned;
        this.fire("distribute-columns", {}, { bubbles: true });
    }
    _toggleVisible() {
        this.isHidden = !this.isHidden;
    }
};
QueryGridConfigureDialogColumn = __decorate([
    WebComponent.register({
        properties: {
            column: Object,
            isPinned: {
                type: Boolean,
                reflectToAttribute: true
            },
            isHidden: {
                type: Boolean,
                reflectToAttribute: true
            }
        }
    })
], QueryGridConfigureDialogColumn);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS$1 = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(
el,
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(
el,
selector,
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable$1.ghost && (includeDragEl || children[i] !== Sortable$1.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable$1.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable$1.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = 'Sortable' + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable$1.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target);
        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable$1)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable$1.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
_silent = false,
    savedInputChecked = [];
var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS$1,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
supportDraggable = documentExists && !ChromeForAndroid && !IOS$1 && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }
  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }
  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable$1(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable$1.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable$1.prototype =
{
  constructor: Sortable$1,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  evt) {
    if (!evt.cancelable) return;
    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  evt,
  touch,
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable$1.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable$1.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable$1.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  evt,
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable$1.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        }
        while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable$1.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable$1.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  evt,
  fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable$1.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable$1.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable$1.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable$1.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  _onDragOver: function _onDragOver(
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable$1.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable$1.active) {
          putSortable = _this;
        } else if (_this === Sortable$1.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable$1.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl)
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable$1.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable$1.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  evt) {
    var el = this.el,
        options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable$1.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable$1.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable$1.dragged = Sortable$1.ghost = Sortable$1.clone = Sortable$1.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable$1.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable$1.eventCanceled) return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver(
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable$1.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable$1.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
Sortable$1.get = function (element) {
  return element[expando];
};
Sortable$1.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable$1.utils = _objectSpread2(_objectSpread2({}, Sortable$1.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable$1.create = function (el, options) {
  return new Sortable$1(el, options);
};
Sortable$1.version = version;
var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn;
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function () {
          if (isFallback && this.layer === 0) {
            Sortable$1.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable$1.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});
Sortable$1.mount(new AutoScrollPlugin());
Sortable$1.mount(Remove, Revert);

const _groups = [];
let Sortable = class Sortable extends WebComponent {
    connectedCallback() {
        super.connectedCallback();
        if (this.group)
            _groups.push(this);
        this._create();
    }
    disconnectedCallback() {
        if (this.group)
            _groups.remove(this);
        this._destroy();
        super.disconnectedCallback();
    }
    groupChanged() {
        this._sortable.option("group", this.group);
        if (this.group)
            _groups.push(this);
        else
            _groups.remove(this);
    }
    filterChanged() {
        this._sortable.option("filter", this.filter);
    }
    handleChanged() {
        this._sortable.option("handle", this.handle);
    }
    draggableItemsChangted() {
        this._sortable.option("draggable", this.draggableItems);
    }
    _dragStart() {
        this.fire("drag-start", undefined);
    }
    _dragEnd(element, newIndex, oldIndex) {
        this.fire("drag-end", {
            element: element,
            newIndex: newIndex,
            oldIndex: oldIndex
        });
    }
    _create() {
        this._destroy();
        this._sortable = Sortable$1.create(this, {
            group: this.group,
            filter: this.filter,
            handle: this.handle,
            disabled: !this.enabled,
            animation: 150,
            onStart: () => {
                this._setIsDragging(true);
                if (this.group)
                    _groups.filter(s => s.group === this.group).forEach(s => s._setIsGroupDragging(true));
                this._dragStart();
            },
            onEnd: (e) => {
                this._setIsDragging(false);
                if (this.group)
                    _groups.filter(s => s.group === this.group).forEach(s => s._setIsGroupDragging(false));
                this._dragEnd(e.item, e.newIndex, e.oldIndex);
            }
        });
        if (this.draggableItems)
            this._sortable.option("draggable", this.draggableItems);
    }
    _destroy() {
        if (this._sortable) {
            this._sortable.destroy();
            this._sortable = null;
        }
    }
    _enabledChanged(enabled) {
        if (this._sortable)
            this._sortable.option("disabled", !enabled);
    }
};
Sortable = __decorate([
    WebComponent.registerAbstract({
        properties: {
            "group": {
                type: String,
                reflectToAttribute: true,
            },
            "filter": {
                type: String,
                reflectToAttribute: true
            },
            "draggableItems": {
                type: String,
                reflectToAttribute: true
            },
            "handle": {
                type: String,
                reflectToAttribute: true
            },
            "isDragging": {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            "isGroupDragging": {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            "enabled": {
                type: Boolean,
                reflectToAttribute: true,
                observer: "_enabledChanged"
            }
        }
    })
], Sortable);

let QueryGridConfigureDialog = class QueryGridConfigureDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host main {
  display: flex;
  flex-direction: column;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  padding: var(--theme-h4) 0 var(--theme-h4) var(--theme-h5);
  max-height: calc(80vh - (var(--theme-h1) + var(--theme-h5) * 2) - (var(--theme-h2) + var(--theme-h4) * 2));
}
:host main > vi-scroller {
  flex: 1;
  min-height: 0;
  min-width: 0;
  margin-top: var(--theme-h4);
}
:host main vi-query-grid-configure-dialog-column-list {
  display: block;
  padding: 0 var(--theme-h4) 0 0;
}
:host main vi-query-grid-configure-dialog-column-list:empty {
  display: none;
}
:host footer > vi-button {
  margin: 0;
}
:host footer > div vi-button:first-child {
  margin-right: var(--theme-h5);
}</style>

<header>[[query.label]]</header>
<main>
    <vi-query-grid-configure-dialog-column-list id="pinned" enabled group="pinned"></vi-query-grid-configure-dialog-column-list>
    <vi-scroller no-horizontal>
        <vi-query-grid-configure-dialog-column-list id="unpinned" enabled group="unpinned"></vi-query-grid-configure-dialog-column-list>
    </vi-scroller>
</main>
<footer class="horizontal layout justified">
    <vi-button inverse class="self-end" on-tap="_reset" action-type="Default" label="[[translateMessage('Reset', isConnected)]]"></vi-button>
    <div class="buttons horizontal layout">
        <vi-button on-tap="_save" action-type="Default" label="[[translateMessage('Save', isConnected)]]"></vi-button>
        <vi-button inverse on-tap="cancel" label="[[translateMessage('Cancel', isConnected)]]"></vi-button>
    </div>
</footer>`); }
    constructor(query, _settings) {
        super();
        this.query = query;
        this._settings = _settings;
    }
    connectedCallback() {
        this._elements = this._settings.columns.filter(c => c.width !== "0").map(c => new QueryGridConfigureDialogColumn(c));
        this._distributeColumns();
        super.connectedCallback();
    }
    _distributeColumns(e) {
        const columns = this._elements.orderBy(c => c.column.offset);
        animationFrame.run(() => {
            this._updateColumns(this.$.pinned, columns.filter(c => c.isPinned));
            this._updateColumns(this.$.unpinned, columns.filter(c => !c.isPinned));
        });
        e?.stopPropagation();
    }
    _updateColumns(target, columns) {
        columns.orderBy(c => c.offset).forEach(col => target.appendChild(col));
    }
    _reorderColumns(e) {
        const list = e.composedPath()[0];
        const children = Array.from(list.children);
        const offsets = children.orderBy(c => c.column.offset).map(c => c.column.offset);
        children.forEach((child, index) => {
            child.offset = offsets[index];
        });
        e.stopPropagation();
    }
    _save() {
        this._elements.forEach(c => {
            c.column.isPinned = c.isPinned;
            c.column.isHidden = c.isHidden;
            c.column.offset = c.offset;
        });
        this.close(true);
    }
    _reset() {
        this._elements.forEach(c => {
            c.isPinned = c.column.column.isPinned;
            c.isHidden = c.column.column.isHidden;
            c.offset = c.column.column.offset;
            c.column.width = undefined;
        });
        this._distributeColumns();
    }
};
QueryGridConfigureDialog = __decorate([
    WebComponent.register({
        properties: {
            query: Object
        },
        listeners: {
            "distribute-columns": "_distributeColumns",
            "reorder-columns": "_reorderColumns"
        }
    })
], QueryGridConfigureDialog);
let QueryGridConfigureDialogColumnList = class QueryGridConfigureDialogColumnList extends Sortable {
    _dragEnd() {
        this.fire("reorder-columns", {}, { bubbles: true });
    }
};
QueryGridConfigureDialogColumnList = __decorate([
    WebComponent.register({})
], QueryGridConfigureDialogColumnList);

class QueryGridColumn extends Observable {
    constructor(_column, _userSettingsColumnData) {
        super();
        this._column = _column;
        this._userSettingsColumnData = _userSettingsColumnData;
    }
    get column() {
        return this._column;
    }
    get query() {
        return this._column.query;
    }
    get name() {
        return this._column.name;
    }
    get label() {
        return this._column.label;
    }
    get type() {
        return this._column.type;
    }
    get canSort() {
        return this._column.canSort;
    }
    get canGroupBy() {
        return this._column.canGroupBy;
    }
    get canFilter() {
        return this._column.canFilter;
    }
    get canListDistincts() {
        return this._column.canListDistincts;
    }
    get sortDirection() {
        return this._column.sortDirection;
    }
    get distincts() {
        return this._column.distincts;
    }
    get offset() {
        return this._userSettingsColumnData.offset != null ? this._userSettingsColumnData.offset : this._column.offset;
    }
    set offset(offset) {
        this._userSettingsColumnData.offset = offset;
    }
    get isPinned() {
        return this._userSettingsColumnData.isPinned != null ? this._userSettingsColumnData.isPinned : this._column.isPinned;
    }
    set isPinned(isPinned) {
        const wasPinned = !!this._userSettingsColumnData.isPinned;
        if (wasPinned === isPinned)
            return;
        this.notifyPropertyChanged("isPinned", this._userSettingsColumnData.isPinned = isPinned, wasPinned);
    }
    get isHidden() {
        return this._userSettingsColumnData.isHidden != null ? this._userSettingsColumnData.isHidden : this._column.isHidden;
    }
    set isHidden(isHidden) {
        this._userSettingsColumnData.isHidden = isHidden;
    }
    get width() {
        return this._userSettingsColumnData.width != null ? this._userSettingsColumnData.width : this._column.width;
    }
    set width(width) {
        this._userSettingsColumnData.width = width;
    }
}

class QueryGridUserSettings extends Observable {
    constructor(_query, data = {}) {
        super();
        this._query = _query;
        this._columnsByName = {};
        this._columns = [];
        this._columns = this._query.columns.filter(c => c.width !== "0").map(c => this._columnsByName[c.name] = new QueryGridColumn(c, data[c.name] || {
            offset: c.offset,
            isPinned: c.isPinned,
            isHidden: c.isHidden,
            width: c.width
        }));
        if (!this._columns?.length || this._columns.some(c => !c.isHidden))
            return;
        this._columns[0].isHidden = false;
    }
    getColumn(name) {
        return this._columnsByName[name];
    }
    get query() {
        return this._query;
    }
    get columns() {
        return this._columns.orderBy(c => c.offset);
    }
    async save(refreshOnComplete = true) {
        let queryData;
        const columnData = (name) => (queryData || (queryData = {}))[name] || (queryData[name] = {});
        this._columns.forEach(c => {
            if (c.offset !== c.column.offset)
                columnData(c.name).offset = c.offset;
            if (c.isPinned !== c.column.isPinned)
                columnData(c.name).isPinned = c.isPinned;
            if (c.isHidden !== c.column.isHidden)
                columnData(c.name).isHidden = c.isHidden;
            if (c.width !== c.column.width)
                columnData(c.name).width = c.width;
        });
        if (this._columns.length > 0 && !this._columns.some(c => !c.isHidden))
            this._columns[0].isHidden = false;
        if (queryData)
            this._query.service.application.userSettings["QueryGridSettings"][this._query.id] = queryData;
        else if (this._query.service.application.userSettings["QueryGridSettings"][this._query.id])
            delete this._query.service.application.userSettings["QueryGridSettings"][this._query.id];
        await this._query.service.application.saveUserSettings();
        if (refreshOnComplete)
            this.notifyPropertyChanged("columns", this._columns = this.columns.slice());
    }
    static Load(query) {
        const queryGridSettings = query.service.application.service.application.userSettings["QueryGridSettings"] || (query.service.application.userSettings["QueryGridSettings"] = {});
        return new QueryGridUserSettings(query, queryGridSettings[query.id]);
    }
}

const placeholder = {};
const queryScrollOffsets = new WeakMap();
const PHYSICAL_UPPER_LIMIT = 100000;
let QueryGrid = class QueryGrid extends WebComponent {
    constructor() {
        super(...arguments);
        this._columnWidths = new Map();
        this._virtualGridStartIndex = 0;
        this._verticalSpacerCorrection = 1;
    }
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  --vi-query-grid-row-height: var(--theme-h2);
}
:host([initializing]) header, :host([initializing]) vi-scroller {
  visibility: hidden;
}
:host([initializing]) vi-query-grid-row {
  display: contents;
}
:host([initializing]) .filler {
  display: none;
}
:host vi-scroller {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host [grid] {
  display: grid;
  grid-template-columns: var(--vi-query-grid-columns);
}
:host header {
  display: flex;
  flex-direction: row;
  position: relative;
  z-index: 1;
  border-bottom: 1px solid var(--theme-light-border);
}
:host header [grid] {
  margin-left: calc(var(--vi-query-grid-horizontal, 0) * -1);
}
:host header .controls {
  display: grid;
  background-color: white;
  position: relative;
  z-index: 1;
}
:host header .controls .reorder, :host header .controls .spacer {
  display: none;
  min-width: var(--vi-query-grid-row-height);
  height: var(--vi-query-grid-row-height);
}
:host header .controls .reorder {
  grid-area: reorder;
}
:host header .controls .spacer {
  grid-area: spacer;
}
:host header .controls vi-query-grid-grouping {
  grid-area: grouping;
}
:host header .controls vi-query-grid-select-all {
  grid-area: select;
}
:host header .controls vi-query-grid-filters {
  grid-area: filter;
  line-height: var(--vi-query-grid-row-height);
}
:host header .more {
  position: absolute;
  background-color: rgba(255, 255, 255, 0.75);
  z-index: 1;
}
:host header .more > vi-button {
  width: var(--theme-h2);
  height: var(--theme-h2);
}
:host header .more.left {
  left: 0;
}
:host header .more.right {
  right: 0;
}
:host .physical-upper-limit-exceeded {
  display: flex;
  height: var(--vi-query-grid-row-height);
  line-height: var(--vi-query-grid-row-height);
  padding-left: calc(var(--vi-query-grid-controls-width, 0) + var(--theme-h5));
}
:host footer {
  padding-left: var(--vi-query-grid-controls-width, 0);
}
:host footer vi-query-grid-footer {
  margin-left: calc(var(--vi-query-grid-horizontal, 0) * -1);
}
:host vi-spinner[hidden] {
  display: none !important;
}
:host(:not([can-filter])) vi-query-grid-column-header::part(filter) {
  display: none;
}
:host(:not([can-select])) vi-query-grid-row::part(selector) {
  display: none;
}
:host(:not([inline-actions])) vi-query-grid-row::part(actions) {
  display: none;
}
:host(:not([can-select]):not([can-filter]):not([inline-actions])) .controls {
  grid-template-areas: none;
}
:host(:not([can-select]):not([can-filter]):not([inline-actions])) vi-query-grid-row {
  grid-template-columns: var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select]):not([can-filter]):not([inline-actions])[has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(1, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select]):not([can-filter]):not([inline-actions])[can-reorder]) .controls {
  grid-template-areas: "reorder";
}
:host(:not([can-select]):not([can-filter]):not([inline-actions])[can-reorder]) .controls .reorder {
  display: block;
}
:host(:not([can-select]):not([can-filter]):not([inline-actions])[can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(1, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select]:not([can-filter]):not([inline-actions])) .controls {
  grid-template-areas: "select";
}
:host([can-select]:not([can-filter]):not([inline-actions])) vi-query-grid-row {
  grid-template-columns: auto var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select]:not([can-filter]):not([inline-actions])[has-grouping]) .controls {
  grid-template-areas: "grouping select";
}
:host([can-select]:not([can-filter]):not([inline-actions])[has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select]:not([can-filter]):not([inline-actions])[can-reorder]) .controls {
  grid-template-areas: "reorder select";
}
:host([can-select]:not([can-filter]):not([inline-actions])[can-reorder]) .controls .reorder {
  display: block;
}
:host([can-select]:not([can-filter]):not([inline-actions])[can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(1, var(--vi-query-grid-row-height)) auto var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select])[can-filter]:not([inline-actions])) .controls {
  grid-template-areas: "spacer" "filter";
}
:host(:not([can-select])[can-filter]:not([inline-actions])) .controls .spacer {
  display: block;
  border-bottom: 1px solid var(--theme-light-border);
}
:host(:not([can-select])[can-filter]:not([inline-actions])) vi-query-grid-row {
  grid-template-columns: repeat(1, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select])[can-filter]:not([inline-actions])) vi-query-grid-row::part(actions) {
  display: none;
}
:host(:not([can-select])[can-filter]:not([inline-actions])) vi-query-grid-row::part(filter) {
  display: block;
}
:host(:not([can-select])[can-filter]:not([inline-actions])[has-grouping]) .controls {
  grid-template-areas: "spacer spacer" "grouping filter";
}
:host(:not([can-select])[can-filter]:not([inline-actions])[has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select])[can-filter]:not([inline-actions])[can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(1, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select])[can-filter]:not([inline-actions])[can-reorder]) vi-query-grid-row::part(filter) {
  display: none;
}
:host(:not([can-select]):not([can-filter])[inline-actions]) .controls {
  grid-template-areas: "spacer";
}
:host(:not([can-select]):not([can-filter])[inline-actions]) .controls .spacer {
  display: block;
}
:host(:not([can-select]):not([can-filter])[inline-actions]) vi-query-grid-row {
  grid-template-columns: repeat(1, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select]):not([can-filter])[inline-actions][has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host(:not([can-select]):not([can-filter])[inline-actions][has-grouping]) .controls {
  grid-template-areas: "grouping spacer";
}
:host(:not([can-select]):not([can-filter])[inline-actions][can-reorder]) .controls {
  grid-template-areas: "reorder spacer";
}
:host(:not([can-select]):not([can-filter])[inline-actions][can-reorder]) .controls .reorder {
  display: block;
}
:host(:not([can-select]):not([can-filter])[inline-actions][can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter]:not([inline-actions])) .controls {
  grid-template-areas: "spacer spacer" "select filter";
}
:host([can-select][can-filter]:not([inline-actions])) .controls .spacer {
  display: block;
  border-bottom: 1px solid var(--theme-light-border);
}
:host([can-select][can-filter]:not([inline-actions])) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter]:not([inline-actions])) vi-query-grid-row::part(filter) {
  display: block;
}
:host([can-select][can-filter]:not([inline-actions])[has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(3, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter]:not([inline-actions])[has-grouping]) .controls {
  grid-template-areas: "spacer spacer spacer" "grouping select filter";
}
:host([can-select][can-filter]:not([inline-actions])[can-reorder]) .controls {
  grid-template-areas: "spacer spacer spacer" "reorder select filter";
}
:host([can-select][can-filter]:not([inline-actions])[can-reorder]) .controls .reorder {
  display: block;
}
:host([can-select][can-filter]:not([inline-actions])[can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter]:not([inline-actions])[can-reorder]) vi-query-grid-row::part(filter) {
  display: none;
}
:host([can-select]:not([can-filter])[inline-actions]) .controls {
  grid-template-areas: "select spacer";
}
:host([can-select]:not([can-filter])[inline-actions]) .controls .spacer {
  display: block;
}
:host([can-select]:not([can-filter])[inline-actions]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select]:not([can-filter])[inline-actions][has-grouping]) .controls {
  grid-template-areas: "grouping select spacer";
}
:host([can-select]:not([can-filter])[inline-actions][has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(3, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select]:not([can-filter])[inline-actions][can-reorder]) .controls {
  grid-template-areas: "reorder select spacer";
}
:host([can-select]:not([can-filter])[inline-actions][can-reorder]) .controls .reorder {
  display: block;
}
:host([can-select]:not([can-filter])[inline-actions][can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(3, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter][inline-actions]) .controls {
  grid-template-areas: "spacer spacer" "select filter";
}
:host([can-select][can-filter][inline-actions]) .controls .spacer {
  display: block;
  border-bottom: 1px solid var(--theme-light-border);
}
:host([can-select][can-filter][inline-actions]) vi-query-grid-row {
  grid-template-columns: repeat(2, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter][inline-actions][has-grouping]) .controls {
  grid-template-areas: "spacer spacer spacer" "grouping select filter";
}
:host([can-select][can-filter][inline-actions][has-grouping]) vi-query-grid-row {
  grid-template-columns: repeat(3, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}
:host([can-select][can-filter][inline-actions][can-reorder]) .controls {
  grid-template-areas: "spacer spacer spacer" "reorder select filter";
}
:host([can-select][can-filter][inline-actions][can-reorder]) .controls .reorder {
  display: block;
}
:host([can-select][can-filter][inline-actions][can-reorder]) vi-query-grid-row {
  grid-template-columns: repeat(3, var(--vi-query-grid-row-height)) var(--vi-query-grid-columns-no-data, var(--vi-query-grid-columns));
}</style>

<header>
    <div class="controls">
        <dom-if if="[[canReorder]]">
            <template>
                <div class="reorder"></div>
            </template>
        </dom-if>
        <dom-if if="[[hasGrouping]]">
            <template>
                <vi-query-grid-grouping query="[[query]]" on-scroll-top="_scrollToTop"></vi-query-grid-grouping>
            </template>
        </dom-if>
        <dom-if if="[[canSelect]]">
            <template>
                <vi-query-grid-select-all query="[[query]]"></vi-query-grid-select-all>
            </template>
        </dom-if>
        <dom-if if="[[canFilter]]">
            <template>
                <vi-query-grid-filters query="[[query]]"></vi-query-grid-filters>
            </template>
        </dom-if>
        <div class="spacer"></div>
    </div>
    <div class="relative layout horizontal flex">
        <div class="relative flex" grid>
            <dom-repeat items="[[columns]]" as="column" id="columnHeadersDomRepeat">
                <template>
                    <vi-query-grid-column-header column="[[column]]"></vi-query-grid-column-header>
                </template>
            </dom-repeat>
            <vi-size-tracker size="{{visibleColumnHeaderSize}}"></vi-size-tracker>
        </div>
        <dom-if if="[[moreColumns.left.length]]">
            <template>
                <vi-popup class="more left" on-popup-opening="_onMoreOpening" on-popup-closed="_onMoreClosed">
                    <vi-button slot="header" inverse icon="ChevronLeft"></vi-button>
                    <vi-scroller no-horizontal></vi-scroller>
                </vi-popup>
            </template>
        </dom-if>
    </div>
    <dom-if if="[[moreColumns.right.length]]">
        <template>
            <vi-popup class="more right" on-popup-opening="_onMoreOpening" on-popup-closed="_onMoreClosed" placement="bottom-end">
                <vi-button slot="header" inverse icon="ChevronRight"></vi-button>
                <vi-scroller no-horizontal></vi-scroller>
            </vi-popup>
        </template>
    </dom-if>
</header>

<vi-scroller horizontal-scroll-offset="{{horizontalScrollOffset}}" vertical-scroll-offset="{{verticalScrollOffset}}" outer-height="{{viewportHeight}}" outer-width="{{viewportWidth}}">
    <div id="gridWrapper">
        <vi-query-grid-sortable id="grid" grid$="[[initializing]]" enabled="[[canReorder]]" handle=".reorder">
            <dom-repeat items="[[virtualItems]]" id="itemsDomRepeat">
                <template>
                    <vi-query-grid-row item="[[item]]" index="[[index]]" columns="[[columns]]" offsets="[[_computeOffsets(columnWidths)]]" visible-range="{{_computeVisibleRange(viewportWidth, horizontalScrollOffset)}}" initializing$="[[initializing]]" can-reorder="[[canReorder]]"></vi-query-grid-row>
                </template>
            </dom-repeat>
            <dom-if if="[[physicalUpperLimitExceeded]]">
                <template>
                    <div class="physical-upper-limit-exceeded">
                        <vi-icon source="Ellipsis"></vi-icon>
                    </div>
                </template>
            </dom-if>
        </vi-query-grid-sortable>
    </div>
</vi-scroller>

<dom-if if="[[query.totalItem]]">
    <template>
        <footer>
            <vi-query-grid-footer item="[[query.totalItem]]" columns="[[columns]]"></vi-query-grid-footer>
        </footer>
    </template>
</dom-if>

<vi-spinner hidden$="[[!query.isBusy]]"></vi-spinner>`; }
    connectedCallback() {
        super.connectedCallback();
        this._controlsSizeObserver = new ResizeObserver(this._controlsSizeChanged.bind(this));
        this._controlsSizeObserver.observe(this.shadowRoot.querySelector(".controls"));
    }
    disconnectedCallback() {
        this._controlsSizeObserver.disconnect();
        super.disconnectedCallback();
    }
    ready() {
        super.ready();
        requestAnimationFrame(() => this.rowHeight = parseInt(window.getComputedStyle(this).getPropertyValue("--vi-query-grid-row-height")));
    }
    _onAppRouteDeactivate(sender, message, detail) {
        if (!this.findParent(e => e === sender))
            return;
        queryScrollOffsets.set(this.query, {
            vertical: this.verticalScrollOffset,
            horizontal: this.horizontalScrollOffset
        });
    }
    _onInitializingChanged(initializing, oldInitializing) {
        if (initializing)
            return;
        const offset = queryScrollOffsets.get(this.query);
        if (offset !== undefined) {
            animationFrame.run(() => {
                this.verticalScrollOffset = offset.vertical;
                this.horizontalScrollOffset = offset.horizontal;
                queryScrollOffsets.delete(this.query);
            });
        }
    }
    _queryChanged(query, oldQuery) {
        if (oldQuery)
            this._setInitializing(true);
    }
    _controlsSizeChanged(entries) {
        let width = entries[0]["borderBoxSize"] != null ? entries[0]["borderBoxSize"][0].inlineSize : entries[0].target.offsetWidth;
        this.style.setProperty("--vi-query-grid-controls-width", `${width}px`);
    }
    _columnWidthChanged(e) {
        e.stopPropagation();
        const detail = e.detail;
        detail.entries.forEach(([column, width]) => {
            let columnWidthDetail = this._columnWidths.get(column);
            if (!columnWidthDetail)
                this._columnWidths.set(column, columnWidthDetail = {});
            columnWidthDetail[detail.type] = width;
            if (detail.type !== "current")
                columnWidthDetail.current = Math.max(columnWidthDetail.cell, columnWidthDetail.column) || Number.NaN;
        });
        if (this._columnWidths.size < this.columns.length)
            return;
        Array.from(this._columnWidths).filter(cw => !this.columns.find(c => c.name === cw[0])).forEach(c => this._columnWidths.delete(c[0]));
        const widths = Array.from(this._columnWidths.values());
        if (widths.some(w => Number.isNaN(w.current))) {
            if (this.query.items.length || this.query.isBusy)
                return;
            this._columnWidths.forEach(cw => cw.current = cw.column);
        }
        this.style.setProperty("--vi-query-grid-columns", `${this.columns.map(c => `${Math.ceil(this._columnWidths.get(c.name).current)}px`).join(" ")} minmax(0, 1fr)`);
        if (widths.every(w => w.cell >= 0))
            this.style.removeProperty("--vi-query-grid-columns-no-data");
        this._setInitializing(false);
        if (detail.save)
            this.userSettings.save(false);
    }
    _scrollToTop() {
        this.verticalScrollOffset = 0;
    }
    _update(verticalScrollOffset, virtualRowCount, rowHeight, items, skip, maxRows) {
        if (!virtualRowCount)
            return;
        verticalScrollOffset *= this._verticalSpacerCorrection;
        const viewportStartRowIndex = Math.floor(verticalScrollOffset / rowHeight);
        const viewportEndRowIndex = Math.ceil((verticalScrollOffset + this.viewportHeight) / rowHeight);
        if (!this.virtualItems || this.virtualItems.length !== virtualRowCount) {
            this._setVirtualItems(new Array(Math.min(virtualRowCount, maxRows || Number.MAX_SAFE_INTEGER)));
            items.forceUpdate = true;
        }
        let newVirtualGridStartIndex = 0;
        if (viewportEndRowIndex - this._virtualGridStartIndex > virtualRowCount)
            newVirtualGridStartIndex = viewportStartRowIndex;
        else if (viewportStartRowIndex < this._virtualGridStartIndex)
            newVirtualGridStartIndex = viewportEndRowIndex - virtualRowCount;
        else if (this.virtualItems.some(item => item === placeholder))
            newVirtualGridStartIndex = this._virtualGridStartIndex;
        else if (items.forceUpdate) {
            items.forceUpdate = false;
            newVirtualGridStartIndex = this._virtualGridStartIndex;
        }
        else
            return;
        if (newVirtualGridStartIndex % 2 !== 0 && this._verticalSpacerCorrection === 1)
            newVirtualGridStartIndex--;
        if (newVirtualGridStartIndex < 0)
            newVirtualGridStartIndex = 0;
        const queuedItemIndexes = [];
        for (let virtualIndex = 0; virtualIndex < this.virtualRowCount && (!maxRows || virtualIndex < maxRows); virtualIndex++) {
            const index = newVirtualGridStartIndex + virtualIndex + skip;
            const [item, realIndex] = this._getItem(index, true);
            this.virtualItems[virtualIndex] = item;
            if (this.virtualItems[virtualIndex] === undefined) {
                if (realIndex < this.query.totalItems || this.query.hasMore) {
                    placeholder.query = this.query;
                    this.virtualItems[virtualIndex] = placeholder;
                    queuedItemIndexes.push(realIndex);
                }
                else
                    this.virtualItems[virtualIndex] = null;
            }
        }
        this._updateCellDebouncer = Debouncer.debounce(this._updateCellDebouncer, animationFrame, () => {
            this._virtualGridStartIndex = newVirtualGridStartIndex;
            this.splice("virtualItems", 0, this.virtualRowCount, ...this.virtualItems);
            this.$.grid.style.transform = `translateY(${newVirtualGridStartIndex * rowHeight}px)`;
        });
        this._getItemsDebouncer = Debouncer.debounce(this._getItemsDebouncer, timeOut.after(20), () => {
            if (this._virtualGridStartIndex !== newVirtualGridStartIndex)
                return;
            queuedItemIndexes.forEach(index => this.query.items[index]);
        });
        if (this.initializing && this.query.isBusy) {
            this.query.queueWork(async () => {
                if (this.initializing && !this.query.items.length)
                    this._setInitializing(false);
            });
        }
    }
    _computeItems() {
        if (!this.query) {
            return {
                length: 0,
                groups: [],
                forceUpdate: true
            };
        }
        let length;
        let groups;
        this._setHasGrouping(!!this.query.groupingInfo && !!this.query.groupingInfo.groups);
        if (!this.hasGrouping)
            length = this.query.totalItems || 0;
        else {
            groups = [];
            length = this.query.groupingInfo.groups.reduce((n, g) => {
                groups[n] = g;
                return n + (g.isCollapsed ? 1 : 1 + g.count);
            }, 0);
            groups[length] = null;
        }
        return {
            length: length,
            groups: groups,
            forceUpdate: true
        };
    }
    _getItem(index, disableLazyLoading) {
        const queryLazyLoading = this.query.disableLazyLoading;
        try {
            this.query.disableLazyLoading = disableLazyLoading;
            if (!this.query.hasMore && index >= Math.min(this.items.length, PHYSICAL_UPPER_LIMIT))
                return [null, -1];
            if (!this.hasGrouping)
                return [this.query.items[index], index];
            let diff = 0;
            let result;
            this.items.groups.some((g, nn) => {
                if (nn < index) {
                    diff++;
                    if (g.isCollapsed)
                        diff -= g.count;
                    return false;
                }
                else if (nn === index) {
                    result = g;
                    return true;
                }
                index -= diff;
                result = this.query.items[index];
                return true;
            });
            return [result, index];
        }
        finally {
            this.query.disableLazyLoading = queryLazyLoading;
        }
    }
    _updateVerticalSpacer(viewportHeight, rowHeight, items, maxRows) {
        beforeNextRender(this, () => {
            const newHeight = Math.min(Math.min(items.length, PHYSICAL_UPPER_LIMIT), maxRows || Number.MAX_SAFE_INTEGER) * rowHeight;
            if (!maxRows)
                this.$.gridWrapper.style.height = `${newHeight}px`;
            else
                this.$.gridWrapper.style.maxHeight = `${newHeight}px`;
            this._verticalSpacerCorrection = (newHeight - this.viewportHeight) / (this.$.gridWrapper.clientHeight - viewportHeight);
        });
    }
    _updatePinnedColumns() {
        const pinnedColumns = this.columns.filter(c => c.isPinned);
        this._setPinnedColumns(pinnedColumns);
        if (!pinnedColumns.length) {
            if (this._pinnedStyle != null) {
                this.shadowRoot.removeChild(this._pinnedStyle);
                this._pinnedStyle = null;
            }
            return;
        }
        if (this._pinnedStyle == null)
            this.shadowRoot.appendChild(this._pinnedStyle = document.createElement("style"));
        this._pinnedStyle.innerHTML = `
            header [grid] > *:nth-child(-n+${pinnedColumns.length}), vi-query-grid-row > .column:nth-child(-n+${pinnedColumns.length}) {
                transform: translateX(var(--vi-query-grid-horizontal, 0));
            }

            header [grid] > *:nth-child(-n+${pinnedColumns.length}) {
                z-index: 1;
            }

            vi-query-grid-row > .column:nth-child(${pinnedColumns.length}) {
                border-right: 1px solid var(--theme-light-border);
            }
        `;
    }
    _updateUserSettings(query) {
        this._setUserSettings(query ? QueryGridUserSettings.Load(query) : null);
    }
    _computeColumns(columns) {
        columns = columns.filter(c => !c.isHidden);
        if (this.columns) {
            const signature = (columns) => columns.orderBy(c => c.name).map(c => c.name).join(";");
            if (signature(columns) !== signature(this.columns.filter(c => !c.isHidden)))
                this._setInitializing(true);
        }
        if (this.initializing) {
            const init = columns.map(c => c.width || "max-content").join(" ");
            this.style.setProperty("--vi-query-grid-columns-no-data", init);
            this.style.setProperty("--vi-query-grid-columns", init);
        }
        return [...columns.filter(c => c.isPinned), ...columns.filter(c => !c.isPinned)];
    }
    _computeVirtualRowCount(viewportHeight, rowHeight, canReorder, totalItems) {
        if (!viewportHeight)
            return 0;
        if (canReorder && totalItems > 0)
            return totalItems;
        return Math.ceil(Math.max(Math.ceil(viewportHeight / rowHeight) * 1.5, this.virtualRowCount || 0));
    }
    _computeOffsets(columnWidths) {
        let offset = 0;
        return columnWidths.map(width => {
            return [offset, offset += width];
        });
    }
    _computeVisibleRange(viewportWidth, horizontalScrollOffset) {
        return [horizontalScrollOffset, viewportWidth + horizontalScrollOffset];
    }
    _computeCanSelect(query, noSelection, asLookup) {
        return !noSelection && !!query && (asLookup || query.actions.some(a => a.isVisible && a.definition.selectionRule !== ExpressionParser.alwaysTrue));
    }
    _computeInlineActions(query, noInlineActions) {
        return !noInlineActions && !!query && !query.asLookup && !this.asLookup && (query.actions.some(a => a.isVisible && a.definition.selectionRule !== ExpressionParser.alwaysTrue && a.definition.selectionRule(1)));
    }
    _computeCanReorder(canReorder, hasGrouping) {
        return canReorder && !hasGrouping;
    }
    _computePhysicalUpperLimitExceeded(totalItems) {
        return totalItems > PHYSICAL_UPPER_LIMIT;
    }
    _computeHasMoreRows(totalItems, maxRows) {
        return !!maxRows && totalItems > maxRows;
    }
    _rowHeightChanged(rowHeight) {
        this.style.setProperty("--vi-query-grid-row-height", `${rowHeight}px`);
    }
    _updateHorizontalScrollOffset(horizontalScrollOffset) {
        this.style.setProperty("--vi-query-grid-horizontal", `${horizontalScrollOffset}px`);
        Popup.closeAll();
    }
    _onVerticalScrollOffsetChanged() {
        Popup.closeAll();
    }
    _itemSelect(e) {
        const detail = e.detail;
        const indexOfItem = this.query.items.indexOf(detail.item);
        if (!detail.item.isSelected && this._lastSelectedItemIndex >= 0 && detail.shift) {
            if (this.query.selectRange(Math.min(this._lastSelectedItemIndex, indexOfItem), Math.max(this._lastSelectedItemIndex, indexOfItem))) {
                this._lastSelectedItemIndex = indexOfItem;
                return;
            }
        }
        if (!detail.ctrl) {
            if (this.query.selectAll.isAvailable && this.query.selectAll)
                this.query.selectAll.allSelected = this.query.selectAll.inverse = false;
            this.query.selectedItems = this.query.selectedItems.length > 1 || !detail.item.isSelected ? [detail.item] : [];
        }
        else
            detail.item.isSelected = !detail.item.isSelected;
        if (detail.item.isSelected)
            this._lastSelectedItemIndex = indexOfItem;
    }
    async _onReorderStart(e) {
        this.__rowsBeforeDragEnd = Array.from(this.$.grid.querySelectorAll("vi-query-grid-row"));
    }
    async _onReorderEnd(e) {
        const details = e.detail;
        if (details.newIndex == null)
            return;
        try {
            await this.query.reorder(details.element.previousElementSibling?.item ?? null, details.element.item, details.element.nextElementSibling?.item ?? null);
        }
        finally {
            this.__rowsBeforeDragEnd.forEach(row => this.$.grid.appendChild(row));
        }
    }
    async _onColumnUpdate() {
        await this.userSettings.save();
        this._reset();
    }
    async _onConfigure() {
        if (await this.app.showDialog(new QueryGridConfigureDialog(this.query, this.userSettings)))
            this._onColumnUpdate();
    }
    _reset() {
        this._updateUserSettings(this.query);
        this._update(this.verticalScrollOffset, this.virtualRowCount, this.rowHeight, this.items, this.skip);
    }
    _updateMore(visibleColumnHeaderSize, horizontalScrollOffset) {
        if (visibleColumnHeaderSize == null || horizontalScrollOffset == null)
            return;
        this._updateMoreDebouncer = Debouncer.debounce(this._updateMoreDebouncer, timeOut.after(50), () => {
            const sizeTracker = this.$.columnHeadersDomRepeat;
            const headers = Array.from(sizeTracker.parentElement.querySelectorAll("vi-query-grid-column-header"));
            this._setMoreColumns({
                left: headers.filter(h => h.offsetLeft - horizontalScrollOffset < 0),
                right: headers.filter(h => (h.offsetLeft + h.offsetWidth / 2) > visibleColumnHeaderSize.width)
            });
        });
    }
    _onMoreOpening(e) {
        const popup = e.target;
        const isLeft = popup.classList.contains("left");
        const headers = isLeft ? this.moreColumns.left : this.moreColumns.right;
        popup.querySelector("vi-scroller").append(...headers.map(h => {
            return new PopupMenuItem(h.column.label, null, () => {
                const pinnedColumns = this.columns.filter(c => c.isPinned);
                const pinnedOffset = pinnedColumns.length > 0 ? pinnedColumns.sum(c => this._columnWidths.get(c.name)?.current || 0) : 0;
                this.horizontalScrollOffset = h.offsetLeft - pinnedOffset;
            });
        }));
    }
    _onMoreClosed(e) {
        const popup = e.target;
        popup.querySelector("vi-scroller").innerHTML = "";
    }
};
QueryGrid = __decorate([
    WebComponent.register({
        properties: {
            initializing: {
                type: Boolean,
                readOnly: true,
                value: true,
                reflectToAttribute: true,
                observer: "_onInitializingChanged"
            },
            query: {
                type: Object,
                observer: "_queryChanged"
            },
            asLookup: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            items: {
                type: Array,
                computed: "_computeItems(query.lastUpdated)"
            },
            columns: {
                type: Array,
                computed: "_computeColumns(userSettings.columns)"
            },
            pinnedColumns: {
                type: Array,
                readOnly: true
            },
            horizontalScrollOffset: {
                type: Number,
                observer: "_updateHorizontalScrollOffset"
            },
            rowHeight: {
                type: Number,
                observer: "_rowHeightChanged"
            },
            userSettings: {
                type: Object,
                readOnly: true
            },
            verticalScrollOffset: {
                type: Number,
                observer: "_onVerticalScrollOffsetChanged"
            },
            viewportHeight: {
                type: Number,
                value: 0
            },
            viewportWidth: Number,
            virtualRowCount: {
                type: Number,
                computed: "_computeVirtualRowCount(viewportHeight, rowHeight, query.canReorder, query.totalItems)",
                value: 0
            },
            virtualItems: {
                type: Array,
                readOnly: true
            },
            hasGrouping: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            noSelection: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            canSelect: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeCanSelect(query, noSelection, asLookup)"
            },
            noInlineActions: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            inlineActions: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeInlineActions(query, noInlineActions)"
            },
            canFilter: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "query.canFilter"
            },
            canReorder: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeCanReorder(query.canReorder, hasGrouping)"
            },
            visibleColumnHeaderSize: Object,
            moreColumns: {
                type: Object,
                readOnly: true
            },
            physicalUpperLimitExceeded: {
                type: Boolean,
                computed: "_computePhysicalUpperLimitExceeded(query.items.length)"
            },
            maxRows: {
                type: Number,
                reflectToAttribute: true,
                value: null
            },
            hasMoreRows: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasMoreRows(query.items.length, maxRows)"
            },
            skip: {
                type: Number,
                reflectToAttribute: true,
                value: 0
            },
        },
        forwardObservers: [
            "query.canReorder",
            "query.columns",
            "query.isBusy",
            "query.lastUpdated",
            "query.items.*",
            "query.totalItem",
            "query.totalItems",
            "_updatePinnedColumns(columns.*.isPinned)"
        ],
        listeners: {
            "column-width-changed": "_columnWidthChanged",
            "item-select": "_itemSelect",
            "query-grid-column:configure": "_onConfigure",
            "query-grid-column:update": "_onColumnUpdate",
            "drag-start": "_onReorderStart",
            "drag-end": "_onReorderEnd"
        },
        observers: [
            "_scrollToTop(query.items)",
            "_update(verticalScrollOffset, virtualRowCount, rowHeight, items, skip, maxRows)",
            "_updateVerticalSpacer(viewportHeight, rowHeight, items, maxRows)",
            "_updateUserSettings(query, query.columns)",
            "_updateMore(visibleColumnHeaderSize, horizontalScrollOffset)"
        ],
        serviceBusObservers: {
            "app-route:deactivate": "_onAppRouteDeactivate"
        }
    })
], QueryGrid);
let QueryGridSortable = class QueryGridSortable extends Sortable {
    static get template() { return html$3 `<style>:host { display: block; }</style><slot></slot>`; }
};
QueryGridSortable = __decorate([
    WebComponent.register()
], QueryGridSortable);

let QueryItemsPresenter = class QueryItemsPresenter extends ConfigurableWebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
}
:host > * {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host(:focus) {
  outline: none !important;
}
:host ::slotted(*) {
  flex: 1;
  min-height: 0;
  min-width: 0;
}</style>

<dom-if if="[[fileDrop]]">
    <template>
        <vi-file-drop class="layout horizontal">
            <slot></slot>
        </vi-file-drop>
    </template>
</dom-if>
<dom-if if="[[!fileDrop]]">
    <template>
        <slot></slot>
    </template>
</dom-if>
<vi-spinner hidden$="[[!loading]]"></vi-spinner>`; }
    async _renderQuery(query, currentChart, isConnected) {
        if (!isConnected)
            return;
        this.empty();
        this._renderedQuery = null;
        if (!query) {
            this._setFileDrop(false);
            this._setTemplated(false);
            return;
        }
        this._setLoading(true);
        const config = this.app.configuration.getQueryConfig(query);
        this._setFileDrop(!!config && !!config.fileDropAttribute && !!query.actions[config.fileDropAction]);
        this._setTemplated(!!config && config.hasTemplate);
        if (this.templated) {
            if (this._renderedQuery !== query) {
                this.appendChild(config.stamp(query, config.as || "query"));
                this._renderedQuery = query;
            }
        }
        else {
            if (!currentChart) {
                if (query !== this.query || this._renderedQuery === query || !!query.currentChart)
                    return;
                const grid = new QueryGrid();
                this._renderedQuery = grid.query = this.query;
                this.appendChild(grid);
            }
            else {
                const chartConfig = this.app.configuration.getQueryChartConfig(currentChart.type);
                if (!chartConfig) {
                    console.error(`No chart configuration found for type '${currentChart.type}'`);
                    return;
                }
                if (query !== this.query || this._renderedQuery === query)
                    return;
                this._renderedQuery = query;
                this.appendChild(chartConfig.stamp(currentChart, chartConfig.as || "chart"));
            }
        }
        this._setLoading(false);
    }
    async _onFileDropped(e) {
        if (!this.fileDrop)
            return;
        const details = e.detail;
        for (let detail of details) {
            await this.query.service.hooks.onQueryFileDrop(this.query, detail.name, detail.contents);
        }
    }
    _refresh() {
        if (this.query)
            this.query.search();
    }
    _new() {
        if (!this.query)
            return;
        const action = this.query.actions["New"];
        if (action)
            action.execute();
    }
    _delete() {
        if (!this.query || !this.query.selectedItems || this.query.selectedItems.length === 0)
            return true;
        const action = this.query.actions["Delete"];
        if (action)
            action.execute();
    }
    _bulkEdit() {
        if (!this.query)
            return;
        const action = this.query.actions["BulkEdit"];
        if (action)
            action.execute();
    }
    _configure(e) {
        if (this.query.isSystem)
            return;
        e.detail.push({
            label: `Query: ${this.query.label}`,
            icon: "viConfigure",
            action: () => {
                this.app.changePath(`Management/PersistentObject.b9d2604d-2233-4df2-887a-709d93502843/${this.query.id}`);
            },
            subActions: [{
                    label: `Persistent Object: ${this.query.persistentObject.type}`,
                    icon: "viConfigure",
                    action: () => {
                        this.app.changePath(`Management/PersistentObject.316b2486-df38-43e3-bee2-2f7059334992/${this.query.persistentObject.id}`);
                    }
                }]
        });
    }
};
QueryItemsPresenter = __decorate([
    ConfigurableWebComponent.register({
        properties: {
            query: Object,
            loading: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                value: true
            },
            templated: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            fileDrop: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            }
        },
        keybindings: {
            "f5 ctrl+r": "_refresh",
            "ctrl+n": "_new",
            "delete": "_delete",
            "f2": "_bulkEdit"
        },
        observers: [
            "_renderQuery(query, query.currentChart, isConnected)"
        ],
        forwardObservers: [
            "query.currentChart"
        ],
        listeners: {
            "file-dropped": "_onFileDropped",
            "vi:configure": "_configure"
        }
    })
], QueryItemsPresenter);

let PersistentObjectAttributeValidationError = class PersistentObjectAttributeValidationError extends WebComponent {
    static get template() { return html$3 `<style>:host {
  width: var(--theme-h2);
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  padding: 0;
  background-color: transparent;
  cursor: pointer;
}
:host vi-icon {
  width: var(--theme-h2);
  height: var(--theme-h2);
  --vi-icon-width: var(--theme-h3);
  --vi-icon-height: var(--theme-h3);
  fill: var(--theme-color-error);
}
:host pre {
  padding: var(--theme-h5);
  border: 1px solid var(--theme-color-error);
}
:host #content.top {
  transform: translateY(var(--theme-h4));
}
:host #content.bottom {
  transform: translateY(calc(var(--theme-h4) * -1));
}</style>

<vi-popup open-on-hover placement="bottom">
    <vi-icon slot="header" source="Notification_Error"></vi-icon>
    <pre>[[attribute.validationError]]</pre>
</vi-popup>`; }
    _computeHidden(validationError, isReadOnly) {
        return !validationError || isReadOnly;
    }
    _showError(e) {
        e.stopPropagation();
        this.app.showMessageDialog({
            title: this.app.translateMessage("Error"),
            titleIcon: "Notification_Error",
            actions: [this.translations.OK],
            message: this.attribute.validationError
        });
    }
};
PersistentObjectAttributeValidationError = __decorate([
    WebComponent.register({
        properties: {
            attribute: Object,
            hidden: {
                type: Boolean,
                computed: "_computeHidden(attribute.validationError, attribute.isReadOnly)",
                reflectToAttribute: true,
                value: true
            }
        },
        listeners: {
            "tap": "_showError"
        },
        forwardObservers: [
            "attribute.validationError",
            "attribute.isReadOnly"
        ]
    })
], PersistentObjectAttributeValidationError);

let PersistentObjectAttributeEdit = class PersistentObjectAttributeEdit extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  flex: 1;
  min-height: 0;
  min-width: 0;
  line-height: var(--theme-h2);
}
:host .box {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  flex: 1;
  min-height: 0;
  min-width: 0;
  position: relative;
  background-color: white;
  line-height: calc(var(--theme-h2) - 2px);
  border: 1px solid var(--theme-light-border);
  box-sizing: border-box;
}
:host([read-only]) .box {
  background-color: var(--theme-read-only);
}
:host([read-only]) .box .buttons {
  background-color: transparent;
}
:host([has-error]) .box {
  border-color: var(--theme-color-error) !important;
  overflow: hidden;
}
:host([has-error]) .box::before {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  content: " ";
  opacity: 0.05;
  background-color: var(--theme-color-error);
  pointer-events: none;
}
:host .box[disabled] {
  background-color: #eee;
  cursor: default;
  pointer-events: none;
}
:host .box[disabled] .extras {
  background-color: #eee;
}
:host .box[disabled] ::slotted(*) {
  opacity: 0.5;
}
:host .box[disabled] ::slotted(*)::before {
  border-left-color: var(--theme-light-border);
}
:host .box > ::slotted(*) {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host .box .extras {
  position: relative;
  background-color: white;
}
:host .box .extras ::slotted(*), :host .box .extras .action {
  position: relative;
  outline: none;
  cursor: pointer;
  width: calc(var(--theme-h2) - 2px);
  height: calc(var(--theme-h2) - 2px);
  line-height: calc(var(--theme-h2) - 2px);
  padding: 0;
  box-sizing: content-box;
  text-align: center;
  background-color: transparent;
  color: var(--color);
  fill: #595959;
  -moz-transition-property: fill, color, background-color;
  -o-transition-property: fill, color, background-color;
  -webkit-transition-property: fill, color, background-color;
  transition-property: fill, color, background-color;
  -moz-transition-duration: 0.1s;
  -o-transition-duration: 0.1s;
  -webkit-transition-duration: 0.1s;
  transition-duration: 0.1s;
  -moz-transition-timing-function: ease-out;
  -o-transition-timing-function: ease-out;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
  transition: background-color 0.1s ease-out;
}
:host .box .extras ::slotted(*):hover, :host .box .extras .action:hover {
  background-color: var(--color-faint);
}
:host .box .extras ::slotted(*):active, :host .box .extras .action:active {
  background-color: var(--color-dark);
  fill: white !important;
  color: white !important;
}
:host .box .extras ::slotted(*)[disabled], :host .box .extras .action[disabled] {
  fill: var(--color-faint);
  color: fadeout(black, 50%);
}
:host .box .extras ::slotted(*)::after, :host .box .extras .action::after {
  position: absolute;
  bottom: -1px;
  left: 3px;
  right: 4px;
  content: " ";
  border-bottom: 1px solid var(--theme-light-border);
  transition: all 0.1s ease-in-out;
}
:host .box .extras ::slotted(*)::before, :host .box .extras .action::before {
  position: absolute;
  top: 4px;
  bottom: 4px;
  content: " ";
  transition: all 0.1s ease-in-out;
}
:host .box .extras ::slotted(*) vi-icon, :host .box .extras .action vi-icon {
  width: calc(var(--theme-h2) - 2px);
  height: calc(var(--theme-h2) - 2px);
}
:host .box .extras ::slotted(*:hover), :host .box .extras .action:hover {
  background-color: var(--color-faint);
}
:host .box .extras ::slotted(*:active), :host .box .extras .action:active {
  background-color: var(--color-dark) !important;
  --vi-icon-fill: white;
}
:host .box .extras:hover ::slotted(*)::after, :host .box .extras:hover .action::after {
  left: 0;
  right: 0;
}
:host .box .extras:hover ::slotted(*)::before, :host .box .extras:hover .action::before {
  top: 0;
  bottom: 0;
}
:host .box .extras.left ::slotted(*)::before, :host .box .extras.left .action::before {
  right: 0;
  border-right: 1px solid var(--theme-light-border);
}
:host .box .extras.right ::slotted(*)::before, :host .box .extras.right .action::before {
  left: 0;
  border-left: 1px solid var(--theme-light-border);
}
:host .box .extras.left, :host .box .extras.right {
  display: flex;
  flex-direction: row;
}
:host .box .extras ::slotted(*::part(popup)) {
  background-color: yellowgreen;
}
:host .box .extras ::slotted(*)::part(icon) {
  background-color: yellow;
}
:host(:focus-within) .box {
  border-color: var(--color-lighter);
}
:host(:focus-within) .box .extras ::slotted(*), :host(:focus-within) .box .extras .action {
  --vi-icon-fill: var(--color);
}
:host(:focus-within) .box .extras ::slotted(*:hover), :host(:focus-within) .box .extras .action:hover {
  background-color: var(--color);
  --vi-icon-fill: white !important;
}
:host(:focus-within) .box .extras ::slotted(*)::after, :host(:focus-within) .box .extras ::slotted(*)::before, :host(:focus-within) .box .extras .action::after, :host(:focus-within) .box .extras .action::before {
  border-color: var(--color-lighter);
}</style>

<div class="box" disabled$="[[attribute.parent.isFrozen]]">
    <div class="left extras">
        <slot name="left"></slot>
    </div>
    <slot></slot>
    <div class="right extras">
        <dom-repeat items="[[attribute.actions]]" as="action">
            <template>
                <vi-button class="action" on-tap="_onActionTap" tabindex="-1">
                    <vi-icon source="[[_computeActionIcon(action)]]"></vi-icon>
                </vi-button>
            </template>
        </dom-repeat>
        <slot name="right"></slot>
    </div>
</div>

<dom-if if="[[hasValidationError]]">
    <template>
        <vi-persistent-object-attribute-validation-error attribute="[[attribute]]"></vi-persistent-object-attribute-validation-error>
    </template>
</dom-if>`; }
    _focus(e) {
        this._setFocus(true);
    }
    _blur(e) {
        this._setFocus(false);
    }
    _computeHasError(validationError) {
        return !!validationError;
    }
    _computeSensitive(isSensitive, isAppSensitive) {
        return isSensitive && isAppSensitive;
    }
    _computeHasValidationError(validationError, isReadOnly) {
        return validationError && !isReadOnly;
    }
    _computeActionIcon(action) {
        if (!action)
            return "";
        return !exists(action.definition.icon) ? "Action_Default$" : action.definition.icon;
    }
    _onActionTap(e) {
        const action = e.model.action;
        action?.execute({
            parameters: {
                "AttributeName": this.attribute.name
            }
        });
    }
};
PersistentObjectAttributeEdit = __decorate([
    WebComponent.register({
        properties: {
            attribute: Object,
            focus: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            hasError: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasError(attribute.validationError)"
            },
            reverse: {
                type: Boolean,
                reflectToAttribute: true
            },
            sensitive: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeSensitive(attribute.isSensitive, isAppSensitive)"
            },
            readOnly: {
                type: Boolean,
                computed: "attribute.isReadOnly",
                reflectToAttribute: true
            },
            hasValidationError: {
                type: Boolean,
                computed: "_computeHasValidationError(attribute.validationError, attribute.isReadOnly)"
            }
        },
        listeners: {
            "focusin": "_focus",
            "focusout": "_blur",
        },
        forwardObservers: [
            "attribute.actions",
            "attribute.isSensitive",
            "attribute.validationError",
            "attribute.parent.isFrozen",
            "attribute.isReadOnly",
            "attribute.validationError"
        ],
        sensitive: true
    })
], PersistentObjectAttributeEdit);

const styleElement = document.createElement("dom-module");
styleElement.innerHTML = `<template>
    <style include="vi-flex-layout-style-module"></style>
    <style>:host textarea {
  overflow: auto;
  resize: none;
  padding: var(--theme-h5);
  line-height: var(--theme-h3);
}
:host input, :host *::part(input) {
  padding: 0 var(--theme-h5);
  line-height: calc(var(--theme-h2) - 2px);
}
:host input, :host textarea, :host *::part(input) {
  background-color: transparent;
  box-sizing: border-box;
  margin: 0;
  border: none;
  outline: none;
  color: #333;
  width: 100%;
  font-family: inherit;
}</style>
</template>`;
styleElement.register("vi-persistent-object-attribute-style-module");
let PersistentObjectAttribute = class PersistentObjectAttribute extends WebComponent {
    focus() {
        (this.shadowRoot.querySelector("vi-persistent-object-attribute-edit input") ||
            this.shadowRoot.querySelector("vi-persistent-object-attribute-edit textarea") ||
            this.shadowRoot.querySelector("vi-persistent-object-attribute-edit vi-select"))?.focus();
    }
    _attributeValueChanged() {
        this.value = this.attribute.value !== undefined ? this.attribute.value : null;
    }
    _optionsChanged(options) {
    }
    _attributeChanged() {
    }
    _editingChanged() {
    }
    _valueChanged(newValue, oldValue) {
        if (this.attribute && newValue !== this.attribute.value)
            this.attribute.setValue(newValue, false).catch(noop$1);
    }
    _computeHasError(validationError) {
        return !String.isNullOrEmpty(validationError);
    }
    _computeEditing(isEditing, nonEdit) {
        return !nonEdit && isEditing;
    }
    _computeReadOnly(...flags) {
        return flags.some(f => f);
    }
    _computeReadOnlyTabIndex(readOnly) {
        return readOnly ? "-1" : null;
    }
    _computeSensitive(isSensitive, isAppSensitive, type) {
        return isSensitive && isAppSensitive && type !== "AsDetail";
    }
    _computePlaceholder(attribute) {
        return attribute ? this.attribute.getTypeHint("placeholder", "", void 0, true) : "";
    }
    _computeOptions(options, isRequired, type) {
        if (!options || options.length === 0 || isRequired || ["KeyValueList", "DropDown", "ComboBox"].indexOf(type) === -1)
            return options;
        if (typeof options[0] === "string" || options[0] == null) {
            if (options.some(o => o == null))
                return options;
            return [null].concat(options);
        }
        if (options.some(o => !o.key))
            return options;
        return [{ key: null, value: "" }].concat(options);
    }
    _updateForegroundDataTypeHint(attribute, isEditing, isReadOnly) {
        const foreground = this.attribute.getTypeHint("foreground", null, true);
        if ((!isEditing || isReadOnly) && foreground) {
            this.updateStyles({
                "--vi-persistent-object-attribute-foreground": this._foreground = foreground
            });
        }
        else if (this._foreground) {
            this.updateStyles({
                "--vi-persistent-object-attribute-foreground": this._foreground = null
            });
        }
    }
    _onFocus(e) {
        flush$1();
        if (this.shadowRoot.activeElement)
            return;
    }
    _gridAreaChanged(gridArea) {
        this.style.gridArea = gridArea;
    }
    static registerAttributeType(attributeType, constructor) {
        registeredAttributeTypes[attributeType] = constructor;
    }
    static getAttributeConstructor(attributeType) {
        return registeredAttributeTypes[attributeType];
    }
};
PersistentObjectAttribute = __decorate([
    WebComponent.registerAbstract({
        properties: {
            attribute: {
                type: Object,
                observer: "_attributeChanged"
            },
            editing: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeEditing(attribute.parent.isEditing, nonEdit)"
            },
            nonEdit: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            readOnly: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeReadOnly(attribute.isReadOnly, disabled, sensitive)"
            },
            readOnlyTabIndex: {
                type: String,
                reflectToAttribute: true,
                computed: "_computeReadOnlyTabIndex(readOnly)"
            },
            frozen: {
                type: Boolean,
                computed: "attribute.parent.isFrozen"
            },
            required: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "attribute.isRequired"
            },
            sensitive: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeSensitive(attribute.isSensitive, isAppSensitive, attribute.type)"
            },
            value: {
                type: Object,
                notify: true,
                observer: "_valueChanged"
            },
            placeholder: {
                type: String,
                computed: "_computePlaceholder(attribute)"
            },
            validationError: {
                type: Object,
                notify: true,
                computed: "attribute.validationError"
            },
            hasError: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasError(attribute.validationError)"
            },
            options: {
                type: Array,
                computed: "_computeOptions(attribute.options, attribute.isRequired, attribute.type)",
                observer: "_optionsChanged"
            },
            gridArea: {
                type: String,
                reflectToAttribute: true,
                observer: "_gridAreaChanged"
            }
        },
        forwardObservers: [
            "attribute.displayValue",
            "attribute.isRequired",
            "attribute.isReadOnly",
            "attribute.isSensitive",
            "attribute.options",
            "attribute.validationError",
            "attribute.parent.isFrozen",
            "_editingChanged(attribute.parent.isEditing)",
            "_attributeValueChanged(attribute.value)"
        ],
        observers: [
            "_updateForegroundDataTypeHint(attribute, editing, readOnly)"
        ],
        sensitive: true
    })
], PersistentObjectAttribute);
const registeredAttributeTypes = {};

let PersistentObjectAttributeAsDetailRow = class PersistentObjectAttributeAsDetailRow extends WebComponent {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: grid;
  grid-template-columns: var(--column-widths);
  white-space: nowrap;
  height: var(--theme-h2);
  line-height: var(--theme-h2);
}
:host .column {
  padding: 0 1px 1px 0;
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  box-sizing: border-box;
  min-width: 0;
}
:host .column:last-of-type {
  padding-right: 0;
}
:host .column > vi-persistent-object-attribute-presenter {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
}
:host .column > vi-persistent-object-attribute-presenter[soft-edit-only] {
  display: none !important;
}
:host .column > [pre-edit] {
  height: var(--theme-h2);
  line-height: calc(var(--theme-h2) - 2px);
}
:host .column > [pre-edit] .value-box {
  position: relative;
  border: 1px solid var(--theme-light-border);
  box-sizing: border-box;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 var(--theme-h5);
}
:host .column > [pre-edit] vi-persistent-object-attribute-validation-error:not([hidden]) + div {
  border-color: var(--theme-color-error) !important;
}
:host .column > [pre-edit] vi-persistent-object-attribute-validation-error:not([hidden]) + div::before {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  content: " ";
  opacity: 0.05;
  background-color: var(--theme-color-error);
  pointer-events: none;
}
:host .column span {
  padding: 0 var(--theme-h5);
  overflow: hidden;
  text-overflow: ellipsis;
}
:host(:not([full-edit]):not([read-only]):not([frozen])) {
  cursor: pointer;
}
:host([frozen]) [pre-edit] {
  background-color: #eee;
}
:host(:not([full-edit])[read-only]) .column {
  background-color: var(--theme-read-only);
}
:host .delete-button {
  width: var(--persistent-object-attribute-as-detail--delete-width);
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  box-sizing: border-box;
  border: 1px solid var(--theme-light-border);
  fill: var(--color-light);
  margin-left: 1px;
}
:host .delete-button:not(:hover):not(:active) {
  background-color: transparent;
}
:host .delete-button vi-icon {
  line-height: var(--theme-h2);
  height: var(--theme-h2);
}
:host .delete-button[disabled] {
  background-color: #eee !important;
}

:host-context(vi-persistent-object-attribute-as-detail:not([editing])) .column:not(:last-of-type) {
  border-right: 1px solid var(--theme-light-border);
}</style>

<dom-repeat items="[[columns]]" as="column" filter="_isColumnVisible">
    <template>
        <div class="column layout horizontal" data-column$="[[column.name]]">
            <dom-if if="[[editing]]">
                <template>
                    <dom-if if="[[op_some(fullEdit, softEdit)]]">
                        <template>
                            <vi-persistent-object-attribute-presenter class="flex" no-label attribute="[[_attributeForColumn(serviceObject, column)]]" soft-edit-only$="[[_isSoftEditOnly(fullEdit, softEdit)]]"></vi-persistent-object-attribute-presenter>
                        </template>
                    </dom-if>
                    <dom-if if="[[!fullEdit]]" restamp>
                        <template>
                            <div pre-edit on-tap="_setFullEdit" class="flex layout horizontal-reverse">
                                <vi-persistent-object-attribute-validation-error attribute="[[_attributeForColumn(serviceObject, column)]]"></vi-persistent-object-attribute-validation-error>
                                <vi-sensitive disabled="[[!sensitive]]">
                                    <div class="value-box flex">
                                        <span class="value">[[_displayValue(serviceObject, column, fullEdit, serviceObject.lastUpdated)]]</span>
                                    </div>
                                </vi-sensitive>
                            </div>
                        </template>
                    </dom-if>
                </template>
            </dom-if>
            <dom-if if="[[!editing]]">
                <template>
                    <vi-sensitive disabled="[[!sensitive]]">
                        <span class="flex">[[_displayValue(serviceObject, column, serviceObject.lastUpdated)]]</span>
                    </vi-sensitive>
                </template>
            </dom-if>
        </div>
    </template>
</dom-repeat>

<dom-if if="[[canDelete]]">
    <template>
        <vi-button class="delete-button" inverse on-tap="_delete" disabled="[[op_some(frozen, serviceObject.isReadOnly)]]">
            <vi-icon source="Action_Delete"></vi-icon>
        </vi-button>
    </template>
</dom-if>`; }
    _isColumnVisible(column) {
        return !column.isHidden && column.width !== "0";
    }
    _attributeForColumn(obj, column) {
        return obj.attributes[column.name];
    }
    _displayValue(obj, column) {
        const attr = this._attributeForColumn(obj, column);
        return attr && attr.displayValue || "";
    }
    _computeSoftEdit(serviceObject) {
        return serviceObject && serviceObject.ownerDetailAttribute.objects[0] === serviceObject;
    }
    _isSoftEditOnly(fullEdit, softEdit) {
        return !fullEdit && softEdit;
    }
    _computeIsSensitive(column, isAppSensitive) {
        return column.isSensitive && isAppSensitive;
    }
    _setFullEdit(e) {
        this.fire("full-edit", null);
        flush$1();
        const attribute = this._attributeForColumn(this.serviceObject, e.model.column);
        const presenters = Array.from(this.shadowRoot.querySelectorAll("vi-persistent-object-attribute-presenter"));
        const presenter = presenters.find(p => p.attribute === attribute);
        if (!presenter)
            return;
        presenter.queueFocus();
    }
    _delete() {
        if (this.serviceObject.isReadOnly)
            return;
        this.dispatchEvent(new CustomEvent("delete", { detail: this.serviceObject }));
    }
    _onAttributeLoading(e) {
        e.stopPropagation();
    }
    _onAttributeLoaded(e) {
        e.stopPropagation();
    }
};
PersistentObjectAttributeAsDetailRow = __decorate([
    WebComponent.register({
        properties: {
            serviceObject: Object,
            columns: Array,
            editing: Boolean,
            canDelete: Boolean,
            frozen: {
                type: Boolean,
                reflectToAttribute: true
            },
            fullEdit: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            softEdit: {
                type: Boolean,
                computed: "_computeSoftEdit(serviceObject)",
                value: false
            },
            isSensitive: {
                type: Boolean,
                computed: "_computeIsSensitive(column, isAppSensitive)"
            }
        },
        forwardObservers: [
            "serviceObject.lastUpdated"
        ],
        listeners: {
            "attribute-loading": "_onAttributeLoading",
            "attribute-loaded": "_onAttributeLoaded",
        },
        sensitive: true
    })
], PersistentObjectAttributeAsDetailRow);

var _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex;
let PersistentObjectAttributeAsDetail = class PersistentObjectAttributeAsDetail extends PersistentObjectAttribute {
    constructor() {
        super(...arguments);
        _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex.set(this, void 0);
    }
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
  overflow: hidden;
  --persistent-object-attribute-as-detail--delete-width: var(--theme-h2);
}
:host([initializing]) #table {
  opacity: 0;
}
:host #table {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-height: 0;
  min-width: 0;
  line-height: var(--theme-h2);
  overflow: hidden;
}
:host #table #head {
  display: grid;
  grid-template-columns: var(--column-widths);
  height: var(--theme-h2);
  border-style: solid;
  border-color: var(--theme-light-border);
  border-width: 0 0 1px 0;
}
:host #table #head .column {
  box-sizing: border-box;
  border-style: solid;
  border-color: var(--theme-light-border);
  border-width: 0;
}
:host #table #head .column label {
  display: block;
  padding: 0 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
  font-weight: bold;
  font-size: 11px;
  letter-spacing: 0.5px;
}
:host #table #body {
  position: relative;
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host #table #body #data {
  display: block;
  overflow: hidden;
}
:host #table button.action {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
}
:host([editing]) #table {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host([editing]) #table #head {
  background-color: #F9F9F9;
}
:host([editing]) #table #head .column {
  border-width: 1px 0 0 1px;
  padding: 0 1px 1px 0;
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  box-sizing: border-box;
  width: auto;
  min-width: 0;
}
:host([editing]) #table #head .delete-spacer {
  width: var(--persistent-object-attribute-as-detail--delete-width);
  border-width: 1px 1px 0 0;
  border-color: var(--theme-light-border);
  border-style: solid;
}
:host([editing]) #table #body {
  margin-top: 1px !important;
}
:host([editing]) #table #body .row {
  height: calc(var(--theme-h2) + 2px);
  line-height: calc(var(--theme-h2) + 2px);
  overflow: hidden;
}
:host([editing]) #table #body .row:last-of-type {
  height: var(--theme-h2);
}
:host([editing]) #table #body .row:last-of-type .column, :host([editing]) #table #body .row:last-of-type div.delete-button {
  padding-bottom: 0;
}
:host([editing]) #table #body[vertical] .row div.delete-button {
  margin-right: var(--theme-h4);
}
:host([editing]) #table .row.add.foot {
  height: var(--theme-h2);
  background-color: #F9F9F9;
  border: 1px solid var(--theme-light-border);
}
:host([editing]) #table .row.add ::content > button {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
}
:host([editing]:not([can-delete])) #head .column:last-of-type {
  border-right: 0;
}
:host(:not([editing])) #table {
  border: none;
}
:host(:not([editing])) #table #body .row:nth-child(odd) {
  background-color: #FCFCFC;
}
:host(:not([editing])) #table #body .row:nth-child(even) {
  background-color: #F7F7F7;
}
:host(:not([editing])) #table #body .row .column {
  padding: 1px 4px;
  overflow: hidden;
  text-overflow: ellipsis;
}
:host(:not([editing])) #foot {
  display: none;
}</style>

<div id="table">
    <div id="head" class="horizontal layout" part="head">
        <dom-repeat items="[[attribute.details.columns]]" as="column" filter="_isColumnVisible">
            <template>
                <div class="column" data-column$="[[column.name]]"><label on-mouseenter="_titleMouseenter">[[column.label]]</label></div>
            </template>
        </dom-repeat>
        <div class="delete-spacer" hidden$="[[!canDelete]]"></div>
    </div>
    <vi-scroller id="body" no-horizontal force-scrollbars$="[[editing]]">
        <div class="flex horizontal layout">
            <div id="data" class="flex relative">
                <vi-size-tracker trigger-zero size="{{size}}"></vi-size-tracker>
                <div id="rows">
                    <dom-repeat items="[[attribute.objects]]" as="obj" filter="_isNotDeleted" observe="isDeleted">
                        <template>
                            <vi-persistent-object-attribute-as-detail-row class="row" service-object="[[obj]]" columns="[[attribute.details.columns]]" editing="[[editing]]" can-delete="[[canDelete]]" on-delete="_delete" full-edit="[[_isRowFullEdit(forceFullEdit, activeObjectIndex, index)]]" on-full-edit="_setActiveObjectIndex" read-only$="[[readOnly]]" frozen="[[frozen]]"></vi-persistent-object-attribute-as-detail-row>
                        </template>
                    </dom-repeat>
                </div>
                <dom-if if="[[newAction]]">
                    <template>
                        <div class="row add inline layout horizontal" hidden$="[[newActionPinned]]">
                            <vi-button inverse icon="Action_New" label="[[newAction.displayName]]" on-tap="_add" disabled$="[[op_some(attribute.parent.isFrozen, isAdding)]]" busy="[[isAdding]]"></vi-button>
                            <dom-if if="[[!newActionPinned]]" restamp>
                                <template>
                                    <slot name="button"></slot>
                                </template>
                            </dom-if>
                        </div>
                    </template>
                </dom-if>
            </div>
        </div>
    </vi-scroller>
    <dom-if if="[[newAction]]">
        <template>
            <div class="row add foot layout horizontal" hidden$="[[!newActionPinned]]">
                <vi-button inverse icon="Action_New" label="[[newAction.displayName]]" on-tap="_add" disabled$="[[op_some(attribute.parent.isFrozen, isAdding)]]" busy="[[isAdding]]"></vi-button>
                <dom-if if="[[newActionPinned]]" restamp>
                    <template>
                        <slot name="button"></slot>
                    </template>
                </dom-if>
            </div>
        </template>
    </dom-if>
</div>`; }
    _isColumnVisible(column) {
        return !column.isHidden && column.width !== "0";
    }
    _computeColumns(columns) {
        return columns.filter(c => !c.isHidden);
    }
    _computeCanDelete(editing, deleteAction, objects, attribute) {
        return editing && deleteAction && (attribute.parent.isNew || (!!objects && objects.some(o => !o.isDeleted)));
    }
    _computeNewActionPinned(height, newAction) {
        if (!height || !newAction)
            return false;
        const scroller = this.$.body;
        if (!this._inlineAddHeight) {
            const inlineAdd = scroller.querySelector(".row.add.inline");
            if (!inlineAdd)
                return false;
            this._inlineAddHeight = inlineAdd.offsetHeight;
        }
        const contentHeight = this.newActionPinned ? height : height - this._inlineAddHeight;
        return contentHeight + this._inlineAddHeight > this.$.table.offsetHeight - this.$.head.offsetHeight;
    }
    _isNotDeleted(object) {
        return !object.isDeleted;
    }
    _updateActions(actions, editing, readOnly, attribute) {
        this._setNewAction(editing && !readOnly ? actions["New"] || null : null);
        this._setDeleteAction(editing && !readOnly && (attribute.parent.isNew || !!actions["Delete"]));
    }
    _updateWidths(columns, canDelete, isConnected) {
        if (!isConnected || !columns?.length)
            return;
        let remainingFraction = 100;
        const widths = columns.filter(c => c.width !== "0").map(c => {
            if (c.width?.endsWith("%")) {
                const width = parseInt(c.width);
                remainingFraction -= width;
                return `${width}fr`;
            }
            const width = parseInt(c.width);
            if (!isNaN(width) && width)
                return `${width}px`;
            return null;
        });
        const remainingWidths = widths.filter(w => w === null);
        if (remainingWidths.length > 0) {
            const remainingWidth = `${remainingFraction / remainingWidths.length}fr`;
            widths.forEach((w, i) => {
                if (w)
                    return;
                widths[i] = remainingWidth;
            });
        }
        if (canDelete)
            widths.push("min-content");
        this.style.setProperty("--column-widths", widths.join(" "));
        this._setInitializing(false);
    }
    async _add(e) {
        try {
            this._setIsAdding(true);
            const po = await this.attribute.newObject();
            if (!po)
                return;
            if (po.stateBehavior.indexOf("OpenAsDialog") < 0) {
                if (this.attribute.lookupAttribute && po.attributes[this.attribute.lookupAttribute]) {
                    const lookupAttribute = po.attributes[this.attribute.lookupAttribute];
                    lookupAttribute.lookup.search();
                    lookupAttribute.lookup.maxSelectedItems = 0;
                    const items = await this.app.showDialog(new SelectReferenceDialog(lookupAttribute.lookup));
                    if (items && items.length > 0) {
                        const objects = [po];
                        let item = items.shift();
                        await lookupAttribute.changeReference([item]);
                        do {
                            if (!(item = items.shift()))
                                break;
                            const po2 = await this.attribute.newObject();
                            await po2.getAttribute(this.attribute.lookupAttribute).changeReference([item]);
                            objects.push(po2);
                        } while (items.length > 0);
                        await this._finalizeAdd(...objects);
                    }
                }
                else
                    await this._finalizeAdd(po);
            }
            else {
                this.app.showDialog(new PersistentObjectDialog(po, {
                    saveLabel: po.service.actionDefinitions["AddReference"].displayName,
                    save: (po, close) => {
                        this._finalizeAdd(po);
                        close();
                    }
                }));
            }
        }
        catch (e) {
            this.attribute.parent.setNotification(e);
        }
        finally {
            this._setIsAdding(false);
        }
    }
    async _finalizeAdd(...objects) {
        objects.forEach(po => {
            po.parent = this.attribute.parent;
            this.push("attribute.objects", po);
        });
        this.activeObjectIndex = this.attribute.objects.length - 1;
        flush$1();
        microTask.run(() => this.$.body.verticalScrollOffset = this.$.body.innerHeight);
        this.attribute.isValueChanged = true;
        this.attribute.parent.triggerDirty();
        if (this.attribute.triggersRefresh)
            await this.attribute._triggerAttributeRefresh(true);
    }
    _delete(e) {
        const object = e.detail;
        object.isDeleted = true;
        if (object.isNew)
            this.splice("attribute.objects", this.attribute.objects.indexOf(object), 1);
        this.attribute.isValueChanged = true;
        this.attribute.parent.triggerDirty();
        if (this.attribute.triggersRefresh)
            this.attribute._triggerAttributeRefresh(true);
    }
    _setActiveObjectIndex(e) {
        if (!this.readOnly)
            this.activeObjectIndex = e.model.index;
        e.stopPropagation();
    }
    _isRowFullEdit(forceFullEdit, activeObjectIndex, index) {
        return forceFullEdit || activeObjectIndex === index;
    }
    _frozenChanged(frozen) {
        if (frozen) {
            __classPrivateFieldSet(this, _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex, this.activeObjectIndex, "f");
            this.activeObjectIndex = -1;
        }
        else if (__classPrivateFieldGet(this, _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex, "f") !== undefined && this.attribute.objects.length > __classPrivateFieldGet(this, _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex, "f")) {
            this.activeObjectIndex = __classPrivateFieldGet(this, _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex, "f");
            __classPrivateFieldSet(this, _PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex, undefined, "f");
        }
    }
    _titleMouseenter(e) {
        const label = e.target;
        label.setAttribute("title", label.textContent);
    }
};
_PersistentObjectAttributeAsDetail__unfrozenActiveObjectIndex = new WeakMap();
PersistentObjectAttributeAsDetail = __decorate([
    WebComponent.register({
        properties: {
            columns: {
                type: Array,
                computed: "_computeColumns(attribute.details.columns)"
            },
            newAction: {
                type: Object,
                readOnly: true
            },
            newActionPinned: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeNewActionPinned(size.height, newAction)"
            },
            deleteAction: {
                type: Boolean,
                readOnly: true
            },
            size: {
                type: Object,
                notify: true
            },
            canDelete: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeCanDelete(editing, deleteAction, attribute.objects, attribute)"
            },
            initializing: {
                type: Boolean,
                reflectToAttribute: true,
                value: true,
                readOnly: true
            },
            activeObjectIndex: {
                type: Number,
                value: -1
            },
            isAdding: {
                type: Boolean,
                readOnly: true,
                value: false
            },
            forceFullEdit: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            }
        },
        observers: [
            "_updateWidths(columns, canDelete, isConnected)",
            "_updateActions(attribute.details.actions, editing, readOnly, attribute)",
            "_frozenChanged(frozen)"
        ],
        forwardObservers: [
            "attribute.objects.*.isDeleted"
        ]
    })
], PersistentObjectAttributeAsDetail);
PersistentObjectAttribute.registerAttributeType("AsDetail", PersistentObjectAttributeAsDetail);

let PersistentObjectAttributeBinaryFile = class PersistentObjectAttributeBinaryFile extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
  outline: none;
}
:host input[readonly] {
  flex: 1;
  min-height: 0;
  min-width: 0;
  z-index: 1;
}
:host .browse ::slotted(input) {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  opacity: 0;
  padding: 0;
  margin: 0;
  border: 0;
  cursor: pointer;
}
:host span, :host input {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[fileName]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <input class="flex" value="{{fileName}}" type="text" readonly placeholder="[[placeholder]]">
            </vi-sensitive>
            <dom-if if="[[!readOnly]]">
                <template>
                    <button class="browse" slot="right" on-change="_change">
                        <vi-icon source="FileUpload"></vi-icon>
                        <slot name="upload"></slot>
                    </button>
                    <dom-if if="[[canClear]]" restamp>
                        <template>
                            <button slot="right" on-tap="_clear" tabindex="-1">
                                <vi-icon source="Remove"></vi-icon>
                            </button>
                        </template>
                    </dom-if>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>

<vi-icon name="FileUpload">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 7.4765625 1.4882812 L 7.4765625 6.2617188 L 24.523438 6.2617188 L 24.523438 1.4882812 L 7.4765625 1.4882812 z M 15.966797 7.9042969 L 4.3476562 19.521484 L 7.703125 22.880859 L 13.615234 16.966797 L 13.615234 30.46875 L 18.388672 30.46875 L 18.388672 17.033203 L 24.296875 22.949219 L 27.652344 19.589844 L 15.966797 7.9042969 z " />
        </g>
    </svg>
</vi-icon>`; }
    connectedCallback() {
        super.connectedCallback();
        this._hookInput(this.attribute);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._unhookInput();
    }
    focus() {
        this.attribute?.input?.focus();
    }
    _attributeChanged() {
        super._attributeChanged();
        this._unhookInput();
        this._hookInput(this.attribute);
    }
    async _change(e) {
        const targetInput = e.target;
        if (targetInput.files && targetInput.files.length > 0) {
            this.value = targetInput.files[0].name;
            if (this.attribute.triggersRefresh)
                await this.attribute._triggerAttributeRefresh(true);
        }
    }
    _unhookInput() {
        const currentInput = this.querySelector("input[slot=upload]");
        if (currentInput)
            this.removeChild(currentInput);
    }
    _hookInput(attribute) {
        if (!attribute?.input)
            return;
        attribute.input.setAttribute("slot", "upload");
        this.appendChild(attribute.input);
    }
    async _clear() {
        this.value = null;
        if (this.attribute?.input?.files?.length)
            this.attribute.input.value = null;
        if (this.attribute?.triggersRefresh)
            await this.attribute._triggerAttributeRefresh(true);
    }
    _computeCanClear(value, readOnly) {
        return !readOnly && !String.isNullOrEmpty(value);
    }
    _computeFileName(value) {
        if (String.isNullOrEmpty(value))
            return "";
        return value.split("|")[0];
    }
};
PersistentObjectAttributeBinaryFile = __decorate([
    WebComponent.register({
        properties: {
            canClear: {
                type: Boolean,
                computed: "_computeCanClear(value, readOnly)"
            },
            fileName: {
                type: String,
                computed: "_computeFileName(value)"
            }
        }
    })
], PersistentObjectAttributeBinaryFile);
PersistentObjectAttribute.registerAttributeType("BinaryFile", PersistentObjectAttributeBinaryFile);

let Toggle = class Toggle extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  padding-right: var(--theme-h5);
  box-sizing: border-box;
}
:host(:not([disabled])) {
  cursor: pointer;
}
:host #box {
  padding: 2px;
  border: 1px solid var(--theme-light-border);
  width: var(--theme-h2);
}
:host #box #switch {
  background-color: #333;
  width: calc(var(--theme-h4) - 2px);
  height: calc(var(--theme-h4) - 2px);
  transform: translateX(0px);
  -webkit-transition: transform 0.25s cubic-bezier(0, 1, 0.6, 1);
  transition: transform 0.25s cubic-bezier(0, 1, 0.6, 1);
}
:host span {
  padding: 0 1px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
:host span:not(:empty) {
  margin-left: calc(var(--theme-h5) - 1px);
}
:host(:focus) {
  outline: 0;
}
:host(:focus:not([disabled])) span {
  outline: 1px dotted var(--color-light);
}

:host([toggled]) #box {
  background-color: var(--color);
  border-color: var(--color);
}
:host([toggled]) #box #switch {
  background-color: white;
  transform: translateX(calc(var(--theme-h2) - var(--theme-h4) + 2px));
}

:host([disabled][toggled]) #box {
  background-color: #d6d6d6;
  border-color: #d6d6d6;
}

:host([disabled]:not([toggled])) #box {
  border-color: var(--theme-light-border);
}
:host([disabled]:not([toggled])) #box #switch {
  background-color: #a5a5a5;
}</style>

<div class="layout horizontal center">
    <div id="box" class="relative">
        <div id="switch"></div>
    </div>
    <span hidden$="[[op_isEmpty(label)]]">[[label]]</span>
</div>`; }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("tabindex", "0");
    }
    toggle() {
        if (this.disabled)
            return;
        this.toggled = !this.toggled;
    }
    _keyToggle(e) {
        if (this.app.activeElement !== this)
            return true;
        this.toggle();
    }
    _computeIsNull(toggled) {
        return toggled !== false && toggled !== true;
    }
};
Toggle = __decorate([
    WebComponent.register({
        properties: {
            toggled: {
                type: Boolean,
                reflectToAttribute: true,
                notify: true
            },
            label: {
                type: String,
                value: null
            },
            isNull: {
                type: Boolean,
                value: true,
                computed: "_computeIsNull(toggled)"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            }
        },
        listeners: {
            "tap": "toggle"
        },
        keybindings: {
            "space": "_keyToggle"
        }
    })
], Toggle);

let PersistentObjectAttributeBoolean = class PersistentObjectAttributeBoolean extends PersistentObjectAttribute {
    static get template() { return html$3 `<style>:host {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: row;
  line-height: normal;
}
:host vi-checkbox {
  display: inline-block;
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}

:host-context(vi-persistent-object-attribute-as-detail) {
  border: 1px solid var(--theme-light-border);
  margin: 0 1px;
  padding: 0 var(--theme-h5);
  line-height: var(--theme-h2);
}</style>
<dom-if if="[[editing]]">
    <template>
        <dom-if if="[[!sensitive]]" restamp>
            <template>
                <dom-if if="[[!isCheckbox]]">
                    <template>
                        <vi-toggle label="[[attribute.displayValue]]" toggled="{{value}}" disabled="[[op_some(attribute.isReadOnly, attribute.parent.isFrozen)]]"></vi-toggle>
                    </template>
                </dom-if>
                <dom-if if="[[isCheckbox]]">
                    <template>
                        <vi-checkbox checked="{{value}}" label="[[attribute.displayValue]]" disabled="[[op_some(attribute.isReadOnly, attribute.parent.isFrozen)]]"></vi-checkbox>
                    </template>
                </dom-if>
            </template>
        </dom-if>
        <dom-if if="[[sensitive]]" restamp>
            <template>
                <vi-sensitive>
                    <span>[[attribute.displayValue]]</span>
                </vi-sensitive>
            </template>
        </dom-if>
    </template>
</dom-if>
<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>`; }
    connectedCallback() {
        super.connectedCallback();
        this._setDefaultInputtype(this.app.configuration.getSetting("vi-persistent-object-attribute-boolean.inputtype", "toggle").toLowerCase());
    }
    _valueChanged(newValue) {
        if (this.attribute && newValue !== this.attribute.value)
            this.attribute.setValue(newValue, true).catch(noop$1);
    }
    _computeCanToggle(editing, isReadOnly) {
        return editing && !isReadOnly;
    }
    _computeIsDisabled(isReadOnly, isFrozen) {
        return isReadOnly || isFrozen;
    }
    _computeIsCheckbox(attribute, defaultInputtype) {
        return attribute.getTypeHint("inputtype", defaultInputtype, undefined, true) === "checkbox";
    }
};
PersistentObjectAttributeBoolean = __decorate([
    WebComponent.register({
        properties: {
            canToggle: {
                type: Boolean,
                computed: "_computeCanToggle(editing, readOnly)"
            },
            defaultInputtype: {
                type: String,
                readOnly: true
            },
            isCheckbox: {
                type: Boolean,
                computed: "_computeIsCheckbox(attribute, defaultInputtype)"
            }
        }
    })
], PersistentObjectAttributeBoolean);
PersistentObjectAttribute.registerAttributeType("Boolean", PersistentObjectAttributeBoolean);

let Select = class Select extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
  border: 1px solid #ddd;
  outline: none !important;
}
:host vi-popup {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host vi-popup #content {
  transform: translate(0, 1px);
}
:host vi-popup [slot=header] {
  flex: 1;
  min-height: 0;
  min-width: 0;
  display: flex;
  flex-direction: row;
  position: relative;
}
:host vi-popup [slot=header] .suggestions {
  z-index: 1;
  padding-left: var(--theme-h5);
  position: absolute;
  left: 0;
  height: calc(var(--theme-h2) - 2px);
  line-height: calc(var(--theme-h2) - 2px);
}
:host vi-popup [slot=header] .suggestions span {
  float: left;
}
:host vi-popup [slot=header] .suggestions span:first-child {
  color: transparent;
}
:host vi-popup [slot=header] .suggestions span:nth-child(2) {
  color: #CCC;
}
:host vi-popup [slot=header] input {
  border: none;
  height: calc(var(--theme-h2) - 2px);
  line-height: calc(var(--theme-h2) - 2px);
  padding-left: var(--theme-h5);
  background-color: transparent;
  outline: none;
}
:host vi-popup [slot=header] input[disabled] {
  color: inherit !important;
}
:host vi-popup [slot=header] vi-icon {
  height: calc(var(--theme-h2) - 2px);
  width: calc(var(--theme-h2) - 2px);
  fill: var(--vi-select-icon-color, var(--theme-foreground));
}
:host vi-popup [content] {
  max-height: calc(var(--theme-h2) * 10);
  padding: 0;
  margin: 0;
  list-style: none;
}
:host vi-popup [content] .group, :host vi-popup [content] vi-select-option-item {
  display: block;
  line-height: calc(var(--theme-h2) - 2px);
  height: calc(var(--theme-h2) - 2px);
  white-space: nowrap;
}
:host vi-popup [content] .group {
  padding-left: var(--theme-h5);
  color: #888;
}
:host vi-popup [content] vi-select-option-item {
  padding-left: var(--theme-h3);
  cursor: pointer;
}
:host vi-popup [content] vi-select-option-item:hover {
  background-color: var(--color-faint);
}
:host vi-popup [content] vi-select-option-item[suggested], :host vi-popup [content]:not([filtering]) vi-select-option-item[selected] {
  color: white;
  background-color: var(--color);
}
:host vi-popup [content] vi-select-option-item[suggested]:hover, :host vi-popup [content]:not([filtering]) vi-select-option-item[selected]:hover {
  background-color: var(--color-light);
}
:host vi-popup [content][filtering] vi-select-option-item span.match {
  background-color: rgba(255, 255, 0, 0.5);
  font-weight: bold;
  pointer-events: none;
}
:host vi-popup[disabled] [slot=header] vi-icon {
  opacity: 0.25;
  cursor: default;
}
:host([sensitive]) input, :host([sensitive]) vi-select-option-item {
  filter: blur(5px);
}
:host([sensitive]) input + vi-icon {
  opacity: 0.5;
}</style>

<vi-popup id="popup" on-popup-opened="_popupOpened" on-popup-closed="_popupClosed" sticky auto-width disabled$="[[op_some(readonly, disabled, sensitive)]]">
    <div slot="header" >
        <slot name="left"></slot>
        <div class="suggestions">
            <span id="match"></span><span id="remainder"></span>
        </div>
        <vi-sensitive disabled="[[!sensitive]]">
            <input class="flex" value="{{_inputValue::input}}" on-blur="_blur" on-keydown="_keydown" on-keyup="_keyup" readonly$="[[isReadonlyInput]]" tabindex="[[inputTabindex]]" placeholder="[[placeholder]]" part="input" disabled="[[disabled]]">
        </vi-sensitive>
        <vi-icon source="CaretDown" hidden$="[[!hasOptions]]" part="icon"></vi-icon>
        <slot name="right"></slot>
    </div>
    <dom-if if="[[!lazy]]">
        <template>
            <dom-if if="[[!groupSeparator]]">
                <template>
                    <vi-scroller id="scroller" content filtering$="[[filtering]]" on-select-option="_select">
                        <dom-repeat items="[[filteredItems]]" as="item">
                            <template>
                                <vi-select-option-item suggested="[[op_areSame(item.option, suggestion.option)]]" selected="[[op_areSame(item.option, selectedItem.option)]]" item="{{item}}" inner-h-t-m-l="[[_computeItemDisplayValue(item.displayValue, inputValue)]]"></vi-select-option-item>
                            </template>
                        </dom-repeat>
                    </vi-scroller>
                </template>
            </dom-if>
            <dom-if if="[[groupSeparator]]">
                <template>
                    <vi-scroller id="grouped-scroller" content filtering$="[[filtering]]" on-select-option="_select">
                        <dom-repeat items="[[filteredItems]]" as="item">
                            <template>
                                <dom-if if="[[op_every(item.group, item.groupFirst)]]">
                                    <template>
                                        <div class="group">[[item.group]]</div>
                                    </template>
                                </dom-if>
                                <vi-select-option-item suggested="[[op_areSame(item.option, suggestion.option)]]" selected="[[op_areSame(item.option, selectedItem.option)]]" item="{{item}}" inner-h-t-m-l="[[_computeItemDisplayValue(item.displayValue, inputValue)]]"></vi-select-option-item>
                            </template>
                        </dom-repeat>
                    </vi-scroller>
                </template>
            </dom-if>
        </template>
    </dom-if>
</vi-popup>`; }
    open() {
        if (this.readonly || !this.items || this.items.length === 0)
            return;
        this.popup.popup();
    }
    focus() {
        this.shadowRoot.querySelector("input").focus();
    }
    get popup() {
        return this.$.popup;
    }
    _keydown(e) {
        if (!this.ungroupedOptions || this.ungroupedOptions.length === 0)
            return;
        if (this.items && this.items.length > 0) {
            const currentIndex = this.filteredItems.indexOf(this.filtering ? this.suggestion : this.selectedItem);
            if (e.key === Keys.ArrowDown) {
                this.popup.popup();
                if (currentIndex + 1 < this.filteredItems.length) {
                    if (this.filtering)
                        this._setSuggestion(this.filteredItems[currentIndex + 1]);
                    else
                        this._setSelectedItem(this.filteredItems[currentIndex + 1]);
                }
                e.stopPropagation();
                e.preventDefault();
            }
            else if (e.key === Keys.ArrowUp) {
                this.popup.popup();
                if (currentIndex > 0) {
                    if (this.filtering)
                        this._setSuggestion(this.filteredItems[currentIndex - 1]);
                    else
                        this._setSelectedItem(this.filteredItems[currentIndex - 1]);
                }
                e.stopPropagation();
                e.preventDefault();
            }
            else if (e.key === Keys.Enter || e.key === Keys.Tab) {
                this.popup.close();
                if (this.suggestion !== this.selectedItem)
                    this._setSelectedItem(this.suggestion);
                else
                    this._selectedItemChanged();
                if (e.key === Keys.Enter) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
            else if (e.key === Keys.Escape) {
                this.popup.close();
                if (this.filtering)
                    this._setFiltering(false);
                const currentSelectedItem = this.selectedItem;
                this._setSelectedItem(this._getItem(this.selectedOption));
                if (currentSelectedItem === this.selectedItem)
                    this._selectedItemChanged();
                e.stopPropagation();
                e.preventDefault();
            }
        }
    }
    _keyup(e) {
        if (this._lastMatchedInputValue !== this._inputValue && !this.filtering && e.key !== Keys.Enter && e.key !== Keys.Tab && e.key !== Keys.Escape)
            this._setFiltering(true);
    }
    _blur() {
        if (this.keepUnmatched)
            return;
        if (!this.popup.open)
            this._selectedItemChanged();
    }
    _popupOpened() {
        if (this.lazy) {
            this._setLazy(false);
            flush$1();
        }
        this._scrollItemIntoView();
    }
    _popupClosed() {
        if (this._pendingSelectedOption) {
            const pendingSelectedOption = this._pendingSelectedOption;
            this._pendingSelectedOption = undefined;
            this._setSelectedItem(this._getItem(pendingSelectedOption));
        }
    }
    _scrollItemIntoView() {
        if (!this.selectedItem)
            return;
        const scroller = this.shadowRoot.getElementById(`${this.groupSeparator ? "grouped-" : ""}scroller`);
        if (scroller != null) {
            const options = Array.from(scroller.querySelectorAll("vi-select-option-item"));
            options.find(option => option.item === this.selectedItem)?.scrollIntoView();
        }
    }
    _computeHasOptions(options, readonly) {
        return !readonly && !!options && options.length > 0;
    }
    _computeUngroupedOptions(options, groupSeparator) {
        if (!groupSeparator || !options || options.length === 0)
            return options;
        if (options.some(o => typeof o === "string"))
            return options.map(o => o ? o.split(groupSeparator, 2)[1] : o);
        else
            return options.map(kvp => {
                return {
                    key: kvp.key,
                    value: kvp && kvp.value ? kvp.value.split(groupSeparator, 2)[1] : ""
                };
            });
    }
    _computeItems(options, ungroupedOptions) {
        if (!options || options.length === 0)
            return [];
        const isKvp = !options.some(o => typeof o === "string");
        let groupFirstOptions;
        if (this.groupSeparator) {
            let optionsByGroup;
            if (!isKvp)
                optionsByGroup = options.groupBy(o => {
                    const parts = o ? o.split(this.groupSeparator, 2) : [];
                    return parts.length === 2 ? parts[0] || null : null;
                });
            else {
                optionsByGroup = options.groupBy(kvp => {
                    const displayValue = kvp ? kvp.value : null;
                    const displayParts = displayValue ? displayValue.split(this.groupSeparator, 2) : [];
                    return displayParts.length === 2 ? displayParts[0] || null : null;
                });
            }
            groupFirstOptions = new Map();
            optionsByGroup.forEach(g => {
                g.value.forEach((o, n) => groupFirstOptions.set(o, { name: g.key, first: n === 0 }));
            });
        }
        let result;
        if (!isKvp)
            result = options.map((o, n) => {
                const group = groupFirstOptions ? groupFirstOptions.get(o) : null;
                return {
                    displayValue: ungroupedOptions[n],
                    group: group ? group.name : null,
                    groupFirst: group ? group.first : null,
                    option: ungroupedOptions[n]
                };
            });
        else {
            result = options.map((kvp, index) => {
                const ungroupedKvp = ungroupedOptions[index];
                const group = groupFirstOptions ? groupFirstOptions.get(kvp) : null;
                return {
                    displayValue: ungroupedKvp ? ungroupedKvp.value : "",
                    group: group ? group.name : null,
                    groupFirst: group ? group.first : null,
                    option: ungroupedKvp
                };
            });
        }
        return result;
    }
    _computeFilteredItems(items, inputValue, filtering, selectedOption) {
        let result = items;
        if (result.length === 0)
            return result;
        if (filtering) {
            if (!String.isNullOrEmpty(inputValue)) {
                const lowerInputValue = inputValue.toLowerCase();
                result = result.filter(r => r != null && r.displayValue && r.displayValue.toLowerCase().contains(lowerInputValue));
                if (!this.suggestion || result.indexOf(this.suggestion) < 0)
                    this._setSuggestion(result[0] !== undefined && result[0].displayValue.toLowerCase().startsWith(lowerInputValue) ? result[0] : null);
            }
            else {
                let suggestion;
                if (result[0].option == null)
                    suggestion = result[0];
                else if (typeof result[0].option === "string") {
                    suggestion = result.find(o => o.option == null);
                    if (!suggestion)
                        suggestion = result.find(o => o.option.length === 0);
                }
                else {
                    suggestion = result.find(o => o.option.key == null);
                    if (!suggestion)
                        suggestion = result.find(o => o.option.key.length === 0);
                }
                this._setSuggestion(suggestion);
            }
            if (!this.popup.open && result.length > 1)
                this.popup.popup();
        }
        else if (!this.selectedItem)
            this._setSelectedItem(this._getItem(this.selectedOption));
        return result;
    }
    _computeSuggestionFeedback(inputValue, suggestion, filtering) {
        let suggestionMatch = "";
        let suggestionRemainder = "";
        if (filtering && suggestion && suggestion.displayValue) {
            suggestionMatch = inputValue;
            suggestionRemainder = suggestion.displayValue.substr(inputValue.length);
        }
        this.$.match.innerHTML = this._escapeHTML(suggestionMatch).replace(" ", "&nbsp;");
        this.$.remainder.innerHTML = this._escapeHTML(suggestionRemainder).replace(" ", "&nbsp;");
    }
    _computeItemDisplayValue(displayValue, inputValue) {
        if (!displayValue || !inputValue)
            return displayValue;
        const exp = new RegExp(`(${inputValue})`, "gi");
        return displayValue.replace(exp, "<span class='match'>$1</span>");
    }
    _disabledChanged(newValue, oldValue) {
        if (newValue && this.$.popup.open)
            this.$.popup.close();
    }
    _setSelectedOption(option, force) {
        if (option && typeof option !== "string")
            option = option.key;
        if (this.popup.open && !force) {
            this._pendingSelectedOption = option;
            this._scrollItemIntoView();
            return;
        }
        this.selectedOption = option;
    }
    _selectedItemChanged() {
        this._setFiltering(false);
        if (this.selectedItem) {
            if (!this.selectedItem.option || typeof this.selectedItem.option === "string") {
                this._setSelectedOption(this.ungroupedOptions.find(o => o === this.selectedItem.option));
                this._inputValue = this.selectedItem.option;
            }
            else {
                this._setSelectedOption(this.ungroupedOptions.find(o => o.key === this.selectedItem.option.key));
                this._inputValue = this.selectedItem.option.value;
            }
            this._lastMatchedInputValue = this._inputValue;
            this._setSuggestion(this.selectedItem);
        }
        else {
            this._setSuggestion(null);
            this._inputValue = "";
        }
    }
    _selectedOptionChanged() {
        this._setFiltering(false);
        this._setSelectedItem(this._getItem(this.selectedOption));
        this._scrollItemIntoView();
    }
    _suggestionChanged() {
        if (!this.filtering && this.suggestion)
            this._setSelectedOption(this.suggestion.option);
    }
    _getItem(key, items = this.items) {
        if (!items)
            return undefined;
        return items.find(i => {
            if (!i.option || typeof i.option === "string")
                return i.option === key;
            else
                return i.option.key === key;
        });
    }
    _select(e, detail) {
        this._setSelectedOption(detail.option, true);
        this.popup.close();
        e.stopPropagation();
    }
    _computeIsReadonlyInput(readonly, hasOptions, keepUnmatched, disableFiltering) {
        return readonly || (!keepUnmatched && (!hasOptions || disableFiltering));
    }
    _computeInputTabIndex(isReadonlyInput) {
        return isReadonlyInput ? "-1" : "0";
    }
};
Select = __decorate([
    WebComponent.register({
        properties: {
            options: {
                type: Array,
                value: null
            },
            hasOptions: {
                type: Boolean,
                computed: "_computeHasOptions(options, readonly)"
            },
            keepUnmatched: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            selectedOption: {
                type: Object,
                observer: "_selectedOptionChanged",
                notify: true
            },
            suggestion: {
                type: Object,
                readOnly: true,
                observer: "_suggestionChanged"
            },
            groupSeparator: {
                type: String,
                value: null
            },
            ungroupedOptions: {
                type: Array,
                computed: "_computeUngroupedOptions(options, groupSeparator)"
            },
            items: {
                type: Array,
                computed: "_computeItems(options, ungroupedOptions)"
            },
            filteredItems: {
                type: Array,
                computed: "_computeFilteredItems(items, inputValue, filtering, selectedOption)"
            },
            selectedItem: {
                type: Object,
                readOnly: true,
                observer: "_selectedItemChanged"
            },
            inputValue: {
                type: String,
                notify: true,
                computed: "_forwardComputed(_inputValue)"
            },
            _inputValue: {
                type: String,
                notify: true,
                value: ""
            },
            filtering: {
                type: Boolean,
                readOnly: true,
                value: false
            },
            readonly: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            isReadonlyInput: {
                type: Boolean,
                computed: "_computeIsReadonlyInput(readonly, hasOptions, keepUnmatched, disableFiltering)"
            },
            inputTabindex: {
                type: String,
                computed: "_computeInputTabIndex(isReadonlyInput)"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
                observer: "_disabledChanged"
            },
            disableFiltering: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            sensitive: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            placeholder: String,
            lazy: {
                type: Boolean,
                readOnly: true,
                value: true
            }
        },
        listeners: {
            "keydown": "_keydown"
        },
        observers: [
            "_computeSuggestionFeedback(inputValue, suggestion, filtering)"
        ]
    })
], Select);
let SelectOptionItem = class SelectOptionItem extends WebComponent {
    _onTap(e) {
        this.fire("select-option", { option: this.item.option }, { bubbles: true });
        e.stopPropagation();
    }
};
SelectOptionItem = __decorate([
    WebComponent.register({
        properties: {
            suggested: {
                type: Boolean,
                reflectToAttribute: true
            },
            selected: {
                type: Boolean,
                reflectToAttribute: true
            },
            item: Object,
            group: {
                type: String,
                reflectToAttribute: true,
                computed: "item.group"
            }
        },
        listeners: {
            "tap": "_onTap"
        }
    })
], SelectOptionItem);

let PersistentObjectAttributeComboBox = class PersistentObjectAttributeComboBox extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host vi-select {
  border: none;
}
:host span, :host vi-select::part(input) {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host #add {
  background-color: var(--color);
}
:host #add vi-icon {
  fill: white !important;
}
:host #add:before {
  border-left-color: var(--color);
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]" restamp>
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <div class="relative">
                <vi-select options="[[comboBoxOptions]]" selected-option="{{value}}" input-value="{{newValue}}" keep-unmatched readonly="[[readOnly]]" disabled="[[attribute.parent.isFrozen]]" placeholder="[[placeholder]]" sensitive="[[sensitive]]"></vi-select>
            </div>
            <dom-if if="[[!readOnly]]">
                <template>
                    <vi-button slot="right" on-tap="_add" id="add" hidden$="[[!canAdd]]" tabindex="-1">
                        <vi-icon source="Add"></vi-icon>
                    </vi-button>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _editingChanged() {
        super._editingChanged();
        if (this.newValue) {
            this.newValue = null;
            this._optionsChanged();
        }
    }
    _valueChanged(newValue) {
        if (this.attribute && newValue !== this.attribute.value)
            this.attribute.setValue(newValue, true).catch(noop$1);
    }
    _optionsChanged() {
        const options = this.attribute.options ? this.attribute.options.slice() : [];
        let empty = options.indexOf(null);
        if (empty < 0)
            empty = options.indexOf("");
        if (options.indexOf(this.attribute.value) < 0) {
            options.splice(empty >= 0 ? empty + 1 : 0, 0, this.attribute.value);
        }
        this._setComboBoxOptions(options);
    }
    _add() {
        this.value = this.newValue;
        this._optionsChanged();
    }
    _computeCanAdd(newValue, options) {
        return newValue != null && options && !options.some(o => o === newValue);
    }
    _onFocus(e) {
        const select = this.shadowRoot.querySelector("vi-select");
        if (e.composedPath().some(e => e === select))
            return;
        this._focusElement(select);
    }
};
PersistentObjectAttributeComboBox = __decorate([
    WebComponent.register({
        properties: {
            newValue: {
                type: String,
                value: null,
                notify: true
            },
            comboBoxOptions: {
                type: Array,
                readOnly: true
            },
            canAdd: {
                type: Boolean,
                computed: "_computeCanAdd(newValue, comboBoxOptions)"
            }
        }
    })
], PersistentObjectAttributeComboBox);
PersistentObjectAttribute.registerAttributeType("ComboBox", PersistentObjectAttributeComboBox);

let PersistentObjectAttributeCommonMark = class PersistentObjectAttributeCommonMark extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  overflow: hidden;
}
:host vi-marked {
  flex: 1;
  min-height: 0;
  min-width: 0;
  resize: none;
}
:host vi-marked, :host textarea {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host textarea {
  white-space: pre-wrap;
  -ms-overflow-style: -ms-autohiding-scrollbar;
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-scroller class="flex" allow-native>
            <vi-sensitive disabled="[[!sensitive]]">
                <vi-marked markdown="[[attribute.displayValue]]"></vi-marked>
            </vi-sensitive>
        </vi-scroller>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <textarea class="flex" value="{{value::input}}" maxlength$="[[maxlength]]" style$="[[editInputStyle]]" on-blur="_editTextAreaBlur" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" disabled="[[frozen]]"></textarea>
            </vi-sensitive>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _editTextAreaBlur() {
        if (this.attribute && this.attribute.isValueChanged && this.attribute.triggersRefresh)
            this.attribute.setValue(this.value = this.attribute.value, true).catch(noop$1);
    }
};
PersistentObjectAttributeCommonMark = __decorate([
    WebComponent.register()
], PersistentObjectAttributeCommonMark);
PersistentObjectAttribute.registerAttributeType("CommonMark", PersistentObjectAttributeCommonMark);

var MaskedInput_1;
let MaskedInput = MaskedInput_1 = class MaskedInput extends WebComponent {
    static get template() { return html$3 `<input id="input"
       part="input"
       size="[[size]]"
       value="{{value::input}}"
       disabled="[[disabled]]"
       on-keydown="_keydown"
       on-keypress="_keypress"
       on-focus="_focus"
       on-blur="_blur"
       on-cut="_preventCutPaste"
       on-paste="_preventCutPaste"
       on-tap="_tap">`; }
    connectedCallback() {
        super.connectedCallback();
        if (!this.preserve || this.input.value === "")
            this.value = this.format;
    }
    get input() {
        return this.$.input;
    }
    focus() {
        this.$.input.focus();
    }
    _isOther(key) {
        return MaskedInput_1.otherKeys.indexOf(key) >= 0;
    }
    _isGoodOnes(key) {
        return this.allowed.indexOf(key) !== -1 || key === "Backspace" || key === "Delete" || this._isOther(key);
    }
    _isFilled() {
        for (let a = this.input.value.length - 1; a >= 0; a--) {
            for (let c = 0, d = this.open.length; c < d; c++) {
                if (this.input.value[a] === this.open[c])
                    return false;
            }
        }
        return true;
    }
    _resetCursor() {
        if (!!this.input.value && this.input.value !== this.format)
            return;
        setTimeout(() => {
            this._setTextCursor(0);
        }, 1);
    }
    _getTextCursor() {
        try {
            this.input.focus();
            if (this.input.selectionStart >= 0)
                return this.input.selectionStart;
            return -1;
        }
        catch (e) {
            return -1;
        }
    }
    _setTextCursor(pos) {
        try {
            if (this.input.selectionStart) {
                this.input.focus();
                this.input.setSelectionRange(pos, pos);
            }
        }
        catch (e) {
            return false;
        }
        return true;
    }
    _update(key) {
        let p = this._getTextCursor(), c = this.input.value, val = "";
        if (this.allowed.indexOf(key) !== -1) {
            p++;
            if (p > this.format.length)
                return false;
            while (this.separator.indexOf(c.charAt(p - 1)) !== -1 && p <= this.format.length)
                p++;
            val = c.substr(0, p - 1) + key + c.substr(p);
            if (this.allowed.indexOf(c.charAt(p)) === -1 && this.open.indexOf(c.charAt(p)) === -1)
                p++;
        }
        else if (key === "Backspace") {
            p--;
            if (p < 0)
                return false;
            while (this.allowed.indexOf(c.charAt(p)) === -1 && this.open.indexOf(c.charAt(p)) === -1 && p > 1)
                p--;
            val = c.substr(0, p) + this.format.substr(p, 1) + c.substr(p + 1);
        }
        else if (key === "Delete") {
            if (p >= c.length)
                return false;
            while (this.separator.indexOf(c.charAt(p)) !== -1 && c.charAt(p) !== '')
                p++;
            val = c.substr(0, p) + this.format.substr(p, 1) + c.substr(p + 1);
            p++;
        }
        else if (this._isOther(key))
            return true;
        else
            return false;
        this.value = "";
        this.value = val;
        this._setTextCursor(p);
        return false;
    }
    _keydown(e) {
        if (this.disabled)
            return true;
        if (e.metaKey || e.ctrlKey)
            return true;
        if (!this.input.value) {
            this.value = this.format;
            this._setTextCursor(0);
        }
        if (e.key === "Backspace" || e.key === "Delete") {
            this._update(e.key);
            e.preventDefault();
            return false;
        }
        return true;
    }
    _keypress(e) {
        if (this.disabled)
            return true;
        if (this._isOther(e.key) || e.metaKey || e.ctrlKey || e.altKey)
            return true;
        if (e.key !== "Backspace" && e.key !== "Delete" && e.key !== "shift") {
            if (!this._isGoodOnes(e.key)) {
                e.preventDefault();
                return false;
            }
            if (this._update(e.key)) {
                if (this._isFilled())
                    this.fire("filled");
                e.preventDefault();
                return true;
            }
            if (this._isFilled())
                this.fire("filled");
            e.preventDefault();
            return false;
        }
        return false;
    }
    _tap() {
        this._resetCursor();
    }
    _focus() {
        this._resetCursor();
        this._startText = this.input.value;
    }
    _blur() {
        if (this.input.value !== this._startText && this.input.onchange)
            this.input.dispatchEvent(new Event("change"));
    }
    _preventCutPaste(e) {
        e.preventDefault();
        return false;
    }
    _resetField() {
        this.value = this.format;
    }
    _computeSize(format) {
        return format?.length || undefined;
    }
};
MaskedInput.otherKeys = ["Tab", "Enter", "ArrowUp", "ArrowLeft", "ArrowDown", "ArrowRight"];
MaskedInput = MaskedInput_1 = __decorate([
    WebComponent.register({
        properties: {
            format: {
                type: String,
                observer: "_resetField",
                value: ""
            },
            separator: {
                type: String,
                observer: "_resetField",
                value: "\/:-"
            },
            allowed: {
                type: String,
                observer: "_resetField",
                value: "0123456789"
            },
            open: {
                type: String,
                observer: "_resetField",
                value: "_YMDhms"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            },
            preserve: {
                type: Boolean,
                reflectToAttribute: true
            },
            size: {
                type: Number,
                computed: "_computeSize(format)"
            },
            value: {
                type: String,
                notify: true
            }
        }
    })
], MaskedInput);

let TimePicker = class TimePicker extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  position: relative;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host(:hover) vi-popup[open] [slot=header], :host vi-popup[hover] [slot=header] {
  background-color: var(--color) !important;
  --vi-icon-fill: white !important;
}
:host .clock {
  padding: calc(var(--theme-h4) * 2);
}
:host(:active) .clock {
  color: var(--color) !important;
}
:host #clockHost {
  position: relative;
  width: 200px;
  height: 200px;
}
:host #clockHost::before {
  position: absolute;
  z-index: -1;
  left: -10px;
  top: -10px;
  width: 220px;
  height: 220px;
  background: #eee;
  -moz-border-radius: 50%;
  -webkit-border-radius: 50%;
  border-radius: 50%;
  content: "";
}
:host #clockHost .list {
  -moz-transition: all 0.3s ease-in-out;
  -o-transition: all 0.3s ease-in-out;
  -webkit-transition: all 0.3s ease-in-out;
  transition: all 0.3s ease-in-out;
  left: 90px;
  top: 90px;
  position: absolute;
  list-style-type: none;
  padding: 0;
  margin: 0;
}
:host #clockHost .list .item {
  position: absolute;
  text-align: center;
  display: block;
  width: 20px;
  height: 20px;
}
:host #clockHost .list .item:nth-child(12) {
  transform: rotate(330deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(12) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-330deg);
}
:host #clockHost .list .item:nth-child(12) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(11) {
  transform: rotate(300deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(11) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-300deg);
}
:host #clockHost .list .item:nth-child(11) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(10) {
  transform: rotate(270deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(10) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-270deg);
}
:host #clockHost .list .item:nth-child(10) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(9) {
  transform: rotate(240deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(9) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-240deg);
}
:host #clockHost .list .item:nth-child(9) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(8) {
  transform: rotate(210deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(8) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-210deg);
}
:host #clockHost .list .item:nth-child(8) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(7) {
  transform: rotate(180deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(7) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-180deg);
}
:host #clockHost .list .item:nth-child(7) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(6) {
  transform: rotate(150deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(6) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-150deg);
}
:host #clockHost .list .item:nth-child(6) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(5) {
  transform: rotate(120deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(5) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-120deg);
}
:host #clockHost .list .item:nth-child(5) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(4) {
  transform: rotate(90deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(4) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-90deg);
}
:host #clockHost .list .item:nth-child(4) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(3) {
  transform: rotate(60deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(3) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-60deg);
}
:host #clockHost .list .item:nth-child(3) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(2) {
  transform: rotate(30deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(2) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-30deg);
}
:host #clockHost .list .item:nth-child(2) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item:nth-child(1) {
  transform: rotate(0deg) translate(0, -90px);
}
:host #clockHost .list .item:nth-child(1) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(0deg);
}
:host #clockHost .list .item:nth-child(1) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(1) {
  font-size: 90%;
}
:host #clockHost .list:nth-child(2) {
  position: absolute;
  list-style-type: none;
  padding: 0;
  margin: 0;
}
:host #clockHost .list:nth-child(2) .item {
  position: absolute;
  text-align: center;
  display: block;
  width: 20px;
  height: 20px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(12) {
  transform: rotate(330deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(12) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-330deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(12) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(11) {
  transform: rotate(300deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(11) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-300deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(11) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(10) {
  transform: rotate(270deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(10) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-270deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(10) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(9) {
  transform: rotate(240deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(9) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-240deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(9) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(8) {
  transform: rotate(210deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(8) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-210deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(8) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(7) {
  transform: rotate(180deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(7) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-180deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(7) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(6) {
  transform: rotate(150deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(6) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-150deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(6) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(5) {
  transform: rotate(120deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(5) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-120deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(5) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(4) {
  transform: rotate(90deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(4) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-90deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(4) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(3) {
  transform: rotate(60deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(3) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-60deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(3) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(2) {
  transform: rotate(30deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(2) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(-30deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(2) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list:nth-child(2) .item:nth-child(1) {
  transform: rotate(0deg) translate(0, -57px);
}
:host #clockHost .list:nth-child(2) .item:nth-child(1) span {
  width: 20px;
  height: 20px;
  line-height: 20px;
  transform: rotate(0deg);
}
:host #clockHost .list:nth-child(2) .item:nth-child(1) span::before {
  width: 25px;
  height: 25px;
  border-radius: 12.5px;
}
:host #clockHost .list .item span {
  position: absolute;
  text-align: center;
  z-index: 1;
  left: 0;
  top: 0;
  cursor: pointer;
}
:host #clockHost .list .item span:hover {
  color: white;
}
:host #clockHost .list .item span:hover::before {
  background-color: var(--color-light);
}
:host #clockHost .list .item span::before {
  position: absolute;
  z-index: -1;
  left: -12.5%;
  top: -12.5%;
  content: "";
}
:host #clockHost .list .item.active span {
  color: white;
}
:host #clockHost .list .item.active span::before {
  background-color: var(--color);
}
:host #clockHost .list .item.active span:hover::before {
  background-color: var(--color-dark);
}
:host #clockHost > .face {
  position: absolute;
  width: 220px;
  height: 220px;
  -moz-transform-origin: 50% 50%;
  -ms-transform-origin: 50% 50%;
  -o-transform-origin: 50% 50%;
  -webkit-transform-origin: 50% 50%;
  transform-origin: 50% 50%;
}
:host #current {
  display: block;
  text-align: center;
  margin-bottom: 20px;
  font-size: var(--theme-h3);
}
:host #current span.minutes, :host #current span.hours {
  cursor: pointer;
  font-weight: bold;
}
:host([state=minutes]) .list:nth-child(3) {
  transform: scale(1);
  opacity: 1;
  z-index: 2;
}
:host([state=minutes]) .list:nth-child(1), :host([state=minutes]) .list:nth-child(2) {
  transform: scale(1.3);
  opacity: 0;
  z-index: -2;
}
:host([state=minutes]) #current .minutes {
  color: var(--color);
}
:host([state=hours]) .list:nth-child(3) {
  transform: scale(0.7);
  opacity: 0;
  z-index: 1;
}
:host([state=hours]) .list:nth-child(1), :host([state=hours]) .list:nth-child(2) {
  transform: scale(1);
  opacity: 1;
  z-index: 2;
}
:host([state=hours]) #current .hours {
  color: var(--color);
}</style>

<vi-popup id="popup" vertical-align="bottom" placement="bottom-end" part="popup">
    <vi-icon slot="header" part="icon" source="Clock"></vi-icon>
    <div class="clock" on-tap="_catchTap">
        <div id="current">
            <span class="hours" on-tap="_switch">[[_zeroPrefix(hours)]]</span>
            <span>:</span>
            <span class="minutes" on-tap="_switch">[[_zeroPrefix(minutes)]]</span>
        </div>
        <div id="clockHost" on-tap="_tap">
            <div class="face">
                <div class="list">
                    <div class="item" data-hours="0"><span>00</span></div>
                    <div class="item" data-hours="13"><span>13</span></div>
                    <div class="item" data-hours="14"><span>14</span></div>
                    <div class="item" data-hours="15"><span>15</span></div>
                    <div class="item" data-hours="16"><span>16</span></div>
                    <div class="item" data-hours="17"><span>17</span></div>
                    <div class="item" data-hours="18"><span>18</span></div>
                    <div class="item" data-hours="19"><span>19</span></div>
                    <div class="item" data-hours="20"><span>20</span></div>
                    <div class="item" data-hours="21"><span>21</span></div>
                    <div class="item" data-hours="22"><span>22</span></div>
                    <div class="item" data-hours="23"><span>23</span></div>
                </div>
                <div class="list">
                    <div class="item" data-hours="12"><span>12</span></div>
                    <div class="item" data-hours="1"><span>1</span></div>
                    <div class="item" data-hours="2"><span>2</span></div>
                    <div class="item" data-hours="3"><span>3</span></div>
                    <div class="item" data-hours="4"><span>4</span></div>
                    <div class="item" data-hours="5"><span>5</span></div>
                    <div class="item" data-hours="6"><span>6</span></div>
                    <div class="item" data-hours="7"><span>7</span></div>
                    <div class="item" data-hours="8"><span>8</span></div>
                    <div class="item" data-hours="9"><span>9</span></div>
                    <div class="item" data-hours="10"><span>10</span></div>
                    <div class="item" data-hours="11"><span>11</span></div>
                </div>
                <div class="list">
                    <div class="item" data-minutes="0"><span>00</span></div>
                    <div class="item" data-minutes="5"><span>05</span></div>
                    <div class="item" data-minutes="10"><span>10</span></div>
                    <div class="item" data-minutes="15"><span>15</span></div>
                    <div class="item" data-minutes="20"><span>20</span></div>
                    <div class="item" data-minutes="25"><span>25</span></div>
                    <div class="item" data-minutes="30"><span>30</span></div>
                    <div class="item" data-minutes="35"><span>35</span></div>
                    <div class="item" data-minutes="40"><span>40</span></div>
                    <div class="item" data-minutes="45"><span>45</span></div>
                    <div class="item" data-minutes="50"><span>50</span></div>
                    <div class="item" data-minutes="55"><span>55</span></div>
                </div>
            </div>
        </div>
    </div>
</vi-popup>`; }
    connectedCallback() {
        super.connectedCallback();
        this._updateTime();
    }
    get isOpen() {
        return this.$.popup.open;
    }
    _timeChanged() {
        this._updateTime();
    }
    _tap(e, detail, sender) {
        let source;
        let tapSource = e.target;
        if (tapSource.tagName === "SPAN") {
            const parent = tapSource.parentNode;
            if (parent.classList && parent.classList.contains("item"))
                source = parent;
        }
        else {
            const parent = tapSource;
            if (parent.classList && parent.classList.contains("item"))
                source = parent;
        }
        if (!source)
            return;
        const newTime = new Date();
        if (this.time) {
            newTime.netOffset(this.time.netOffset());
            newTime.netType(this.time.netType());
            newTime.setFullYear(this.time.getFullYear(), this.time.getMonth(), this.time.getDate());
            newTime.setHours(this.time.getHours(), this.time.getMinutes(), 0, 0);
        }
        else
            newTime.setHours(0, 0, 0, 0);
        if (this.state === "hours") {
            this._setHours(parseInt(source.getAttribute("data-hours"), 10));
            newTime.setHours(this.hours);
            this.state = "minutes";
        }
        else if (this.state === "minutes") {
            this._setMinutes(parseInt(source.getAttribute("data-minutes"), 10));
            newTime.setMinutes(this.minutes);
        }
        this.time = newTime;
        e.stopPropagation();
    }
    _switch(e, detail) {
        const target = e.target;
        if (target.classList.contains("hours"))
            this.state = "hours";
        else if (target.classList.contains("minutes"))
            this.state = "minutes";
        e.stopPropagation();
    }
    _updateTime() {
        this._setHours(this.time ? this.time.getHours() : 0);
        this._setMinutes(this.time ? this.time.getMinutes() : 0);
        const items = this.shadowRoot.querySelectorAll(".item");
        [].forEach.apply(items, [(item) => {
                const hours = parseInt(item.getAttribute("data-hours"), 10);
                const minutes = parseInt(item.getAttribute("data-minutes"), 10);
                if (hours === this.hours || minutes === this.minutes)
                    item.classList.add("active");
                else
                    item.classList.remove("active");
            }]);
    }
    _catchTap(e) {
        e.stopPropagation();
    }
    _zeroPrefix(n) {
        return n < 10 ? "0" + n : n.toString();
    }
};
TimePicker = __decorate([
    WebComponent.register({
        properties: {
            time: {
                type: Date,
                notify: true,
                observer: "_timeChanged"
            },
            state: {
                type: String,
                reflectToAttribute: true,
                value: "hours"
            },
            hours: {
                type: Number,
                readOnly: true
            },
            minutes: {
                type: Number,
                readOnly: true
            }
        }
    })
], TimePicker);

let DatePicker = class DatePicker extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host(:hover) vi-popup[open] [slot=header], :host vi-popup[hover] [slot=header] {
  background-color: var(--color) !important;
  --vi-icon-fill: white !important;
}
:host header {
  color: white;
  fill: white;
  background-color: var(--color);
}
:host header vi-button {
  text-align: center;
  height: var(--theme-h2);
  min-width: var(--theme-h2);
  line-height: var(--theme-h2);
  cursor: pointer;
}
:host header vi-button > vi-icon {
  height: var(--theme-h2);
  --vi-icon-fill: white;
}
:host header vi-button:hover {
  background-color: var(--color-light);
}
:host main {
  width: calc(var(--theme-h1) * 7);
  height: calc(var(--theme-h1) * 7);
}
:host main .cell {
  border-style: solid;
  border-width: 0 0 1px 1px;
  border-color: var(--color-faint);
  box-sizing: border-box;
  cursor: pointer;
  position: relative;
}
:host main .cell[type$=day] {
  min-width: var(--theme-h1);
  min-height: var(--theme-h1);
  line-height: var(--theme-h2);
  width: var(--theme-h1);
}
:host main .cell[type=day][is-other] {
  color: #AAA;
}
:host main .cell[type=day][is-other]:hover {
  background-color: #eee;
}
:host main .cell[type=day][is-other][is-today] {
  color: white;
  background-color: #bbb;
}
:host main .cell[type=day][is-other][is-today]:hover {
  background-color: #aaa;
  color: var(--color);
}
:host main .cell[type=weekday] {
  font-weight: bold;
  color: #333 !important;
  cursor: default;
}
:host main .cell[type=weekday]:hover {
  background-color: transparent !important;
}
:host main .cell:not([is-other]) {
  color: var(--color);
}
:host main .cell:not([is-other]):hover {
  background-color: var(--color-faint);
}
:host main .cell:not([is-other])[is-today] {
  color: white !important;
  background-color: var(--color-light);
}
:host main .cell:not([is-other])[is-today]:hover {
  background-color: var(--color-lighter);
}
:host main .cell[is-selected]:not([blocked])::before, :host main .cell[is-selected]:not([blocked])::after {
  position: absolute;
  right: 0;
  top: 0;
  content: "";
}
:host main .cell[is-selected]:not([blocked])::before {
  z-index: 2;
  bottom: 0;
  left: 0;
  border: 1px solid var(--color);
}
:host main .cell[is-selected]:not([blocked])[is-other]::before {
  border-color: #777 !important;
}
:host main .cell[is-selected]:not([blocked])[is-other]::after {
  border-top-color: #777 !important;
}
:host main .cell[is-selected]:not([blocked])::after {
  z-index: 1;
  border-left: var(--theme-h4) solid transparent;
  border-top-color: var(--color);
  border-top-width: var(--theme-h4);
  border-top-style: solid;
}
:host main .cell[is-selected]:not([blocked])[is-today]::after {
  border-top-color: white !important;
}
:host main .cell[type$=month], :host main .cell[type$=year] {
  width: 33.3333333333%;
}
:host main .cell[blocked] {
  color: #dedede !important;
  cursor: default !important;
}
:host main .cell[blocked]:hover {
  background-color: transparent !important;
}</style>

<vi-popup id="popup" placement="bottom-end" on-popup-opening="_opening">
    <vi-icon slot="header" part="icon" source="Calendar"></vi-icon>
    <div class="calendar">
        <header class="horizontal layout">
            <vi-button n="-1" on-tap="_fast" hidden$="[[!canFast]]"><vi-icon source="FastBackward"></vi-icon></vi-button>
            <vi-button n="-1" on-tap="_slow"><vi-icon source="Backward"></vi-icon></vi-button>
            <vi-button class="flex" on-tap="_zoomOut" label="[[header]]"></vi-button>
            <vi-button n="1" on-tap="_slow"><vi-icon source="Forward"></vi-icon></vi-button>
            <vi-button n="1" on-tap="_fast" hidden$="[[!canFast]]"><vi-icon source="FastForward"></vi-icon></vi-button>
        </header>
        <main class="layout horizontal wrap" zoom$="[[zoom]]">
            <dom-if if="[[!deferredCellsUpdate]]">
                <template>
                    <dom-repeat items="[[cells]]" as="cell">
                        <template>
                            <div class="cell layout horizontal center-center" type$="[[cell.type]]" is-selected$="[[_isDateSelected(zoom, cell.date, selectedDateMoment)]]" is-today$="[[_isDateToday(zoom, cell.date, today)]]" is-other$="[[_isOtherMonth(cell.monthOffset)]]" blocked$="[[cell.blocked]]" break$="[[cell.break]]" on-tap="_select">[[cell.content]]</div>
                        </template>
                    </dom-repeat>
                </template>
            </dom-if>
        </main>
    </div>
</vi-popup>`; }
    connectedCallback() {
        super.connectedCallback();
        this.zoom = this.monthMode ? "months" : "days";
        this._setToday(moment(new Date()));
        this._setCurrentDate(moment(new Date()));
    }
    get isOpen() {
        return this.$.popup.open;
    }
    _zoomChanged(zoom) {
        if (zoom === "days") {
            let dayNames = CultureInfo.currentCulture.dateFormat.shortDayNames.slice();
            if (CultureInfo.currentCulture.dateFormat.firstDayOfWeek > 0)
                dayNames = dayNames.slice(CultureInfo.currentCulture.dateFormat.firstDayOfWeek).concat(dayNames.slice(0, CultureInfo.currentCulture.dateFormat.firstDayOfWeek));
            const cells = dayNames.map(d => {
                return {
                    type: "weekday",
                    content: d
                };
            });
            cells.push(...Array.range(1, 42).map(d => {
                return { type: "day" };
            }));
            this._setCells(cells);
            this._setCanFast(true);
        }
        else {
            this._setCells(Array.range(1, 12).map(d => {
                return { type: zoom.substr(0, zoom.length - 1) };
            }));
            this._setCanFast(false);
        }
    }
    _render(cells, currentDate, minDate, maxDate, deferredCellsUpdate) {
        if (deferredCellsUpdate)
            return;
        const currentDateMoment = currentDate.clone();
        if (this.zoom === "days") {
            if (cells.length !== 42 + 7)
                return;
            this._setHeader(`${CultureInfo.currentCulture.dateFormat.shortMonthNames[currentDateMoment.month()]} ${currentDateMoment.year()}`);
            const loop = currentDateMoment.startOf("month").startOf(CultureInfo.currentCulture.dateFormat.firstDayOfWeek > 0 ? "isoWeek" : "week");
            const end = loop.clone().add(6, "weeks");
            let index = 7;
            do {
                this.set(`cells.${index}.date`, loop.clone());
                this.set(`cells.${index}.content`, loop.format("D"));
                this.set(`cells.${index}.monthOffset`, loop.isSame(currentDate, "month") ? 0 : (loop.isBefore(currentDate) ? -1 : 1));
                this.set(`cells.${index}.blocked`, this._isBlocked(cells[index], minDate, maxDate));
                index++;
                loop.add(1, "days");
            } while (loop.isBefore(end));
        }
        else if (this.zoom === "months") {
            this._setHeader(`${currentDateMoment.year()}`);
            const loop = currentDateMoment.startOf("year");
            const end = loop.clone().add(12, "months");
            let index = 0;
            do {
                this.set(`cells.${index}.date`, loop.clone());
                this.set(`cells.${index}.content`, CultureInfo.currentCulture.dateFormat.shortMonthNames[index]);
                this.set(`cells.${index}.blocked`, this._isBlocked(cells[index], minDate, maxDate));
                index++;
                loop.add(1, "months");
            } while (loop.isBefore(end));
        }
        else if (this.zoom === "years") {
            const loop = currentDateMoment.startOf("year").subtract(6, "years");
            const end = loop.clone().add(12, "years");
            let index = 0;
            do {
                this.set(`cells.${index}.date`, loop.clone());
                this.set(`cells.${index}.content`, loop.year());
                this.set(`cells.${index}.blocked`, this._isBlocked(cells[index], minDate, maxDate));
                index++;
                loop.add(1, "years");
            } while (loop.isBefore(end));
            this._setHeader(`${cells[0].date.year()} - ${cells[cells.length - 1].date.year()}`);
        }
    }
    _isDateSelected(zoom, date, selectedDate) {
        if (!this.ensureArgumentValues(arguments))
            return undefined;
        if (zoom === "days")
            return date.isSame(selectedDate, "day");
        else if (zoom === "months" && this.monthMode)
            return date.isSame(selectedDate, "month");
        return false;
    }
    _isDateToday(zoom, date, today) {
        if (!this.ensureArgumentValues(arguments))
            return undefined;
        if (zoom === "days")
            return date.isSame(today, "day");
        else if (zoom === "months")
            return date.isSame(today, "month");
        return date.isSame(today, "year");
    }
    _isOtherMonth(monthOffset) {
        return !!monthOffset;
    }
    _isBlocked(cell, minDate, maxDate) {
        const date = cell.date;
        if (!date || (!minDate && !maxDate))
            return false;
        const granularity = this.zoom === "days" ? "day" : (this.zoom === "months" ? "month" : "year");
        return (minDate && date.isBefore(minDate, granularity)) || (maxDate && date.isAfter(maxDate, granularity));
    }
    _computeMoment(date) {
        return moment(date);
    }
    _slow(e) {
        const amount = parseInt(e.currentTarget.getAttribute("n"));
        if (this.zoom === "days")
            this.currentDate.add(amount, "months");
        else if (this.zoom === "months")
            this.currentDate.add(amount, "years");
        else
            this.currentDate.add(amount * 12, "years");
        this._setCurrentDate(this.currentDate.clone());
        e.stopPropagation();
    }
    _fast(e) {
        const amount = parseInt(e.currentTarget.getAttribute("n"));
        this._setCurrentDate(this.currentDate.add(amount, "years").clone());
        e.stopPropagation();
    }
    _zoomOut(e) {
        if (this.zoom === "days")
            this.zoom = "months";
        else if (this.zoom === "months")
            this.zoom = "years";
        e.stopPropagation();
    }
    _select(e) {
        const cell = e.model.cell;
        if (!cell?.date)
            return;
        if (cell.blocked) {
            e.stopPropagation();
            return;
        }
        if (this.zoom === "days") {
            const newSelectedDate = moment(this.selectedDate || new Date());
            if (!this.selectedDate && this.newTime) {
                const newTime = /(\d\d):(\d\d)(:(\d\d))?/.exec(this.newTime);
                if (newTime[1] != null && newTime[2] != null) {
                    newSelectedDate.hours(parseInt(newTime[1]));
                    newSelectedDate.minutes(parseInt(newTime[2]));
                    newSelectedDate.seconds(parseInt(newTime[4] || "0"));
                }
            }
            newSelectedDate.year(cell.date.year());
            newSelectedDate.month(cell.date.month());
            newSelectedDate.date(cell.date.date());
            this.selectedDate = newSelectedDate.clone().toDate();
            if (cell.monthOffset !== 0)
                this._setCurrentDate(this.currentDate.add(cell.monthOffset, "months").clone());
        }
        else if (this.zoom === "months") {
            this._setCurrentDate(this.currentDate.clone().month(cell.date.month()));
            if (!this.monthMode)
                this.zoom = "days";
            else {
                const newSelectedDate = moment(this.selectedDate || new Date());
                newSelectedDate.date(1);
                newSelectedDate.month(cell.date.month());
                newSelectedDate.year(cell.date.year());
                this.selectedDate = newSelectedDate.clone().toDate();
            }
        }
        else if (this.zoom === "years") {
            this._setCurrentDate(this.currentDate.year(cell.date.year()).clone());
            this.zoom = "months";
        }
        e.stopPropagation();
    }
    _opening() {
        this._setCurrentDate(this.selectedDate ? moment(this.selectedDate) : moment(new Date()));
        this.zoom = this.monthMode ? "months" : "days";
        this._setDeferredCellsUpdate(false);
    }
    _catchTap(e) {
        e.stopPropagation();
    }
};
DatePicker = __decorate([
    WebComponent.register({
        properties: {
            zoom: {
                type: String,
                reflectToAttribute: true,
                observer: "_zoomChanged"
            },
            canFast: {
                type: Boolean,
                readOnly: true
            },
            currentDate: {
                type: Object,
                readOnly: true
            },
            selectedDate: {
                type: Object,
                notify: true
            },
            selectedDateMoment: {
                type: Object,
                computed: "_computeMoment(selectedDate)"
            },
            today: {
                type: Object,
                readOnly: true
            },
            monthMode: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            cells: {
                type: Array,
                readOnly: true
            },
            header: {
                type: String,
                readOnly: true
            },
            deferredCellsUpdate: {
                type: Boolean,
                readOnly: true,
                value: true
            },
            minDate: {
                type: Object,
                value: null
            },
            maxDate: {
                type: Object,
                value: null
            },
            newTime: String
        },
        observers: [
            "_render(cells, currentDate, minDate, maxDate, deferredCellsUpdate)"
        ],
        listeners: {
            "tap": "_catchTap"
        }
    })
], DatePicker);

let PersistentObjectAttributeDateTime = class PersistentObjectAttributeDateTime extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host([editing]) [slot=content] {
  display: flex;
  flex-direction: row;
}
:host([editing]) vi-masked-input {
  display: inline-block;
  border: none;
  height: calc(var(--theme-h2) - 2px);
  line-height: calc(var(--theme-h2) - 2px);
  width: auto;
}
:host([editing]) vi-masked-input:not([hidden]) + input {
  padding-left: 0;
}
:host([editing]) vi-masked-input:last-of-type:not([hidden]), :host([editing]) vi-masked-input[flex] {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host([editing][is-invalid]) vi-masked-input::part(input), :host([editing][is-invalid]) span#monthMode {
  color: red;
}
:host span, :host vi-masked-input {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host span#monthMode {
  flex: 1;
  padding: 0 var(--theme-h5);
  cursor: default;
}
:host :is(vi-time-picker, vi-date-picker)::part(icon) {
  width: calc(var(--theme-h2) - 2px);
  height: calc(var(--theme-h2) - 2px);
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <dom-if if="[[!monthMode]]">
                    <template>
                        <vi-masked-input class="date"
                                         format="[[dateFormat]]"
                                         separator="[[dateSeparator]]"
                                         disabled="[[readOnly]]"
                                         tabindex$="[[readOnlyTabIndex]]"
                                         hidden$="[[!hasDateComponent]]"
                                         flex$="[[!hasTimeComponent]]"
                                         on-filled="_dateFilled">
                        </vi-masked-input>
                        <vi-masked-input class="time"
                                         format="[[timeFormat]]"
                                         separator="[[timeSeparator]]"
                                         disabled="[[readOnly]]"
                                         tabindex$="[[readOnlyTabIndex]]"
                                         hidden$="[[!hasTimeComponent]]"
                                         on-filled="_timeFilled">
                        </vi-masked-input>
                    </template>
                </dom-if>
                <dom-if if="[[monthMode]]">
                    <template>
                        <vi-sensitive hidden$="[[!hasDateComponent]]" disabled="[[!sensitive]]">
                            <span id="monthMode">[[attribute.displayValue]]</span>
                        </vi-sensitive>
                    </template>
                </dom-if>
            </vi-sensitive>
            <dom-if if="[[!readOnly]]">
                <template>
                    <dom-if if="[[hasDateComponent]]">
                        <template>
                            <dom-if if="[[monthMode]]">
                                <template>
                                    <vi-button slot="right" on-tap="_previousMonth">
                                        <vi-icon source="ChevronLeft"></vi-icon>
                                    </vi-button>
                                    <vi-button slot="right" on-tap="_nextMonth">
                                        <vi-icon source="ChevronRight"></vi-icon>
                                    </vi-button>
                                </template>
                            </dom-if>
                            <vi-date-picker slot="right" id="datepicker" selected-date="{{selectedDate}}" month-mode="[[monthMode]]" min-date="[[minDate]]" max-date="[[maxDate]]"></vi-date-picker>
                        </template>
                    </dom-if>
                    <dom-if if="[[hasTimeComponent]]">
                        <template>
                            <vi-time-picker slot="right" id="timepicker" time="{{selectedTime}}"></vi-time-picker>
                        </template>
                    </dom-if>
                    <dom-if if="[[canClear]]">
                        <template>
                            <vi-button slot="right" on-tap="_clear" tabindex="-1">
                                <vi-icon source="Remove"></vi-icon>
                            </vi-button>
                        </template>
                    </dom-if>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    get dateInput() {
        if (!this._dateInput) {
            flush$1();
            this._dateInput = this.shadowRoot.querySelector("vi-masked-input.date");
        }
        return this._dateInput;
    }
    get timeInput() {
        if (!this._timeInput) {
            flush$1();
            this._timeInput = this.shadowRoot.querySelector("vi-masked-input.time");
        }
        return this._timeInput;
    }
    focus() {
        if (this.app.activeElement instanceof HTMLInputElement) {
            const input = this.app.activeElement;
            if (input.getRootNode().host === this._timeInput)
                return;
        }
        (this._dateInput || this._timeInput)?.focus();
    }
    _editingChanged() {
        super._editingChanged();
        flush$1();
        if (this.editing)
            this._setIsInvalid(false);
    }
    _valueChanged(value, oldValue) {
        super._valueChanged(value, oldValue);
        try {
            this._valueChangedBlock = true;
            if (this.attribute && value) {
                this.selectedDate = this.attribute.type.contains("Date") ? value : null;
                if (this.attribute.type === "Time" || this.attribute.type === "NullableTime") {
                    const parts = this.value.split(/[:.]/);
                    const startIndex = parts.length - 4;
                    const time = new Date();
                    time.setHours(parseInt(parts[startIndex], 10), parseInt(parts[startIndex + 1], 10), parseInt(parts[startIndex + 2], 10), parseInt(parts[startIndex + 3].substr(0, 3), 10));
                    this.selectedTime = time;
                }
                else
                    this.selectedTime = this.attribute.type.contains("Time") ? value : null;
            }
            else
                this.selectedDate = this.selectedTime = null;
        }
        finally {
            this._setIsInvalid(false);
            this._valueChangedBlock = false;
        }
    }
    _selectedDateChanged(selectedDate, hasDateComponent, hasTimeComponent) {
        if (!this.editing || this.readOnly || !hasDateComponent || this._valueChangedBlock)
            return;
        if (selectedDate) {
            const newValue = new Date(selectedDate.getTime());
            if (this.hasTimeComponent) {
                if (this.selectedTime)
                    newValue.setHours(this.selectedTime.getHours(), this.selectedTime.getMinutes(), this.selectedTime.getSeconds(), this.selectedTime.getMilliseconds());
                else if (typeof this.attribute.typeHints.newtime === "string") {
                    const time = this.attribute.typeHints.newtime.split(/[:.]/);
                    while (time.length < 4)
                        time.push("0");
                    newValue.setHours(parseInt(time[0], 10), parseInt(time[1], 10), parseInt(time[2], 10), parseInt(time[3].substr(0, 3), 10));
                }
            }
            this._guardedSetValue(newValue);
        }
        else
            this._guardedSetValue(null);
    }
    _selectedTimeChanged(selectedTime, hasDateComponent, hasTimeComponent) {
        if (!this.editing || this.readOnly || !hasTimeComponent || this._valueChangedBlock)
            return;
        if (hasDateComponent) {
            if (selectedTime) {
                const newValue = new Date((this.selectedDate || new Date()).getTime());
                newValue.setHours(selectedTime.getHours(), this.selectedTime.getMinutes(), selectedTime.getSeconds(), selectedTime.getMilliseconds());
                this._guardedSetValue(newValue);
            }
        }
        else if (selectedTime) {
            const newTimeValue = String.format("0:{0:D2}:{1:D2}:{2:D2}.{3:D3}0000", selectedTime.getHours(), selectedTime.getMinutes(), selectedTime.getSeconds(), selectedTime.getMilliseconds());
            if (!this.value || this.value.substr(0, newTimeValue.length - 4) !== newTimeValue.substr(0, newTimeValue.length - 4))
                this._guardedSetValue(newTimeValue);
        }
        else
            this._guardedSetValue(null);
    }
    _guardedSetValue(value) {
        if (value instanceof Date) {
            if (this.minDate && value < this.minDate)
                return this._setIsInvalid(true);
            if (this.maxDate && value > this.maxDate)
                return this._setIsInvalid(true);
            if (this.value instanceof Date && value.getTime() === this.value.getTime())
                return;
        }
        else
            this._setIsInvalid(false);
        let allowRefresh = this.monthMode;
        if (!allowRefresh && !this.isInvalid) {
            allowRefresh = value && !this.value;
            if (!allowRefresh) {
                allowRefresh = (this.hasTimeComponent && this.shadowRoot.querySelector("#timepicker").isOpen) || (this.hasDateComponent && this.shadowRoot.querySelector("#datepicker").isOpen);
                if (!allowRefresh)
                    allowRefresh = document.activeElement !== this.dateInput && document.activeElement !== this.timeInput;
            }
        }
        this._pendingRefresh = this.attribute.triggersRefresh && !allowRefresh;
        this.attribute.setValue(value, allowRefresh);
    }
    _renderDate(selectedDate, hasDateComponent, readOnly, editing) {
        if (!editing || !hasDateComponent || this.monthMode)
            return;
        let newDate;
        if (selectedDate)
            newDate = moment(selectedDate).format(CultureInfo.currentCulture.dateFormat.shortDatePattern.toUpperCase());
        else if (!readOnly)
            newDate = this.dateFormat;
        else
            newDate = "—";
        this._setInputValue(this.dateInput, newDate);
    }
    _renderTime(selectedTime, hasDateComponent, hasTimeComponent, readOnly, editing) {
        if (!editing || !hasTimeComponent)
            return;
        let newTime;
        if (selectedTime)
            newTime = String.format(`{0:D2}${CultureInfo.currentCulture.dateFormat.timeSeparator}{1:D2}`, selectedTime.getHours(), selectedTime.getMinutes());
        else if (!readOnly)
            newTime = this.timeFormat;
        else
            newTime = hasDateComponent ? "" : "—";
        this._setInputValue(this.timeInput, newTime);
    }
    _setInputValue(input, value) {
        if (input.value === value)
            return;
        const selection = document.activeElement === input ? { start: 0, end: 0 } : null;
        if (selection != null) {
            selection.start = input.selectionStart;
            selection.end = input.selectionEnd;
        }
        input.value = value;
        if (selection != null) {
            if (selection.start > 0)
                input.selectionStart = selection.start;
            if (selection.end > 0)
                input.selectionEnd = selection.end;
        }
    }
    _clear() {
        this.attribute.setValue(null, true).catch(noop$1);
    }
    _dateFilled() {
        const dateMoment = moment(this.dateInput.value, CultureInfo.currentCulture.dateFormat.shortDatePattern.toUpperCase(), true);
        if (dateMoment.isValid()) {
            this.selectedDate = dateMoment.toDate();
            if (this.hasTimeComponent) {
                this._focusElement(this.timeInput);
                this.timeInput.selectionStart = 0;
                this.timeInput.selectionEnd = this.timeInput.value.length;
            }
        }
        else
            this._setIsInvalid(true);
    }
    _timeFilled() {
        const timeMoment = moment(this.timeInput.value, `HH${CultureInfo.currentCulture.dateFormat.timeSeparator}mm`, true);
        if (timeMoment.isValid())
            this.selectedTime = timeMoment.toDate();
        else
            this._setIsInvalid(true);
    }
    _keydown(e) {
        if (!this.editing || this.readOnly)
            return;
        const input = e.target;
        if (!input.value)
            return;
        if (input === this.timeInput && (e.key === Keys.Backspace || e.key === Keys.ArrowLeft)) {
            if (input.selectionStart === 0 && input.selectionEnd === 0 && this.hasDateComponent) {
                this._focusElement(this.dateInput);
                this.dateInput.selectionStart = this.dateInput.selectionEnd = this.dateInput.value.length;
                e.stopImmediatePropagation();
                e.preventDefault();
                return;
            }
        }
        if (input === this.dateInput && input.value && e.key === Keys.ArrowRight) {
            if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length && this.hasTimeComponent) {
                this._focusElement(this.timeInput);
                this.timeInput.selectionStart = this.timeInput.selectionEnd = 0;
                e.stopImmediatePropagation();
                e.preventDefault();
                return;
            }
        }
        if (e.key === Keys.Backspace && input.selectionStart === 0 && input.selectionEnd === input.value.length) {
            input.value = input === this.dateInput ? this.dateFormat : this.timeFormat;
            input.selectionStart = input.selectionEnd = 0;
        }
    }
    _keyup(e) {
        if (e.key === Keys.Backspace && this.attribute.type.startsWith("Nullable")) {
            if (!this.hasDateComponent || (this.hasDateComponent && this.dateInput.value === this.dateFormat)) {
                if (!this.hasTimeComponent || (this.hasTimeComponent && this.timeInput.value === this.timeFormat))
                    this._guardedSetValue(null);
            }
        }
    }
    _blur(e) {
        if (!this.editing || this.readOnly || e.relatedTarget === this.dateInput || e.relatedTarget === this.timeInput)
            return;
        this._renderDate(this.selectedDate, this.hasDateComponent, this.readOnly, this.editing);
        this._renderTime(this.selectedTime, this.hasDateComponent, this.hasTimeComponent, this.readOnly, this.editing);
        this._setIsInvalid(false);
        if (this._pendingRefresh)
            this._guardedSetValue(this.value);
    }
    _computeHasComponent(target, component) {
        flush$1();
        return target && target.type.contains(component);
    }
    _computeDateFormat() {
        return CultureInfo.currentCulture.dateFormat.shortDatePattern.toLowerCase().replace(/[ymd]/g, "_");
    }
    _computeDateSeparator() {
        return CultureInfo.currentCulture.dateFormat.dateSeparator;
    }
    _computeTimeFormat() {
        return "__" + CultureInfo.currentCulture.dateFormat.timeSeparator + "__";
    }
    _computeTimeSeparator() {
        return CultureInfo.currentCulture.dateFormat.timeSeparator;
    }
    _computeCanClear(value, required) {
        return value != null && !required;
    }
    _computeMonthMode(attribute) {
        return attribute?.getTypeHint("displayformat", "").toLowerCase() === "{0:y}";
    }
    _computeMinMaxDate(attribute, hint) {
        const date = attribute.getTypeHint(hint);
        if (!date)
            return null;
        return moment(date, "YYYY-MM-DD").toDate();
    }
    _previousMonth() {
        const selectedDateMoment = this.selectedDate ? moment(this.selectedDate) : moment().startOf("month");
        const newSelectedDate = selectedDateMoment.subtract(1, "month").toDate();
        if (this.minDate && newSelectedDate < this.minDate)
            return;
        this.selectedDate = newSelectedDate;
    }
    _nextMonth() {
        const selectedDateMoment = this.selectedDate ? moment(this.selectedDate) : moment().startOf("month");
        const newSelectedDate = selectedDateMoment.add(1, "month").toDate();
        if (this.maxDate && newSelectedDate > this.maxDate)
            return;
        this.selectedDate = newSelectedDate;
    }
};
PersistentObjectAttributeDateTime = __decorate([
    WebComponent.register({
        properties: {
            selectedDate: Object,
            selectedTime: Object,
            hasDateComponent: {
                type: Boolean,
                computed: "_computeHasComponent(attribute, 'Date', isConnected)"
            },
            hasTimeComponent: {
                type: Boolean,
                computed: "_computeHasComponent(attribute, 'Time', isConnected)"
            },
            dateFormat: {
                type: String,
                computed: "_computeDateFormat(isConnected)"
            },
            dateSeparator: {
                type: String,
                computed: "_computeDateSeparator(isConnected)"
            },
            timeFormat: {
                type: String,
                computed: "_computeTimeFormat(isConnected)"
            },
            timeSeparator: {
                type: String,
                computed: "_computeTimeSeparator(isConnected)"
            },
            isInvalid: {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true
            },
            canClear: {
                type: Boolean,
                computed: "_computeCanClear(attribute.value, attribute.isRequired)"
            },
            monthMode: {
                type: Boolean,
                computed: "_computeMonthMode(attribute)"
            },
            minDate: {
                type: Object,
                computed: "_computeMinMaxDate(attribute, 'mindate')"
            },
            maxDate: {
                type: Object,
                computed: "_computeMinMaxDate(attribute, 'maxdate')"
            }
        },
        observers: [
            "_selectedDateChanged(selectedDate, hasDateComponent, hasTimeComponent)",
            "_selectedTimeChanged(selectedTime, hasDateComponent, hasTimeComponent)",
            "_renderDate(selectedDate, hasDateComponent, readOnly, editing)",
            "_renderTime(selectedTime, hasDateComponent, hasTimeComponent, readOnly, editing)"
        ],
        forwardObservers: [
            "attribute.typeHints"
        ]
    })
], PersistentObjectAttributeDateTime);
PersistentObjectAttribute.registerAttributeType("DateTime", PersistentObjectAttributeDateTime);

let PersistentObjectAttributeDropDown = class PersistentObjectAttributeDropDown extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host vi-select {
  border: none;
}
:host vi-sensitive, :host vi-select::part(input) {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host #radiobuttons, :host #chips {
  display: flex;
  flex-direction: column;
  line-height: var(--theme-h2);
  gap: var(--theme-h5);
}
:host #radiobuttons[orientation=horizontal], :host #chips[orientation=horizontal] {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
}
:host #chips vi-button[inverse] {
  background-color: var(--color-faint);
}</style>

<dom-if if="[[!showEditable]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[showEditable]]" restamp>
    <template>
        <dom-if if="[[op_areSame(inputtype, 'select')]]" restamp>
            <template>
                <vi-persistent-object-attribute-edit attribute="[[attribute]]">
                    <vi-select options="[[options]]" selected-option="{{value}}" readonly="[[readOnly]]" disabled="[[attribute.parent.isFrozen]]" placeholder="[[placeholder]]" group-separator="[[groupSeparator]]" sensitive$="[[sensitive]]"></vi-select>
                </vi-persistent-object-attribute-edit>
            </template>
        </dom-if>
        <dom-if if="[[op_areSame(inputtype, 'radio')]]" restamp>
            <template>
                <div id="radiobuttons" orientation$="[[orientation]]">
                    <dom-repeat items="[[options]]" as="option">
                        <template>
                            <vi-checkbox label="[[_optionLabel(option)]]" checked="[[_isChecked(option, value)]]" on-changed="_select" radio part="radio"></vi-checkbox>
                        </template>
                    </dom-repeat>
                </div>
            </template>
        </dom-if>
        <dom-if if="[[op_areSame(inputtype, 'chip')]]" restamp>
            <template>
                <div id="chips" orientation$="[[orientation]]">
                    <dom-repeat items="[[options]]" as="option">
                        <template>
                            <vi-button label="[[_optionLabel(option)]]" inverse="[[_isUnchecked(option, value)]]" on-tap="_select" part="chip"></vi-button>
                        </template>
                    </dom-repeat>
                </div>
            </template>
        </dom-if>
    </template>
</dom-if>`; }
    _valueChanged(newValue) {
        if (this.attribute && newValue !== this.attribute.value)
            this.attribute.setValue(newValue, true).catch(noop$1);
    }
    _computeShowEditable(editing, sensitive) {
        return editing && !sensitive;
    }
    _computeInputType(attribute) {
        return attribute && attribute.getTypeHint("inputtype", "select", undefined, true)?.toLowerCase();
    }
    _computeOrientation(attribute) {
        return attribute && attribute.getTypeHint("orientation", "vertical", undefined, true);
    }
    _computeGroupSeparator(attribute) {
        return attribute && attribute.getTypeHint("groupseparator", null, undefined, true);
    }
    _optionLabel(option) {
        return option != null ? option : "—";
    }
    _isChecked(option, value) {
        return option === value || (!option && !value);
    }
    _isUnchecked(option, value) {
        return !this._isChecked(option, value);
    }
    _select(e) {
        e.stopPropagation();
        this.attribute.setValue(e.model.option, true).catch(noop$1);
    }
};
PersistentObjectAttributeDropDown = __decorate([
    WebComponent.register({
        properties: {
            inputtype: {
                type: String,
                computed: "_computeInputType(attribute)"
            },
            orientation: {
                type: String,
                computed: "_computeOrientation(attribute)"
            },
            groupSeparator: {
                type: String,
                computed: "_computeGroupSeparator(attribute)"
            },
            showEditable: {
                type: Boolean,
                computed: "_computeShowEditable(editing, sensitive)"
            },
        }
    })
], PersistentObjectAttributeDropDown);
PersistentObjectAttribute.registerAttributeType("DropDown", PersistentObjectAttributeDropDown);

let PersistentObjectAttributeFlagsEnumFlag = class PersistentObjectAttributeFlagsEnumFlag extends WebComponent {
    static get template() { return html$3 `<vi-checkbox checked="{{checked}}" label="[[label]]"></vi-checkbox>`; }
    _checkedChanged(checked, oldChecked) {
        if (this._skipCheckedChanged || !this.attribute || oldChecked === undefined)
            return;
        const myValue = parseInt(this.option.key);
        if (this.checked && myValue === 0)
            this.attribute.value = this.option.value;
        else {
            const currentOptions = this.attribute.options;
            let currentValue = this.attribute.value ? this._values(this.attribute.value).sum(v => parseInt(currentOptions.find(o => o.value === v).key)) : 0;
            if (this.checked)
                currentValue |= myValue;
            else
                currentValue &= ~myValue;
            const value = [];
            currentOptions.orderByDescending(o => parseInt(o.key)).forEach(option => {
                const optionKey = parseInt(option.key);
                if (optionKey !== 0 && (currentValue & optionKey) === optionKey) {
                    currentValue &= ~optionKey;
                    value.splice(0, 0, option.value);
                }
            });
            if (value.length > 0)
                this.attribute.value = value.join(", ");
            else {
                this.attribute.value = currentOptions.find(o => o.key === "0").value;
                if (myValue === 0)
                    this.checked = true;
            }
        }
    }
    _computeLabel(option) {
        return option.value;
    }
    _valueChanged(value, label) {
        try {
            this._skipCheckedChanged = true;
            const currentOptions = this.attribute.options;
            const currentValue = this.attribute.value ? this._values(this.attribute.value).sum(v => parseInt(currentOptions.find(o => o.value === v).key)) : 0;
            const myValue = parseInt(this.option.key);
            this.checked = (currentValue === 0 && myValue === 0) || (myValue !== 0 && (currentValue & myValue) === myValue);
        }
        finally {
            this._skipCheckedChanged = false;
        }
    }
    _values(value) {
        return value.split(",").map(v => v.trim());
    }
};
PersistentObjectAttributeFlagsEnumFlag = __decorate([
    WebComponent.register({
        properties: {
            attribute: Object,
            checked: {
                type: Boolean,
                notify: true,
                observer: "_checkedChanged",
                value: false
            },
            label: {
                type: String,
                computed: "_computeLabel(option)"
            },
            option: Object,
            value: {
                type: String,
                computed: "attribute.value"
            }
        },
        observers: [
            "_valueChanged(value, label)"
        ],
        forwardObservers: [
            "attribute.value"
        ]
    })
], PersistentObjectAttributeFlagsEnumFlag);

let PersistentObjectAttributeFlagsEnum = class PersistentObjectAttributeFlagsEnum extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
}
:host ul li {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  padding-left: var(--theme-h5);
  line-height: calc(var(--theme-h2) - 2px);
  height: calc(var(--theme-h2) - 2px);
  cursor: pointer;
  overflow: hidden;
}
:host ul li:hover {
  background-color: var(--color-faint);
}
:host ul li vi-checkbox:not([checked]) {
  fill: #aaa;
}
:host input, :host span {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host vi-icon {
  height: calc(var(--theme-h2) - 2px);
  width: calc(var(--theme-h2) - 2px);
  fill: var(--vi-select-icon-color, var(--theme-foreground));
}
:host vi-popup[disabled] vi-icon {
  opacity: 0.25;
  cursor: default;
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-popup sticky disabled$="[[op_some(readOnly, attribute.parent.isFrozen, sensitive)]]" auto-width>
                <div slot="header" class="layout horizontal flex">
                    <vi-sensitive disabled="[[!sensitive]]">
                        <input class="flex" header value="[[attribute.displayValue]]" readonly placeholder="[[placeholder]]">
                    </vi-sensitive>
                    <vi-icon source="CaretDown" hidden$="[[readOnly]]"></vi-icon>
                </div>
                <ul>
                    <dom-repeat items="[[options]]" as="option">
                        <template>
                            <li>
                                <vi-persistent-object-attribute-flags-enum-flag attribute="[[attribute]]" option="[[option]]"></vi-persistent-object-attribute-flags-enum-flag>
                            </li>
                        </template>
                    </dom-repeat>
                </ul>
            </vi-popup>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
};
PersistentObjectAttributeFlagsEnum = __decorate([
    WebComponent.register()
], PersistentObjectAttributeFlagsEnum);
PersistentObjectAttribute.registerAttributeType("FlagsEnum", PersistentObjectAttributeFlagsEnum);

let PersistentObjectAttributeIcon = class PersistentObjectAttributeIcon extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
  outline: none;
}

.icon-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  --vi-icon-width: var(--theme-h2);
  --vi-icon-height: auto;
}
.icon-grid .icon {
  display: flex;
  align-content: center;
  justify-content: center;
  cursor: pointer;
  aspect-ratio: 1/1;
}
.icon-grid .icon:hover {
  background-color: var(--color-faint);
  fill: var(--color);
}
.icon-grid .icon[selected] {
  background: var(--color-semi-faint);
  fill: var(--color);
}

vi-persistent-object-attribute-edit vi-icon {
  aspect-ratio: 1/1;
}

.value {
  gap: var(--theme-h5);
}
.value vi-icon:not([unresolved]) + span {
  line-height: var(--theme-h2);
}</style>

<dom-if if="[[!editing]]">
    <template>
        <div class="layout horizontal value">
            <vi-icon source="[[attribute.displayValue]]"></vi-icon>
            <span>[[attribute.displayValue]]</span>
        </div>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-popup auto-width on-popup-opening="_onOpening">
                <div class="flex layout horizontal value" slot="header">
                    <vi-icon source="[[attribute.value]]"></vi-icon>
                    <input class="flex" value="{{value::input}}"></input>
                </div>
                <vi-scroller>
                    <div class="icon-grid">
                        <dom-repeat items="[[icons]]" as="icon">
                            <template>
                                <div class="icon" on-tap="_selectIcon" selected$="[[op_areSame(icon, value)]]">
                                    <vi-icon source="[[icon]]"></vi-icon>
                                </div>
                            </template>
                        </dom-repeat>
                    </div>
                </vi-scroller>
            </vi-popup>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _onOpening() {
        const icons = all();
        this._setIcons(!this.attribute.isRequired ? [null, ...icons] : icons);
    }
    _selectIcon(e) {
        this.attribute.setValue(e.model.icon);
    }
};
PersistentObjectAttributeIcon = __decorate([
    WebComponent.register({
        properties: {
            icons: {
                type: Array,
                readOnly: true
            }
        }
    })
], PersistentObjectAttributeIcon);
PersistentObjectAttribute.registerAttributeType("Icon", PersistentObjectAttributeIcon);

let PersistentObjectAttributeImageDialog = class PersistentObjectAttributeImageDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host main {
  position: relative;
  overflow: hidden;
  min-width: var(--theme-h1);
  min-height: var(--theme-h1);
}
:host main img {
  margin: var(--theme-h4);
  max-width: calc(90vw - var(--theme-h1) * 2);
  max-height: calc(90vh - var(--vi-persistent-object-attribute-image-dialog--max-height) - var(--theme-h4) * 2);
}
:host main button {
  width: var(--theme-h1);
  height: var(--theme-h1);
  --vi-icon--width: 22px;
  --vi-icon--height: 22px;
}</style>

<header class="relative">
    <vi-size-tracker size="{{headerSize}}"></vi-size-tracker>
    <h4 class="flex">[[label]]</h4>
</header>
<main class="layout horizontal center">
    <vi-spinner id="spinner"></vi-spinner>
    <vi-button class="previous" icon="ChevronLeft" inverse hidden$="[[!hasMultiple]]" on-tap="_previous"></vi-button>
    <img id="img" hidden src$="[[source]]" />
    <vi-button class="next" icon="ChevronRight" inverse hidden$="[[!hasMultiple]]" on-tap="_next"></vi-button>
</main>
<footer class="horizontal layout end-justified relative">
    <vi-size-tracker size="{{footerSize}}"></vi-size-tracker>
    <vi-button on-tap="_close" action-type="Default" label="[[translateMessage('Close', isConnected)]]"></vi-button>
</footer>`); }
    constructor(label, ...sources) {
        super();
        this.label = label;
        this.sources = sources;
        this.source = this.sources[0];
    }
    _showImage(headerSize, footerSize) {
        this.updateStyles({
            "--vi-persistent-object-attribute-image-dialog--max-height": `${headerSize.height + footerSize.height}px`
        });
        if (!this._updated) {
            this.$.img.removeAttribute("hidden");
            this.$.spinner.setAttribute("hidden", "");
            this._updated = true;
        }
    }
    _computeHasMultiple(sources) {
        return sources && sources.length > 1;
    }
    _next() {
        this.source = this.sources[(this.sources.indexOf(this.source) + 1) % this.sources.length];
    }
    _previous() {
        this.source = this.sources[(this.sources.indexOf(this.source) - 1 + this.sources.length) % this.sources.length];
    }
    _close() {
        this.cancel();
    }
};
PersistentObjectAttributeImageDialog = __decorate([
    WebComponent.register({
        properties: {
            label: String,
            sources: Array,
            source: String,
            hasMultiple: {
                type: Boolean,
                computed: "_computeHasMultiple(sources)"
            },
            headerSize: Object,
            footerSize: Object
        },
        keybindings: {
            "left": "_previous",
            "right": "_next"
        },
        observers: [
            "_showImage(headerSize, footerSize)"
        ]
    })
], PersistentObjectAttributeImageDialog);

let PersistentObjectAttributeImage = class PersistentObjectAttributeImage extends PersistentObjectAttribute {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
  outline: none;
}
:host img {
  position: absolute;
  max-height: 100%;
  max-width: 100%;
}
:host img[can-open] {
  cursor: zoom-in;
}
:host .image-container {
  padding: var(--theme-h5);
}
:host .browse input {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  opacity: 0;
  padding: 0;
  margin: 0;
  border: 0;
  cursor: pointer;
}</style>

<dom-if if="[[!editing]]" restamp>
    <template>
        <vi-sensitive class="fit" disabled="[[!sensitive]]">
            <img src="[[image]]" on-tap="_showDialog" can-open$="[[canOpen]]" />
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]" restamp>
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <div class="flex image-container">
                <vi-sensitive disabled="[[!sensitive]]">
                    <img src="[[image]]" on-tap="_showDialog" can-open$="[[canOpen]]" />
                </vi-sensitive>
            </div>
            <dom-if if="[[!readOnly]]">
                <template>
                    <vi-button slot="right" class="browse bottom-border">
                        <vi-icon source="ImageUpload"></vi-icon>
                        <input type="file" accept="image/*" capture="environment" on-change="_change">
                    </vi-button>
                    <dom-if if="[[hasValue]]" restamp>
                        <template>
                            <vi-button slot="right" class="bottom-border" on-tap="_clear" tabindex="-1">
                                <vi-icon source="Remove"></vi-icon>
                            </vi-button>
                        </template>
                    </dom-if>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>

<vi-icon name="ImageUpload">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 19.614079,3.2046995 0,5.909369 c -1.97001,8.3e-4 -3.940507,7.33e-4 -5.910932,0.0016 4.14e-4,1.0920095 4.14e-4,2.1829885 0,3.2749965 1.970425,8.31e-4 3.940922,7.33e-4 5.910932,0.0016 -4.15e-4,1.969598 0,3.939771 0,5.909369 1.092008,8.31e-4 2.184136,-4.09e-4 3.276559,0 4.15e-4,-1.970007 0,-3.939361 0,-5.909369 1.97001,-4.2e-4 3.93936,4.1e-4 5.90937,0 l 0,-3.2765595 c -1.97001,-4.09e-4 -3.93936,0 -5.90937,0 -8.29e-4,-1.970417 9.38e-4,-3.940913 -0.0016,-5.910931 -1.092008,0.0014 -2.182989,-4.2e-4 -3.274997,0 z M 3.2000323,9.1156305 c 7.85e-4,6.5599345 -0.00134,13.1197455 0.00156,19.6796695 6.5628295,-0.0017 13.1262137,-0.0011 19.6890437,-0.0016 4.15e-4,-2.840958 -4.13e-4,-5.681321 0,-8.521868 -1.092421,-8.3e-4 -2.184136,0 -3.276559,0 -4.15e-4,1.748948 -7.33e-4,3.498332 -0.0016,5.246871 l -13.1249883,0 c -8.29e-4,-4.375497 4.15e-4,-8.751465 0,-13.126551 1.7489552,-8.3e-4 3.4979151,-7.32e-4 5.2468703,-0.0016 -4.15e-4,-1.092008 -4.15e-4,-2.182987 0,-3.2749965 -2.8446958,-8.29e-4 -5.6896729,0 -8.5343672,0 z M 16.556269,14.037501 c -0.07676,0.0062 -0.154516,0.01895 -0.229687,0.04062 -0.503907,0.12525 -0.902584,0.575514 -0.965624,1.090625 -0.0647,0.439209 0.117534,0.902441 0.460937,1.18281 0.237231,0.199071 0.548416,0.306562 0.857812,0.301563 0.391514,4.1e-4 0.773292,-0.197269 1.010936,-0.50625 0.294051,-0.36829 0.356917,-0.900426 0.164062,-1.329685 -0.211205,-0.50225 -0.761122,-0.823201 -1.298436,-0.779687 z m -5.476557,0.321875 c -1.0920077,3.281417 -2.1893355,6.561903 -3.279684,9.84374 3.608229,-0.0048 7.21676,0.0023 10.824989,-0.0047 -0.656947,-1.419239 -1.311483,-2.839702 -1.967185,-4.259371 -0.436306,0.876349 -0.873193,1.752721 -1.314061,2.62656 -1.419237,-2.736447 -2.843577,-5.470614 -4.264059,-8.206241 z" />
        </g>
    </svg>
</vi-icon>`; }
    _attributeChanged() {
        if (this._pasteListener) {
            document.removeEventListener("paste", this._pasteListener, false);
            this._pasteListener = null;
        }
        if (this.attribute && this.attribute.getTypeHint("AllowPaste") === "true") {
            this._pasteListener = this._pasteAuto.bind(this);
            document.addEventListener("paste", this._pasteListener, false);
        }
    }
    disconnectedCallback() {
        if (this._pasteListener) {
            document.removeEventListener("paste", this._pasteListener, false);
            this._pasteListener = null;
        }
        super.disconnectedCallback();
    }
    _change(e) {
        this.attribute.parent.queueWork(() => {
            return new Promise((resolve, reject) => {
                if (!(e.target instanceof HTMLInputElement))
                    return;
                if (e.target.files && e.target.files.length === 1) {
                    const fr = new FileReader();
                    fr.readAsDataURL(e.target.files[0]);
                    fr.onload = () => {
                        resolve(this.value = fr.result.match(/,(.*)$/)[1]);
                    };
                    fr.onerror = () => {
                        reject(fr.error);
                    };
                }
            });
        }, true);
    }
    _clear() {
        this.value = null;
    }
    _computeHasValue(value) {
        return !String.isNullOrEmpty(value);
    }
    _computeImage(value) {
        return value ? value.asDataUri() : "";
    }
    _computeCanOpen(hasValue, sensitive) {
        return hasValue && !sensitive;
    }
    _pasteAuto(e) {
        if (this.readOnly || !this.editing)
            return;
        if (e.clipboardData) {
            const items = e.clipboardData.items;
            if (items) {
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") !== -1) {
                        const blob = items[i].getAsFile();
                        const URLObj = window["URL"] || window["webkitURL"];
                        const source = URLObj.createObjectURL(blob);
                        this._pasteCreateImage(source);
                        e.preventDefault();
                    }
                }
            }
        }
    }
    _pasteCreateImage(source) {
        const pastedImage = new Image();
        pastedImage.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = pastedImage.width;
            canvas.height = pastedImage.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(pastedImage, 0, 0);
            this.value = canvas.toDataURL().match(/,(.*)$/)[1];
        };
        pastedImage.src = source;
    }
    _showDialog() {
        if (!this.value || this.sensitive)
            return;
        this.app.showDialog(new PersistentObjectAttributeImageDialog(this.attribute.label, this.value.asDataUri()));
    }
};
PersistentObjectAttributeImage = __decorate([
    WebComponent.register({
        properties: {
            hasValue: {
                type: Boolean,
                computed: "_computeHasValue(value)"
            },
            image: {
                type: String,
                computed: "_computeImage(value)"
            },
            canOpen: {
                type: Boolean,
                computed: "_computeCanOpen(hasValue, sensitive)"
            }
        }
    })
], PersistentObjectAttributeImage);
PersistentObjectAttribute.registerAttributeType("Image", PersistentObjectAttributeImage);

let PersistentObjectAttributeKeyValueList = class PersistentObjectAttributeKeyValueList extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host vi-select {
  border: none;
}
:host span, :host vi-select::part(input) {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host #radiobuttons, :host #chips {
  display: flex;
  flex-direction: column;
  line-height: var(--theme-h2);
  gap: var(--theme-h5);
}
:host #radiobuttons[orientation=horizontal], :host #chips[orientation=horizontal] {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
}
:host #chips vi-button[inverse] {
  background-color: var(--color-faint);
}</style>

<dom-if if="[[!showEditable]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[showEditable]]">
    <template>
        <dom-if if="[[op_areSame(inputtype, 'select')]]" restamp>
            <template>
                <vi-persistent-object-attribute-edit attribute="[[attribute]]">
                    <vi-select options="[[options]]" selected-option="{{value}}" readonly="[[readOnly]]" disabled="[[attribute.parent.isFrozen]]" placeholder="[[placeholder]]" group-separator="[[groupSeparator]]" disable-filtering="[[disableFiltering]]" sensitive$="[[sensitive]]"></vi-select>
                </vi-persistent-object-attribute-edit>
            </template>
        </dom-if>
        <dom-if if="[[op_areSame(inputtype, 'radio')]]" restamp>
            <template>
                <div id="radiobuttons" orientation$="[[orientation]]">
                    <dom-repeat items="[[options]]" as="option">
                        <template>
                            <vi-checkbox label="[[_optionLabel(option)]]" checked="[[_isChecked(option, value)]]" on-changed="_select" radio disabled$="[[attribute.parent.isFrozen]]" part="radio"></vi-checkbox>
                        </template>
                    </dom-repeat>
                </div>
            </template>
        </dom-if>
        <dom-if if="[[op_areSame(inputtype, 'chip')]]" restamp>
            <template>
                <div id="chips" orientation$="[[orientation]]">
                    <dom-repeat items="[[options]]" as="option">
                        <template>
                            <vi-button label="[[_optionLabel(option)]]" inverse="[[_isUnchecked(option, value)]]" on-tap="_select" part="chip"></vi-button>
                        </template>
                    </dom-repeat>
                </div>
            </template>
        </dom-if>
    </template>
</dom-if>`; }
    _valueChanged(newValue) {
        if (this.attribute && newValue !== this.attribute.value)
            this.attribute.setValue(newValue, true).catch(noop$1);
    }
    _computeShowEditable(editing, sensitive) {
        return editing && !sensitive;
    }
    _computeInputType(attribute) {
        return attribute && attribute.getTypeHint("inputtype", "select", undefined, true)?.toLowerCase();
    }
    _computeOrientation(attribute) {
        return attribute && attribute.getTypeHint("orientation", "vertical", undefined, true);
    }
    _computeGroupSeparator(attribute) {
        return attribute && attribute.getTypeHint("groupseparator", null, undefined, true);
    }
    _computeDisableFiltering(attribute) {
        return attribute && attribute.getTypeHint("disablefiltering", null, undefined, true);
    }
    _optionLabel(option) {
        return option?.value || "—";
    }
    _isChecked(option, value) {
        return option == null && value == null || (option && option.key === value);
    }
    _isUnchecked(option, value) {
        return !this._isChecked(option, value);
    }
    _select(e) {
        e.stopPropagation();
        this.attribute.setValue(e.model.option.key, true).catch(noop$1);
    }
};
PersistentObjectAttributeKeyValueList = __decorate([
    WebComponent.register({
        properties: {
            inputtype: {
                type: String,
                computed: "_computeInputType(attribute)"
            },
            orientation: {
                type: String,
                computed: "_computeOrientation(attribute)"
            },
            groupSeparator: {
                type: String,
                computed: "_computeGroupSeparator(attribute)"
            },
            disableFiltering: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeDisableFiltering(attribute)"
            },
            showEditable: {
                type: Boolean,
                computed: "_computeShowEditable(editing, sensitive)"
            },
        }
    })
], PersistentObjectAttributeKeyValueList);
PersistentObjectAttribute.registerAttributeType("KeyValueList", PersistentObjectAttributeKeyValueList);

let PersistentObjectAttributeMultiLineString = class PersistentObjectAttributeMultiLineString extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host textarea {
  resize: none;
  white-space: pre-wrap;
  -ms-overflow-style: -ms-autohiding-scrollbar;
}
:host pre, :host textarea {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host pre {
  white-space: pre-line;
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-scroller no-horizontal class="flex" allow-native>
            <vi-sensitive disabled="[[!sensitive]]">
                <pre>[[attribute.displayValue]]</pre>
            </vi-sensitive>
        </vi-scroller>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <textarea class="flex" value="{{value::input}}" maxlength$="[[maxlength]]" style$="[[editInputStyle]]" on-blur="_editTextAreaBlur" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" placeholder$="[[placeholder]]" disabled="[[frozen]]"></textarea>
            </vi-sensitive>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _attributeChanged() {
        super._attributeChanged();
        if (this.attribute) {
            const maxlength = parseInt(this.attribute.getTypeHint("MaxLength", "0"), 10);
            this.maxlength = maxlength > 0 ? maxlength : null;
        }
    }
    _editTextAreaBlur() {
        if (this.attribute && this.attribute.isValueChanged && this.attribute.triggersRefresh)
            this.attribute.setValue(this.value = this.attribute.value, true).catch(noop$1);
    }
};
PersistentObjectAttributeMultiLineString = __decorate([
    WebComponent.register({
        properties: {
            maxlength: Number
        }
    })
], PersistentObjectAttributeMultiLineString);
PersistentObjectAttribute.registerAttributeType("MultiLineString", PersistentObjectAttributeMultiLineString);

let PersistentObjectAttributeMultiStringItem = class PersistentObjectAttributeMultiStringItem extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  margin-bottom: 2px;
}
:host input {
  border: 1px solid var(--theme-light-border);
  box-sizing: border-box;
  height: var(--theme-h2);
  line-height: var(--theme-h2);
  -moz-transition: border-color 0.2s ease-in-out;
  -o-transition: border-color 0.2s ease-in-out;
  -webkit-transition: border-color 0.2s ease-in-out;
  transition: border-color 0.2s ease-in-out;
  padding: 0 6px;
  outline: none;
}
:host input:focus {
  border-color: var(--color-lighter);
}
:host input:disabled {
  background-color: #eee;
}
:host vi-persistent-object-attribute-edit {
  height: var(--theme-h2);
  line-height: var(--theme-h2);
}
:host vi-icon {
  align-self: center;
  margin-right: var(--theme-h5);
  fill: #666;
  cursor: pointer;
  cursor: -moz-grab;
  cursor: -webkit-grab;
  pointer-events: all;
}
:host vi-icon[disabled] {
  fill: #aaa;
}
:host([is-new]) vi-icon {
  visibility: hidden;
}
:host([is-new]) input {
  border-style: dashed;
}
:host([is-new]) vi-persistent-object-attribute-edit {
  border: none !important;
}
:host([is-read-only]) vi-icon {
  display: none;
}
:host([is-read-only]) input {
  background-color: var(--theme-read-only);
}</style>

<vi-icon source="Hamburger" class="sort-handle" part="icon" hidden$="[[sensitive]]" disabled$="[[disabled]]"></vi-icon>
<vi-sensitive disabled="[[!sensitive]]">
    <input content class="flex" value="{{value::input}}" on-blur="_onInputBlur" type="text" readonly$="[[isReadOnly]]" tabindex$="[[readOnlyTabIndex]]" disabled$="[[disabled]]" placeholder="[[placeholder]]">
</vi-sensitive>`; }
    constructor(value) {
        super();
        this.value = value;
    }
    connectedCallback() {
        super.connectedCallback();
        this._setInput(this.shadowRoot.querySelector("input"));
        if (this._focusQueued) {
            this._focusQueued = false;
            this._focusElement(this.input);
        }
    }
    focus() {
        this.shadowRoot.querySelector("input")?.focus();
    }
    queueFocus() {
        this._focusQueued = true;
    }
    _valueChanged(value) {
        if (this.isReadOnly)
            return;
        if (this.isNew) {
            if (value) {
                this.fire("multi-string-item-value-new", { value: value });
                this.value = "";
            }
        }
        else
            this.fire("multi-string-item-value-changed", null);
    }
    _onInputBlur() {
        if (!this.isReadOnly && !this.isNew)
            this.fire("multi-string-item-value-changed", null);
    }
};
PersistentObjectAttributeMultiStringItem = __decorate([
    WebComponent.register({
        properties: {
            value: {
                type: String,
                observer: "_valueChanged"
            },
            isReadOnly: {
                type: Boolean,
                reflectToAttribute: true
            },
            input: {
                type: Object,
                readOnly: true
            },
            isNew: {
                type: Boolean,
                reflectToAttribute: true
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true
            },
            placeholder: String,
            sensitive: Boolean
        }
    })
], PersistentObjectAttributeMultiStringItem);

let Tags = class Tags extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
}
:host .wrapContainer {
  flex-wrap: wrap;
}
:host(:not([readonly])) {
  cursor: text;
}
:host input {
  border: none;
  outline: none;
  max-width: 250px;
  width: var(--tags-input--width, 30px);
  min-width: 8px;
}
:host .tag {
  margin: 0 4px 4px 0;
  background-color: var(--color);
  color: white;
  border-radius: var(--theme-h5);
  text-align: center;
  justify-content: center;
}
:host .tag .tagValue {
  margin-left: 8px;
  margin-right: 8px;
  max-width: 250px;
  overflow: hidden;
  text-overflow: ellipsis;
}
:host .tag .delete {
  padding: 5px 5px 3px 0;
  cursor: pointer;
  fill: white;
}</style>

<vi-scroller id="scroller" class="flex" editing$="[[editing]]" no-horizontal on-tap="_passFocus">
    <div class="layout horizontal wrapContainer">
        <dom-repeat items="[[tags]]" as="tag">
            <template>
                <div class="layout horizontal tag">
                    <vi-sensitive disabled="[[!sensitive]]"><span class="tagValue">[[tag]]</span></vi-sensitive>
                    <div on-tap="_onDeleteTap" class="delete" hidden$="[[readonly]]">
                        <vi-icon source="Remove"></vi-icon>
                    </div>
                </div>
            </template>
        </dom-repeat>
        <input id="tagsInput" type="text" value="{{input::input}}" on-keyup="_checkKeyPress" on-blur="_onInputBlur" hidden$="[[readonly]]" />
    </div>
</vi-scroller>`; }
    focus() {
        this.$.tagsInput.focus();
    }
    _passFocus(e) {
        if (this.readonly)
            return;
        const input = this.shadowRoot.querySelector("input");
        if (!input)
            return;
        input.focus();
        const scroller = this.$.scroller;
        scroller.scrollToBottom();
    }
    _checkKeyPress(e) {
        if (!this.input)
            return;
        if (e.key === Keys.Enter)
            this._addTag(this.input);
        else {
            const newWidth = (this.input.length * 8) + 30;
            this.updateStyles({ "--tags-input--width": `${newWidth}px` });
        }
    }
    _onInputBlur() {
        if (!this.input || this.readonly) {
            this.input = "";
            return;
        }
        this._addTag(this.input);
    }
    _addTag(input) {
        if (!((/^\s*$/.test(input)))) {
            this.push("tags", input);
            this.input = undefined;
            this.updateStyles({ "--tags-input--width": "30px" });
        }
        else
            this.input = undefined;
    }
    _onDeleteTap(e) {
        this.splice("tags", this.tags.indexOf(e.model.tag), 1);
    }
};
Tags = __decorate([
    WebComponent.register({
        properties: {
            input: String,
            tags: Array,
            readonly: {
                type: Boolean,
                reflectToAttribute: true
            },
            sensitive: {
                type: Boolean,
                reflectToAttribute: true,
                value: true
            }
        }
    })
], Tags);

let PersistentObjectAttributeMultiStringItems = class PersistentObjectAttributeMultiStringItems extends Sortable {
    _dragEnd() {
        this.fire("reorder-strings", {}, { bubbles: true });
    }
};
PersistentObjectAttributeMultiStringItems = __decorate([
    WebComponent.register()
], PersistentObjectAttributeMultiStringItems);
let PersistentObjectAttributeMultiString = class PersistentObjectAttributeMultiString extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host #strings:empty {
  background-color: red;
}
:host #strings:empty + vi-persistent-object-attribute-multi-string-item::part(icon) {
  display: none;
}
:host #strings:not([enabled]) > vi-persistent-object-attribute-multi-string-item ::content vi-icon[source=Hamburger] {
  opacity: 0.25;
  cursor: default;
}
:host fieldset {
  padding: 0;
  margin: 0;
  border: none;
}
:host vi-persistent-object-attribute-edit vi-tags {
  margin: 4px 0 0 4px;
}
:host vi-tags {
  line-height: calc(var(--theme-h2) - 4px);
}
:host #suggestions ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
:host #suggestions ul li {
  padding: 0 var(--theme-h4);
  text-align: left;
}
:host #suggestions ul li:hover {
  background-color: var(--color-faint);
}</style>

<dom-if if="[[!isTags]]">
    <template>
        <dom-if if="[[!editing]]">
            <template>
                <vi-scroller no-horizontal class="flex">
                    <vi-sensitive disabled="[[!sensitive]]">
                        <pre>[[attribute.displayValue]]</pre>
                    </vi-sensitive>
                </vi-scroller>
            </template>
        </dom-if>
        <dom-if if="[[editing]]">
            <template>
                <vi-scroller no-horizontal class="flex">
                    <vi-persistent-object-attribute-multi-string-items id="strings" draggable-items="vi-persistent-object-attribute-multi-string-item" handle=".sort-handle" enabled="[[!attribute.parent.isFrozen]]" sensitive="[[sensitive]]" disabled="[[frozen]]"></vi-persistent-object-attribute-multi-string-items>
                    <vi-persistent-object-attribute-multi-string-item disabled="[[frozen]]" is-new hidden$="[[readOnly]]" placeholder="[[placeholder]]" sensitive="[[sensitive]]"></vi-persistent-object-attribute-multi-string-item>
                </vi-scroller>
                <vi-persistent-object-attribute-validation-error attribute="[[attribute]]"></vi-persistent-object-attribute-validation-error>
            </template>
        </dom-if>
    </template>
</dom-if>
<dom-if if="[[isTags]]">
    <template>
        <dom-if if="[[!editing]]">
            <template>
                <vi-tags content class="flex" tags="{{tags}}" readonly sensitive="[[sensitive]]"></vi-tags>
            </template>
        </dom-if>
        <dom-if if="[[editing]]">
            <template>
                <vi-persistent-object-attribute-edit attribute="[[attribute]]">
                    <vi-tags content tags="{{tags}}" readonly="[[isTagsReadonly]]" sensitive="[[sensitive]]"></vi-tags>
                    <dom-if if="[[hasSuggestions]]">
                        <template>
                            <vi-popup id="suggestions" slot="right">
                                <vi-icon source="Add" slot="header"></vi-icon>
                                <vi-scroller>
                                    <ul>
                                        <dom-repeat items="[[filteredSuggestions]]" as="suggestion">
                                            <template>
                                                <li on-tap="_addSuggestionTag">[[suggestion]]</li>
                                            </template>
                                        </dom-repeat>
                                    </ul>
                                </vi-scroller>
                            </vi-popup>
                        </template>
                    </dom-if>
                </vi-persistent-object-attribute-edit>
            </template>
        </dom-if>
    </template>
</dom-if>`; }
    focus() {
        if (Array.from(this.shadowRoot.querySelectorAll("vi-persistent-object-attribute-multi-string-item")).some(str => str.shadowRoot?.contains(this.app.activeElement)))
            return;
        if (!this.isTags)
            this.shadowRoot.querySelector("vi-persistent-object-attribute-multi-string-item")?.focus();
        else
            this.shadowRoot.querySelector("vi-tags")?.focus();
    }
    _computeStrings(value, readOnly, sensitive) {
        const strings = value ? value.split("\n").filter(v => !!v.length).map((v, n) => this.strings && this.strings[n] && this.strings[n].value === v ? this.strings[n] : new PersistentObjectAttributeMultiStringItem(v)) : [];
        strings.forEach(s => {
            s.isReadOnly = readOnly || sensitive;
            s.sensitive = sensitive;
        });
        return strings;
    }
    _itemValueNew(e) {
        const { value } = e.detail;
        this.value = `${this.value || ""}\n${value}`;
        flush$1();
        this._focusElement(this.strings[this.strings.length - 1].input);
        e.stopPropagation();
    }
    _itemsOrderChanged() {
        const stringsContainer = this.shadowRoot.querySelector("#strings");
        this.value = Array.from(stringsContainer.children).filter((i) => !!i.value).map((i) => i.value).join("\n");
    }
    _itemValueChanged(e) {
        this.value = this.strings.filter(s => !!s.value).map(s => s.value).join("\n");
        e.stopPropagation();
    }
    _render(strings, editing, isConnected) {
        if (!editing || !isConnected || this.isTags)
            return;
        flush$1();
        const stringsContainer = this.shadowRoot.querySelector("#strings");
        if (stringsContainer.children.length !== strings.length || strings.some((s, n) => stringsContainer.children[n] !== s))
            strings.forEach((s) => stringsContainer.appendChild(s));
        Array.from(stringsContainer.children).forEach((c) => {
            if (strings.indexOf(c) < 0)
                stringsContainer.removeChild(c);
        });
    }
    _computeIsTags(attribute) {
        return attribute && attribute.getTypeHint("inputtype", undefined, undefined, true) === "tags";
    }
    _valueChanged(newValue, oldValue) {
        super._valueChanged(newValue, oldValue);
        if (!newValue)
            this.tags = [];
        else
            this.tags = newValue.split("\n").filter(v => !!v.length);
    }
    _onTagsChanged(isTags) {
        if (!this.isTags || !this.tags || !this.editing)
            return;
        const newValue = this.tags.filter(t => !!t).join("\n");
        if (this.value !== newValue)
            this.value = newValue;
    }
    _onFrozenChanged(frozen) {
        this.strings?.forEach(str => str.toggleAttribute("disabled", frozen));
    }
    _computeTagSuggestions(attribute) {
        if (!attribute || !attribute.options || !attribute.options.length)
            return null;
        return this.attribute.options.filter(o => !String.isNullOrEmpty(o));
    }
    _computeHasTagSuggestions(suggestions, editing, readOnly) {
        return editing && !readOnly && suggestions && suggestions.length > 0;
    }
    _computeFilteredSuggestions(suggestions, strings) {
        if (!suggestions || suggestions.length === 0)
            return [];
        const currentStrings = strings.map(s => s.value);
        return suggestions.filter(s => currentStrings.indexOf(s) < 0);
    }
    _computeIsTagsReadonly(readOnly, editing, frozen) {
        return readOnly || !editing || frozen;
    }
    _addSuggestionTag(e) {
        this.value = `${this.value}\n${e.model.suggestion}`;
    }
};
PersistentObjectAttributeMultiString = __decorate([
    WebComponent.register({
        properties: {
            maxlength: Number,
            strings: {
                type: Array,
                computed: "_computeStrings(value, attribute.isReadOnly, sensitive)"
            },
            isTags: {
                type: Boolean,
                computed: "_computeIsTags(attribute)"
            },
            tags: {
                type: Array
            },
            suggestions: {
                type: Array,
                computed: "_computeTagSuggestions(attribute)"
            },
            hasSuggestions: {
                type: Boolean,
                computed: "_computeHasTagSuggestions(filteredSuggestions, editing, readOnly)"
            },
            filteredSuggestions: {
                type: Array,
                computed: "_computeFilteredSuggestions(suggestions, strings)"
            },
            isTagsReadonly: {
                type: Boolean,
                computed: "_computeIsTagsReadonly(readOnly, editing, frozen)"
            }
        },
        observers: [
            "_render(strings, editing, isConnected)",
            "_onTagsChanged(isTags, tags.*)",
            "_onFrozenChanged(frozen)"
        ],
        listeners: {
            "multi-string-item-value-new": "_itemValueNew",
            "multi-string-item-value-changed": "_itemValueChanged",
            "reorder-strings": "_itemsOrderChanged"
        },
        forwardObservers: [
            "attribute.isReadOnly"
        ]
    })
], PersistentObjectAttributeMultiString);
PersistentObjectAttribute.registerAttributeType("MultiString", PersistentObjectAttributeMultiString);

let PersistentObjectAttributeNullableBoolean = class PersistentObjectAttributeNullableBoolean extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: row;
  line-height: normal;
}
:host vi-checkbox {
  display: inline-block;
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}

:host-context(vi-persistent-object-attribute-as-detail) {
  border: 1px solid var(--theme-light-border);
  margin: 0 1px;
  padding: 0 var(--theme-h5);
  line-height: var(--theme-h2);
}

:host {
  display: flex;
  flex-direction: row;
}
:host vi-select {
  border: none;
}
:host vi-select::part(input) {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}</style>

<dom-if if="[[!editing]]" restamp>
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-select options="[[booleanOptions]]" selected-option="{{value}}" sensitive="[[sensitive]]" disable-filtering readonly="[[readOnly]]" disabled="[[op_some(attribute.isReadOnly, attribute.parent.isFrozen)]]" placeholder="[[placeholder]]"></vi-select>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _computeBooleanOptions(attribute) {
        const options = attribute.type.startsWith("Nullable") ? [
            {
                key: null,
                value: ""
            }
        ] : [];
        return options.concat([
            {
                key: true,
                value: this.translations[this.attribute.getTypeHint("TrueKey", "Yes")]
            },
            {
                key: false,
                value: this.translations[this.attribute.getTypeHint("FalseKey", "No")]
            }
        ]);
    }
    _valueChanged(newValue) {
        if (this.attribute && newValue !== this.attribute.value)
            this.attribute.setValue(newValue, true).catch(noop$1);
    }
    _notNull(value) {
        return value != null;
    }
    _isDisabled(isReadOnly, isFrozen) {
        return isReadOnly || isFrozen;
    }
};
PersistentObjectAttributeNullableBoolean = __decorate([
    WebComponent.register({
        properties: {
            booleanOptions: {
                type: Array,
                computed: "_computeBooleanOptions(attribute, translations)"
            }
        }
    })
], PersistentObjectAttributeNullableBoolean);
PersistentObjectAttribute.registerAttributeType("NullableBoolean", PersistentObjectAttributeNullableBoolean);

var PersistentObjectAttributeNumeric_1;
let PersistentObjectAttributeNumeric = PersistentObjectAttributeNumeric_1 = class PersistentObjectAttributeNumeric extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host span, :host input {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host vi-persistent-object-attribute-edit span {
  position: relative;
  width: calc(var(--theme-h2) - 2px);
  text-align: center;
  cursor: default;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host vi-persistent-object-attribute-edit span:before, :host vi-persistent-object-attribute-edit span:after {
  position: absolute;
  top: 4px;
  bottom: 4px;
  content: " ";
  transition: all 0.1s ease-in-out;
}
:host vi-persistent-object-attribute-edit span.before:before {
  right: 0;
  border-right: 1px solid var(--theme-light-border);
}
:host vi-persistent-object-attribute-edit span.after:after {
  left: 0;
  border-left: 1px solid var(--theme-light-border);
}
:host vi-persistent-object-attribute-edit span:hover:before, :host vi-persistent-object-attribute-edit span:hover:after {
  top: 0;
  bottom: 0;
}
:host vi-persistent-object-attribute-edit span:empty {
  display: none;
}
:host([focused]) vi-persistent-object-attribute-edit span:before, :host([focused]) vi-persistent-object-attribute-edit span:after {
  border-color: var(--color-lighter);
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[attribute.displayValue]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <slot name="left" slot="left"></slot>
            <div class="layout horizontal">
                <span class="before" hidden$="[[!unitBefore]]">[[unitBefore]]</span>
                <vi-sensitive disabled="[[!sensitive]]">
                    <input class="flex" value="{{value::input}}" type$="[[inputtype]]" on-keypress="_keypress" on-focus="_editInputFocus" on-blur="_editInputBlur" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" placeholder="[[placeholder]]" disabled="[[frozen]]">
                </vi-sensitive>
                <span class="after" hidden$="[[!unitAfter]]">[[unitAfter]]</span>
            </div>
            <slot name="right" slot="right"></slot>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _attributeChanged() {
        super._attributeChanged();
        if (this.attribute) {
            this._allowDecimal = PersistentObjectAttributeNumeric_1._decimalTypes.indexOf(numericSynonyms[this.attribute.type] || this.attribute.type) >= 0;
            this._isNullable = (numericSynonyms[this.attribute.type] || this.attribute.type).startsWith("Nullable") && !this.attribute.parent.isBulkEdit;
            this._decimalSeparator = CultureInfo.currentCulture.numberFormat.numberDecimalSeparator;
            const displayFormat = this.attribute.getTypeHint("displayformat", null, null, true);
            if (displayFormat) {
                const groups = /^([^{]*)({.+?})(.*)$/.exec(displayFormat);
                this.unitBefore = groups[1];
                this.unitAfter = groups[3];
            }
            const inputtype = this.attribute.getTypeHint("inputtype", null, null, true);
            if (inputtype)
                this._setInputtype(inputtype);
        }
    }
    _attributeValueChanged() {
        if (this.attribute.value == null) {
            this.value = "";
            return;
        }
        const attributeValue = this.attribute.value.toString();
        let myValue = this.value;
        if (this.value && this._decimalSeparator !== ".")
            myValue = this.value.replace(this._decimalSeparator, ".");
        if (this.focused) {
            if (myValue === "" || myValue === "-")
                myValue = this.attribute.isRequired && !this._isNullable ? "0" : "";
            else if (myValue.endsWith("."))
                myValue = myValue.trimEnd(".");
        }
        if (!!myValue && this._canParse(myValue) && new BigNumber(myValue).eq(this.attribute.value))
            return;
        if (this._decimalSeparator !== ".")
            this.value = attributeValue.replace(".", this._decimalSeparator);
        else
            this.value = attributeValue;
    }
    async _valueChanged(newValue, oldValue) {
        if (!this.attribute)
            return;
        if (newValue === undefined)
            return;
        if (newValue != null && this._decimalSeparator !== ".")
            newValue = newValue.replace(this._decimalSeparator, ".");
        try {
            if (this.focused) {
                if (newValue === "" || newValue === "-")
                    newValue = this.attribute.isRequired && !this._isNullable ? "0" : "";
                else if (newValue.endsWith("."))
                    newValue = newValue.trimEnd(".");
            }
            if (!this._canParse(newValue)) {
                this.value = oldValue;
                return;
            }
            const bigNumberValue = !String.isNullOrEmpty(newValue) ? new BigNumber(newValue) : null;
            if (this.attribute.value instanceof BigNumber && bigNumberValue != null && bigNumberValue.eq(this.attribute.value))
                return;
            await this.attribute.setValue(bigNumberValue, false).catch(noop$1);
        }
        catch (e) {
            this.notifyPath("value", this.attribute.value);
        }
    }
    _editInputBlur(e) {
        this._setFocused(false);
        if (!this.attribute)
            return;
        if (this.attribute.isValueChanged && this.attribute.triggersRefresh) {
            let newValue = this.value;
            if (newValue != null && this._decimalSeparator !== ".")
                newValue = newValue.replace(this._decimalSeparator, ".");
            this.attribute.value = newValue;
        }
        let attributeValue = this.attribute.value ? this.attribute.value.toString() : ((this.attribute.isRequired && !this._isNullable) || this.value ? "0" : "");
        if (attributeValue !== this.value) {
            if (this._decimalSeparator !== ".")
                this.value = attributeValue.replace(".", this._decimalSeparator);
            else
                this.value = attributeValue;
        }
    }
    _editInputFocus(e) {
        this._setFocused(true);
        const input = e.target;
        if (!input.value || !this.attribute.getTypeHint("SelectAllOnFocus"))
            return;
        input.selectionStart = 0;
        input.selectionEnd = input.value.length;
    }
    _canParse(value) {
        if (!value && this._isNullable)
            return true;
        if (value && value.startsWith(this._decimalSeparator))
            value = `0${value}`;
        switch (numericSynonyms[this.attribute.type] || this.attribute.type) {
            case "Byte":
            case "NullableByte":
                return this._between(parseInt(value, 10), 0, 255);
            case "SByte":
            case "NullableSByte":
                return this._between(parseInt(value, 10), -128, 127);
            case "Int16":
            case "NullableInt16":
                return this._between(parseInt(value, 10), -32768, 32767);
            case "UInt16":
            case "NullableUInt16":
                return this._between(parseInt(value, 10), 0, 65535);
            case "Int32":
            case "NullableInt32":
                return this._between(parseInt(value, 10), -2147483648, 2147483647);
            case "UInt32":
            case "NullableUInt32":
                return this._between(parseFloat(value), 0, 4294967295);
            case "Int64":
            case "NullableInt64":
                return this._between(parseFloat(value), -9223372036854775808, 9223372036854775807);
            case "UInt64":
            case "NullableUInt64":
                return this._between(parseFloat(value), 0, 18446744073709551615);
            case "Decimal":
            case "NullableDecimal":
                return this._between(parseFloat(value), -79228162514264337593543950335, 79228162514264337593543950335);
            case "Single":
            case "NullableSingle":
                return this._between(parseFloat(value), -3.40282347E+38, 3.40282347E+38);
            case "Double":
            case "NullableDouble":
                return this._between(parseFloat(value), -1.7976931348623157E+308, 1.7976931348623157E+308);
            default:
                return false;
        }
    }
    _between(value, minValue, maxValue) {
        return !isNaN(value) && value >= minValue && value <= maxValue;
    }
    _setCarretIndex(input, carretIndex) {
        input.selectionEnd = carretIndex;
        input.selectionStart = carretIndex;
    }
    _keypress(e) {
        e.key;
        if (e.key === Keys.Tab || e.key === Keys.Shift || e.key === Keys.Control || e.key === Keys.Alt || e.key === Keys.ArrowLeft || e.key === Keys.ArrowRight || e.key === Keys.ArrowUp || e.key === Keys.ArrowDown || e.key === Keys.Backspace)
            return;
        const input = e.target;
        let value = input.value;
        const carretIndex = input.selectionStart;
        if (input.selectionEnd !== carretIndex)
            value = value.slice(0, Math.min(input.selectionEnd, carretIndex)) + value.slice(Math.max(input.selectionEnd, carretIndex));
        if (e.key.length === 1 && /^\d+$/.test(e.key)) {
            if (!this._canParse(value.insert(e.key, carretIndex)))
                e.preventDefault();
        }
        else {
            if ((e.key === Keys.Comma || e.key === Keys.Period) && !value.contains(this._decimalSeparator) && this._allowDecimal) {
                this.value = input.value = value.insert(this._decimalSeparator, carretIndex);
                this._setCarretIndex(input, carretIndex + 1);
            }
            else if (e.key === Keys.Subtract && !value.contains("-") && carretIndex === 0 && PersistentObjectAttributeNumeric_1._unsignedTypes.indexOf(numericSynonyms[this.attribute.type] || this.attribute.type) === -1) {
                this.value = input.value = value.insert("-", carretIndex);
                this._setCarretIndex(input, carretIndex + 1);
            }
            e.preventDefault();
        }
    }
    _computeDisplayValueWithUnit(value, displayValue, unit, unitPosition) {
        let result = value != null && unit && unitPosition && unitPosition.toLowerCase() === "before" ? unit + " " : "";
        result += displayValue;
        result += value != null && unit && unitPosition && unitPosition.toLowerCase() === "after" ? " " + unit : "";
        return result;
    }
    _computeBeforeUnit(unit, position, value, hideOnNoValue) {
        if (!unit || !position)
            return unit;
        if (hideOnNoValue && !value)
            return "";
        return position === "before" ? unit : "";
    }
    _computeAfterUnit(unit, position) {
        if (!unit || !position)
            return unit;
        return position === "after" ? unit : "";
    }
    static registerNumericAttributeType(attributeType, numericType) {
        numericSynonyms[attributeType] = numericType;
    }
};
PersistentObjectAttributeNumeric._decimalTypes = ["NullableDecimal", "Decimal", "NullableSingle", "Single", "NullableDouble", "Double"];
PersistentObjectAttributeNumeric._unsignedTypes = ["Byte", "NullableByte", "UInt16", "NullableUInt16", "UInt32", "NullableUInt32", "UInt64", "NullableUInt64"];
PersistentObjectAttributeNumeric = PersistentObjectAttributeNumeric_1 = __decorate([
    WebComponent.register({
        properties: {
            inputtype: {
                type: String,
                readOnly: true
            },
            unitBefore: {
                type: String,
                reflectToAttribute: true,
                value: null
            },
            unitAfter: {
                type: String,
                reflectToAttribute: true,
                value: null
            },
            focused: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            }
        }
    })
], PersistentObjectAttributeNumeric);
PersistentObjectAttribute.registerAttributeType("Numeric", PersistentObjectAttributeNumeric);
const numericSynonyms = {};

let PersistentObjectAttributePassword = class PersistentObjectAttributePassword extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host span, :host input {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>&#x25cf;&#x25cf;&#x25cf;&#x25cf;&#x25cf;&#x25cf;</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <input class="flex" value="{{value::input}}" type="password" autocomplete$="[[autocomplete]]" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" on-blur="_editInputBlur" placeholder="[[placeholder]]">
            </vi-sensitive>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _attributeChanged() {
        super._attributeChanged();
        if (this.attribute instanceof PersistentObjectAttribute$1) {
            this._setAutocomplete(this.attribute.getTypeHint("Autocomplete"));
        }
    }
    _editInputBlur() {
        if (this.attribute && this.attribute.isValueChanged && this.attribute.triggersRefresh)
            this.attribute.setValue(this.value = this.attribute.value, true).catch(noop$1);
    }
};
PersistentObjectAttributePassword = __decorate([
    WebComponent.register({
        properties: {
            autocomplete: {
                type: String,
                readOnly: true
            }
        }
    })
], PersistentObjectAttributePassword);
PersistentObjectAttribute.registerAttributeType("Password", PersistentObjectAttributePassword);

let PersistentObjectAttributeReference = class PersistentObjectAttributeReference extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
}
:host input, :host vi-select::part(input) {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host vi-select::part(icon) {
  display: none;
}
:host(:not([editing])) {
  overflow: hidden;
}
:host(:not([editing])) a {
  display: flex;
  flex-direction: row;
  text-decoration: none;
  color: var(--vi-persistent-object-attribute-foreground, var(--color));
  fill: var(--vi-persistent-object-attribute-foreground, var(--color));
  overflow: hidden;
  text-overflow: ellipsis;
}
:host(:not([editing])) a:focus {
  outline: 0;
}
:host(:not([editing])) a:visited {
  color: var(--vi-persistent-object-attribute-foreground, var(--color));
  fill: var(--vi-persistent-object-attribute-foreground, var(--color));
}
:host(:not([editing])) a:hover {
  color: var(--vi-persistent-object-attribute-foreground, var(--color-light));
  fill: var(--vi-persistent-object-attribute-foreground, var(--color-light));
}
:host(:not([editing])) a[disabled] {
  color: var(--vi-persistent-object-attribute-foreground, #333) !important;
}
:host(:not([editing])) a span {
  text-overflow: ellipsis;
  overflow: hidden;
}
:host(:not([editing])) a vi-icon {
  margin: 0 var(--theme-h5);
  min-width: var(--theme-h4);
  height: 1em;
  fill: var(--color);
  transform: translateY(2px);
}
:host([editing]) vi-select {
  border: none;
}
:host([editing]) vi-select vi-popup > #content {
  transform: translateY(1px);
}
:host([editing]) a[disabled] {
  display: none;
}
:host([editing]) a vi-icon {
  height: 100%;
}
:host #radiobuttons, :host #chips {
  display: flex;
  flex-direction: column;
  line-height: var(--theme-h2);
  gap: var(--theme-h5);
}
:host #radiobuttons[orientation=horizontal], :host #chips[orientation=horizontal] {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
}
:host #chips vi-button[inverse] {
  background-color: var(--color-faint);
}</style>

<dom-if if="[[!editing]]">
    <template>
        <a href$="[[href]]" title$="[[title]]" disabled$="[[!href]]" on-tap="_open" target$="[[target]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <span>[[attribute.displayValue]]</span>
            </vi-sensitive>
            <dom-if if="[[href]]">
                <template>
                    <vi-icon source="ArrowUpRight" class="size-h4"></vi-icon>
                </template>
            </dom-if>
            <div class="spacer"></div>
        </a>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <dom-if if="[[attribute.selectInPlace]]">
            <template>
                <dom-if if="[[op_areSame(inputtype, 'default')]]">
                    <template>
                        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
                            <vi-select id="selectInPlace" class="fit" options="[[options]]" selected-option="{{objectId}}" readonly$="[[readOnly]]" placeholder="[[placeholder]]" sensitive="[[sensitive]]" disabled="[[frozen]]"></vi-select>
                            <vi-button slot="right" on-tap="_openSelect" hidden$="[[!canOpenSelect]]" tabindex="-1" disabled="[[frozen]]">
                                <vi-icon source="CaretDown"></vi-icon>
                            </vi-button>
                            <a slot="right" href$="[[href]]" title$="[[title]]" disabled$="[[!href]]" tabindex="-1" on-tap="_open" target$="[[target]]">
                                <vi-icon source="ArrowUpRight"></vi-icon>
                            </a>
                            <dom-if if="[[canAddNewReference]]" restamp>
                                <template>
                                    <vi-button slot="right" on-tap="_addNewReference" tabindex="-1" disabled="[[frozen]]">
                                        <vi-icon source="Add"></vi-icon>
                                    </vi-button>
                                </template>
                            </dom-if>
                            <dom-if if="[[canClear]]" restamp>
                                <template>
                                    <vi-button slot="right" on-tap="_clearReference" tabindex="-1" disabled="[[frozen]]">
                                        <vi-icon source="Remove"></vi-icon>
                                    </vi-button>
                                </template>
                            </dom-if>
                        </vi-persistent-object-attribute-edit>
                    </template>
                </dom-if>
                <dom-if if="[[op_areSame(inputtype, 'radio')]]">
                    <template>
                        <div content>
                            <div id="radiobuttons" orientation$="[[orientation]]">
                                <dom-repeat items="[[options]]" as="option">
                                    <template>
                                        <vi-checkbox label="[[option.value]]" checked="[[op_areSame(option.key, objectId)]]" on-changed="_select" radio part="radio"></vi-checkbox>
                                    </template>
                                </dom-repeat>
                            </div>
                        </div>
                    </template>
                </dom-if>
                <dom-if if="[[op_areSame(inputtype, 'chip')]]">
                    <template>
                        <div content>
                            <div id="chips" orientation$="[[orientation]]">
                                <dom-repeat items="[[options]]" as="option">
                                    <template>
                                        <vi-button label="[[option.value]]" inverse="[[op_areNotSame(option.key, objectId)]]" on-tap="_select" part="chip"></vi-button>
                                    </template>
                                </dom-repeat>
                            </div>
                        </div>
                    </template>
                </dom-if>
            </template>
        </dom-if>
        <dom-if if="[[!attribute.selectInPlace]]">
            <template>
                <vi-persistent-object-attribute-edit attribute="[[attribute]]">
                    <vi-sensitive disabled="[[!sensitive]]">
                        <input class="flex" value="{{filter::input}}" on-blur="_filterBlur" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" placeholder="[[placeholder]]" disabled="[[frozen]]">
                    </vi-sensitive>
                    <a slot="right" href$="[[href]]" title$="[[title]]" disabled$="[[!href]]" tabindex="-1" on-tap="_open" target$="[[target]]">
                        <vi-icon source="ArrowUpRight"></vi-icon>
                    </a>
                    <dom-if if="[[canBrowseReference]]" restamp>
                        <template>
                            <vi-button slot="right" on-tap="_browse" tabindex="-1" disabled="[[frozen]]">
                                <vi-icon source="Ellipsis"></vi-icon>
                            </vi-button>
                        </template>
                    </dom-if>
                    <dom-if if="[[canAddNewReference]]" restamp>
                        <template>
                            <vi-button slot="right" on-tap="_addNewReference" tabindex="-1" disabled="[[frozen]]">
                                <vi-icon source="Add"></vi-icon>
                            </vi-button>
                        </template>
                    </dom-if>
                    <dom-if if="[[canClear]]" restamp>
                        <template>
                            <vi-button slot="right" on-tap="_clearReference" tabindex="-1" disabled="[[frozen]]">
                                <vi-icon source="Remove"></vi-icon>
                            </vi-button>
                        </template>
                    </dom-if>
                </vi-persistent-object-attribute-edit>
            </template>
        </dom-if>
    </template>
</dom-if>`; }
    connectedCallback() {
        super.connectedCallback();
        this._update();
    }
    _attributeChanged() {
        super._attributeChanged();
        this._update();
    }
    _valueChanged(newValue) {
        this._update();
        if (this.attribute && newValue !== this.attribute.value) {
            this.attribute.setValue(newValue, true).catch(noop$1);
        }
    }
    _objectIdChanged() {
        if (this.attribute && this.attribute.objectId !== this.objectId)
            this.attribute.changeReference(this.objectId ? [this.objectId] : []);
    }
    async _filterBlur() {
        if (!this.attribute)
            return;
        if (!String.isNullOrEmpty(this.filter) && this.filter !== this.attribute.value) {
            this.attribute.lookup.textSearch = "vi-breadcrumb:\"" + this.filter + "\"";
            const result = await this.attribute.lookup.search();
            this.attribute.lookup.textSearch = null;
            if (!result)
                return;
            if (result.length === 1) {
                await this.attribute.changeReference([result[0]]);
                this._update();
            }
            else {
                if (result.length === 0) {
                    this.filter = this.attribute.value;
                    this.attribute.lookup.textSearch = "";
                }
                else
                    this.attribute.lookup.textSearch = this.filter;
                await this._browseReference(true, true);
            }
        }
        else
            this.filter = this.attribute.value;
    }
    _editingChanged() {
        this._update();
    }
    _browse(e) {
        this.attribute.lookup.textSearch = "";
        this._browseReference(false, true);
    }
    async _browseReference(throwExceptions, forceSearch) {
        this.attribute.lookup.selectedItems = [];
        try {
            const result = await this.app.showDialog(new SelectReferenceDialog(this.attribute.lookup, forceSearch, this.canAddNewReference));
            if (!result)
                return;
            if (result instanceof Array && result.length > 0 && result[0] instanceof QueryResultItem) {
                await this.attribute.changeReference(result);
                this._update();
            }
            if (result === "AddNewReference")
                this._addNewReference();
        }
        finally {
            this.filter = this.attribute.value;
        }
    }
    _addNewReference(e) {
        this.attribute.addNewReference();
    }
    async _clearReference(e) {
        await this.attribute.changeReference([]);
        this._update();
    }
    _update() {
        if (!this.isConnected)
            return;
        const hasReference = this.attribute instanceof PersistentObjectAttributeWithReference;
        if (hasReference && this.attribute.objectId !== this.objectId)
            this.objectId = this.attribute ? this.attribute.objectId : null;
        if (this.app instanceof App && hasReference && this.attribute.lookup && this.attribute.lookup.canRead && this.attribute.objectId && this.app)
            this.href = Path.routes.rootPath + this.app.getUrlForPersistentObject(this.attribute.lookup.persistentObject.id, this.attribute.objectId);
        else
            this.href = null;
        this.filter = hasReference ? this.attribute.value : "";
        this._setCanClear(hasReference && this.attribute.parent.isEditing && !this.attribute.isReadOnly && !this.sensitive && !this.attribute.isRequired && !String.isNullOrEmpty(this.attribute.objectId));
        this._setCanAddNewReference(hasReference && this.attribute.parent.isEditing && !this.attribute.isReadOnly && !this.sensitive && this.attribute.canAddNewReference);
        this._setCanBrowseReference(hasReference && this.attribute.parent.isEditing && !this.attribute.isReadOnly && !this.sensitive && !this.attribute.selectInPlace);
    }
    _openSelect() {
        const selectInPlace = this.shadowRoot.querySelector("#selectInPlace");
        selectInPlace.open();
    }
    async _open(e) {
        if (!(this.app instanceof App) || this.attribute.parent.isNew || !this.attribute.lookup.canRead)
            return;
        e.preventDefault();
        try {
            const po = await this.attribute.getPersistentObject();
            if (po)
                this.attribute.service.hooks.onOpen(po, false);
        }
        catch (e) {
            this.attribute.parent.setNotification(e, "Error");
        }
    }
    _computeTarget(attribute, href) {
        return attribute && href && attribute.parent.isNew ? "_blank" : "";
    }
    _computeInputType(attribute) {
        return attribute && attribute.getTypeHint("inputtype", "default", undefined, true);
    }
    _computeOrientation(attribute) {
        return attribute && attribute.getTypeHint("orientation", "vertical", undefined, true);
    }
    _computeCanOpenSelect(isReadOnly, options) {
        return !isReadOnly && !!options && options.length > 0;
    }
    _computeTitle(displayValue, sensitive) {
        return !sensitive ? displayValue : "";
    }
    _select(e) {
        e.stopPropagation();
        this.objectId = e.model.option.key;
    }
};
PersistentObjectAttributeReference = __decorate([
    WebComponent.register({
        properties: {
            href: String,
            canClear: {
                type: Boolean,
                readOnly: true
            },
            canAddNewReference: {
                type: Boolean,
                readOnly: true
            },
            canBrowseReference: {
                type: Boolean,
                readOnly: true
            },
            filter: {
                type: String,
                notify: true
            },
            inputtype: {
                type: String,
                computed: "_computeInputType(attribute)"
            },
            objectId: {
                type: String,
                observer: "_objectIdChanged"
            },
            selectInPlace: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "attribute.selectInPlace"
            },
            canOpenSelect: {
                type: Boolean,
                computed: "_computeCanOpenSelect(readOnly, options)"
            },
            orientation: {
                type: String,
                computed: "_computeOrientation(attribute)"
            },
            target: {
                type: String,
                computed: "_computeTarget(attribute, href)"
            },
            title: {
                type: String,
                computed: "_computeTitle(attribute.displayValue, sensitive)"
            }
        },
        observers: [
            "_update(attribute.isReadOnly, sensitive, isConnected)"
        ]
    })
], PersistentObjectAttributeReference);
PersistentObjectAttribute.registerAttributeType("Reference", PersistentObjectAttributeReference);

let PersistentObjectAttributeString = class PersistentObjectAttributeString extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  overflow: hidden;
}
:host span {
  overflow: hidden;
  text-overflow: ellipsis;
}
:host span, :host input {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host #suggestions[open] vi-icon {
  fill: white !important;
  background-color: var(--color);
}
:host #suggestions vi-icon {
  width: calc(var(--theme-h2) - 2px);
  height: calc(var(--theme-h2) - 2px);
}
:host #suggestions vi-icon:hover {
  fill: var(--color);
}
:host #suggestions ul {
  margin: 0;
  padding: 0;
  list-style-type: none;
}
:host #suggestions ul li {
  padding: 0 var(--theme-h5);
  line-height: var(--theme-h2);
  cursor: pointer;
  text-align: left;
}
:host #suggestions ul li:hover {
  background-color: var(--color-faint);
}
:host a {
  display: flex;
  flex-direction: row;
  text-decoration: none;
  overflow: hidden;
  text-overflow: ellipsis;
  fill: var(--vi-persistent-object-attribute-foreground, var(--color));
}
:host a:focus {
  outline: 0;
}
:host a:visited {
  color: var(--vi-persistent-object-attribute-foreground, var(--color));
  fill: var(--vi-persistent-object-attribute-foreground, var(--color));
}
:host a:hover {
  color: var(--vi-persistent-object-attribute-foreground, var(--color-light));
  fill: var(--vi-persistent-object-attribute-foreground, var(--color-light));
}
:host a[disabled] {
  color: var(--vi-persistent-object-attribute-foreground, #333) !important;
}
:host a[href] {
  cursor: pointer;
}
:host a span {
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  overflow: hidden;
  color: var(--vi-persistent-object-attribute-foreground, var(--color));
}
:host a vi-icon {
  margin: 0 var(--theme-h5);
  min-width: var(--theme-h4);
  height: 1em;
  transform: translateY(2px);
}</style>

<dom-if if="[[!editing]]" restamp>
    <template>
        <dom-if if="[[!link]]">
            <template>
                <vi-sensitive disabled="[[!sensitive]]">
                    <span>[[attribute.displayValue]]</span>
                </vi-sensitive>
            </template>
        </dom-if>
        <dom-if if="[[link]]">
            <template>
                <a href$="[[link]]" title$="[[linkTitle]]" rel="external noopener" target="_blank">
                    <vi-sensitive disabled="[[!sensitive]]">
                        <span>[[attribute.displayValue]]</span>
                    </vi-sensitive>
                    <dom-if if="[[attribute.value]]">
                        <template>
                            <vi-icon source="ArrowUpRight" class="size-h4"></vi-icon>
                        </template>
                    </dom-if>
                    <div class="spacer"></div>
                </a>
            </template>
        </dom-if>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <input value="{{value::input}}" type$="[[inputtype]]" maxlength$="[[maxlength]]" autocomplete$="[[autocomplete]]" style$="[[editInputStyle]]" on-focus="_editInputFocus" on-blur="_editInputBlur" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" placeholder="[[placeholder]]" disabled="[[frozen]]">
            </vi-sensitive>
            <template if="[[link]]">
                <a class="button" href$="[[link]]" title$="[[linkTitle]]" tabindex="-1" rel="external noopener" target="_blank">
                    <vi-icon source="ArrowUpRight"></vi-icon>
                </a>
            </template>
            <slot name="button" slot="right"></slot>
            <dom-if if="[[hasSuggestions]]">
                <template>
                    <vi-popup slot="right" id="suggestions" placement="bottom-end">
                        <vi-icon source="Add" slot="header"></vi-icon>
                        <vi-scroller>
                            <ul>
                                <dom-repeat items="[[filteredSuggestions]]" as="suggestion">
                                    <template>
                                        <li on-tap="_addSuggestion">[[suggestion]]</li>
                                    </template>
                                </dom-repeat>
                            </ul>
                        </vi-scroller>
                    </vi-popup>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    _attributeChanged() {
        super._attributeChanged();
        if (this.attribute instanceof PersistentObjectAttribute$1) {
            this._setCharacterCasing(this.attribute.getTypeHint("CharacterCasing", "Normal"));
            this._setInputtype(this.attribute.getTypeHint("InputType", "text"));
            const maxlength = parseInt(this.attribute.getTypeHint("MaxLength", "0"), 10);
            this._setMaxlength(maxlength > 0 ? maxlength : null);
            this._setAutocomplete(this.attribute.getTypeHint("Autocomplete"));
            this._suggestionsSeparator = this.attribute.getTypeHint("SuggestionsSeparator");
            if (this._suggestionsSeparator != null && this.attribute.options != null && this.attribute.options.length > 0) {
                const value = this.attribute.value;
                this._setSuggestions(this.attribute.options.filter(o => !String.isNullOrEmpty(o) && (value == null || !value.contains(o))));
            }
        }
    }
    _editInputBlur() {
        if (this.attribute && this.attribute.isValueChanged && this.attribute.triggersRefresh)
            this.attribute.setValue(this.value = this.attribute.value, true).catch(noop$1);
    }
    _editInputFocus(e) {
        const input = e.target;
        if (!input.value || !this.attribute.getTypeHint("SelectAllOnFocus"))
            return;
        input.selectionStart = 0;
        input.selectionEnd = input.value.length;
    }
    _valueChanged(value, oldValue) {
        let selection;
        let input;
        if (this.editing && value && this.characterCasing !== "Normal") {
            value = this.characterCasing === "Upper" ? value.toUpperCase() : value.toLowerCase();
            if (value !== this.value) {
                input = this.$.input || this.shadowRoot.querySelector("input");
                if (input != null)
                    selection = [input.selectionStart, input.selectionEnd];
            }
        }
        if (value === this.value)
            super._valueChanged(value, oldValue);
        else
            this.attribute.setValue(value, false).catch(noop$1);
        if (selection != null) {
            input.selectionStart = selection[0];
            input.selectionEnd = selection[1];
        }
    }
    _characterCasingChanged(casing) {
        if (casing === "Upper")
            this._setEditInputStyle("text-transform: uppercase;");
        else if (casing === "Lower")
            this._setEditInputStyle("text-transform: lowercase;");
        else
            this._setEditInputStyle(undefined);
    }
    _addSuggestion(e) {
        const suggestion = e.model.suggestion;
        this.attribute.setValue(String.isNullOrEmpty(this.value) ? suggestion : (this.value.endsWith(this._suggestionsSeparator) ? this.value + suggestion : this.value + this._suggestionsSeparator + suggestion)).catch(noop$1);
    }
    _computeFilteredSuggestions(suggestions, value) {
        if (!suggestions || suggestions.length === 0)
            return [];
        if (String.isNullOrEmpty(value))
            return suggestions;
        return suggestions.filter(s => value.indexOf(s) < 0);
    }
    _computeHasSuggestions(suggestions, readOnly) {
        return !readOnly && suggestions && suggestions.length > 0;
    }
    _computeLink(attribute, value) {
        const link = attribute.getTypeHint("Link", "").toLowerCase();
        if (!link)
            return null;
        return link === "email" ? `mailto:${value}` : (!!value ? value : null);
    }
    _computeLinkTitle(displayValue, sensitive) {
        return !sensitive ? displayValue : "";
    }
};
PersistentObjectAttributeString = __decorate([
    WebComponent.register({
        properties: {
            characterCasing: {
                type: String,
                readOnly: true,
                observer: "_characterCasingChanged"
            },
            editInputStyle: {
                type: String,
                readOnly: true
            },
            suggestions: {
                type: Array,
                readOnly: true
            },
            hasSuggestions: {
                type: Boolean,
                computed: "_computeHasSuggestions(filteredSuggestions, readOnly)"
            },
            filteredSuggestions: {
                type: Array,
                computed: "_computeFilteredSuggestions(suggestions, value)"
            },
            inputtype: {
                type: String,
                readOnly: true
            },
            maxlength: {
                type: Number,
                readOnly: true
            },
            autocomplete: {
                type: String,
                readOnly: true
            },
            link: {
                type: String,
                computed: "_computeLink(attribute, attribute.value)"
            },
            linkTitle: {
                type: String,
                computed: "_computeLinkTitle(attribute.displayValue, sensitive)"
            }
        },
    })
], PersistentObjectAttributeString);
PersistentObjectAttribute.registerAttributeType("String", PersistentObjectAttributeString);

let PersistentObjectAttributeTranslatedStringDialog = class PersistentObjectAttributeTranslatedStringDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host ul {
  margin: 0;
  padding: var(--theme-h4);
  list-style: none;
}
:host ul li {
  min-width: 50vw;
}
:host ul li:not(:last-of-type) {
  margin-bottom: var(--theme-h4);
}
:host ul li label {
  display: block;
  font-size: 11px;
  min-height: 20px;
  line-height: 20px;
  font-weight: 400;
  color: #888;
  overflow: hidden;
  text-overflow: ellipsis;
  text-transform: uppercase;
}
:host ul li input, :host ul li textarea {
  width: 100%;
  resize: none;
  box-sizing: border-box;
  margin: 0;
  padding: var(--theme-h5);
  border: 1px solid #ddd;
  outline: none;
}
:host ul li input:focus, :host ul li textarea:focus {
  border-color: var(--color-light);
}
:host([read-only]) input, :host([read-only]) textarea {
  background-color: var(--theme-read-only-color);
}</style>

<header class="horizontal layout">
    <h4 class="flex">[[label]]</h4>
</header>
<main>
    <ul id="content">
        <dom-repeat items="[[strings]]" as="string">
            <template>
                <li>
                    <label>[[string.label]]</label>
                    <dom-if if="[[!multiline]]">
                        <template>
                            <input value="{{string.value::input}}" type="text" readonly$="[[readonly]]" tabindex$="[[readOnlyTabIndex]]">
                        </template>
                    </dom-if>
                    <dom-if if="[[multiline]]">
                        <template>
                            <textarea rows="5" value="{{string.value::input}}"></textarea>
                        </template>
                    </dom-if>
                </li>
            </template>
        </dom-repeat>
    </ul>
</main>
<footer class="horizontal layout end-justified">
    <dom-if if="[[!readonly]]">
        <template>
            <vi-button on-tap="_ok" label="[[translateMessage('OK', isConnected)]]"></vi-button>
            <vi-button on-tap="cancel" inverse label="[[translateMessage('Cancel', isConnected)]]"></vi-button>
        </template>
    </dom-if>
    <dom-if if="[[readonly]]">
        <template>
            <vi-button on-tap="_ok" label="[[translateMessage('Close', isConnected)]]"></vi-button>
        </template>
    </dom-if>
</footer>`); }
    constructor(label, strings, multiline, readonly) {
        super();
        this.label = label;
        this.strings = strings;
        this.multiline = multiline;
        this.readonly = readonly;
    }
    _keyboardOk(e) {
        if (document.activeElement && document.activeElement instanceof HTMLInputElement)
            document.activeElement.blur();
        e.stopPropagation();
        this._ok();
    }
    _ok() {
        this.close(this.strings);
    }
    _onCaptureTab() {
    }
};
PersistentObjectAttributeTranslatedStringDialog = __decorate([
    WebComponent.register({
        properties: {
            label: String,
            strings: Array,
            readonly: Boolean,
            multiline: {
                type: Boolean,
                reflectToAttribute: true,
            }
        },
        keybindings: {
            "ctrl+s": "_keyboardOk"
        }
    })
], PersistentObjectAttributeTranslatedStringDialog);

let PersistentObjectAttributeTranslatedString = class PersistentObjectAttributeTranslatedString extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
  overflow: hidden;
}
:host span {
  overflow: hidden;
  text-overflow: ellipsis;
}
:host pre {
  padding-top: var(--theme-h5);
  line-height: normal !important;
}
:host span, :host pre, :host input, :host textarea {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}
:host([multiline]) #multiline {
  overflow: hidden;
  padding: var(--theme-h5) var(--theme-h5) 0 var(--theme-h5);
}
:host([multiline]) button {
  background-color: white;
}</style>

<dom-if if="[[!editing]]" restamp>
    <template>
        <dom-if if="[[!multiline]]">
            <template>
                <vi-sensitive disabled="[[!sensitive]]">
                    <span>[[attribute.displayValue]]</span>
                </vi-sensitive>
            </template>
        </dom-if>
        <dom-if if="[[multiline]]">
            <template>
                <vi-scroller>
                    <vi-sensitive disabled="[[!sensitive]]">
                        <pre>[[attribute.displayValue]]</pre>
                    </vi-sensitive>
                </vi-scroller>
            </template>
        </dom-if>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]" reverse-content$="[[multiline]]">
            <dom-if if="[[!multiline]]">
                <template>
                    <vi-sensitive disabled="[[!sensitive]]">
                        <input class="flex" value="{{value::input}}" type="text" on-blur="_editInputBlur" readonly$="[[readOnly]]" tabindex$="[[readOnlyTabIndex]]" placeholder="[[placeholder]]">
                    </vi-sensitive>
                </template>
            </dom-if>
            <dom-if if="[[multiline]]">
                <template>
                    <vi-scroller class="fit">
                        <vi-sensitive disabled="[[!sensitive]]">
                            <pre id="multiline">[[attribute.value]]</pre>
                        </vi-sensitive>
                    </vi-scroller>
                </template>
            </dom-if>
            <dom-if if="[[canShowDialog]]">
                <template>
                    <vi-button slot="right" on-tap="_showLanguagesDialog" tabindex="-1" hidden$="[[sensitive]]">
                        <vi-icon source="TranslatedString"></vi-icon>
                    </vi-button>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>

<vi-icon name="TranslatedString">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="m 23.768684,3.4875715 c -0.187969,6.15e-4 -0.375821,0.00251 -0.563174,0.00251 -3.307948,-6.624e-4 -6.615915,0.00307 -9.923864,0.00511 C 12.047242,3.4972215 10.80365,3.8513851 9.7871011,4.5596721 8.9428659,5.1558007 8.256372,5.9894787 7.8882936,6.9594657 7.0906205,6.9795183 6.2929474,7.1259797 5.5499935,7.4203076 4.6027782,7.7914444 3.7531051,8.412417 3.1284252,9.2168879 2.4612617,10.06724 2.0350656,11.119794 1.9949616,12.204657 c -0.032285,1.449202 -0.0085,2.898734 -0.015986,4.347937 -0.00139,0.794613 -0.031295,1.601484 0.1542696,2.380465 0.1913454,0.726301 0.5094641,1.425772 0.9788235,2.015106 1.1752678,1.490325 3.0911106,2.328104 4.9790841,2.270326 -0.444209,1.764601 -0.8887365,3.5295 -1.3326061,5.2941 2.77979,-1.703423 5.5541223,-3.416015 8.3356123,-5.117739 0.152262,-0.09006 0.315069,-0.184868 0.498598,-0.178751 0.974406,-6.81e-4 1.948822,-0.0058 2.923566,0 0.716785,-0.0055 1.440016,0.03025 2.148983,-0.100263 0.716105,-0.122013 1.415237,-0.359581 2.045694,-0.722222 0.916287,0.561124 1.831565,1.123917 2.746833,1.68708 -0.423817,-1.685412 -0.848994,-3.370781 -1.27281,-5.056192 1.210615,0.03432 2.428345,-0.308644 3.441495,-0.973088 0.933621,-0.605987 1.690488,-1.499844 2.068423,-2.552419 0.268496,-0.667163 0.328664,-1.393761 0.328664,-2.106127 -0.0031,-0.975085 -9.54e-4,-1.95018 -0.0013,-2.925264 -0.0041,-0.7140655 0.01087,-1.4288219 -0.02618,-2.141867 C 29.907082,7.1616811 29.360199,6.0570854 28.55301,5.2230464 27.732547,4.3628345 26.617106,3.8112476 25.452374,3.6032475 24.897452,3.4956791 24.332601,3.4858013 23.768694,3.4875856 Z m 0.02076,0.9641666 c 0.569317,-0.00166 1.141801,0.00919 1.697913,0.1415237 1.070927,0.2321308 2.072214,0.8289516 2.727822,1.7153306 0.431633,0.5719998 0.726959,1.2534382 0.809207,1.9678433 0.03263,0.3334108 0.02448,0.6688515 0.03228,1.0036222 0.0026,1.0539351 0.0014,2.1078591 9.54e-4,3.1617941 -0.0089,0.757228 0.04999,1.526734 -0.121979,2.271388 -0.144785,0.532575 -0.371138,1.049516 -0.708628,1.488627 -0.915607,1.198718 -2.432784,1.883895 -3.932288,1.857385 -0.447268,-0.0023 -0.894525,0.01321 -1.341793,0.01933 0.330353,1.313934 0.661695,2.627571 0.992047,3.941846 -1.778492,-1.094719 -3.558366,-2.18743 -5.337921,-3.28011 -0.28481,-0.170274 -0.559797,-0.358222 -0.856842,-0.506405 -0.224654,-0.115215 -0.476487,-0.172653 -0.728329,-0.176732 -1.325832,-0.0052 -2.651671,0.0078 -3.977162,-0.0064 -0.740237,-0.03194 -1.479443,-0.205278 -2.142188,-0.54107 C 10.195958,17.143635 9.5729674,16.602564 9.1464311,15.927583 8.7515031,15.304943 8.5156657,14.573853 8.5180445,13.833617 8.5163087,12.123055 8.5183951,10.412875 8.5170898,8.7026533 8.5181313,8.0273332 8.708765,7.3574509 9.039797,6.7704965 9.5635362,5.8446927 10.441428,5.1380942 11.439965,4.7815714 12.05037,4.5589568 12.701888,4.453247 13.351039,4.4597046 c 3.398353,-0.00407 6.796684,-0.0044 10.194697,-0.00679 0.08114,-4.249e-4 0.162418,-9.46e-4 0.243749,-0.00118 z M 7.6095976,7.9824486 c -0.035688,0.2375684 -0.056794,0.4775266 -0.056447,0.717814 0.00139,1.7109024 -0.00104,3.4217934 9.546e-4,5.1330344 -0.00199,0.770824 0.1988449,1.536868 0.553668,2.219665 0.6566275,1.272131 1.8536369,2.238401 3.2144738,2.665956 0.631816,0.202222 1.295592,0.299785 1.958337,0.300464 1.235424,0.0014 2.470849,-6.9e-4 3.706274,0.001 0.198483,-0.01024 0.375195,0.0897 0.539012,0.188945 1.395842,0.850353 2.784219,1.712251 4.179382,2.563623 -0.697072,0.28821 -1.450541,0.432664 -2.20437,0.432324 -1.246641,0.0014 -2.49293,-0.0024 -3.739571,0.001 -0.256923,-0.0092 -0.518283,0.01465 -0.75959,0.108123 -0.219896,0.08395 -0.420461,0.210029 -0.621324,0.330682 -2.012705,1.237465 -4.025028,2.474929 -6.0384143,3.711373 0.345647,-1.377831 0.6933015,-2.75497 1.0396282,-4.13212 -0.4890716,-0.0061 -0.9784512,-0.01701 -1.4678638,-0.01497 -1.222169,0.0061 -2.4426613,-0.437093 -3.3745827,-1.228309 C 4.1211618,20.622878 3.7571616,20.194685 3.5025997,19.704254 3.2548358,19.22096 3.0723254,18.697531 3.0250839,18.154079 c -0.056421,-0.543451 -0.034654,-1.09063 -0.036694,-1.63578 0.00746,-1.438327 -0.017028,-2.877004 0.016619,-4.31533 0.050303,-1.021647 0.5274775,-1.994002 1.232026,-2.7250617 C 5.1088,8.5589015 6.3595605,8.0671103 7.6095998,7.9824834 Z M 24.433709,9.6879543 c -0.09788,-2.036e-4 -0.195765,0.00886 -0.291862,0.027506 -0.578119,0.1039979 -1.068242,0.5716487 -1.198411,1.1446687 -0.116576,0.474797 0.01295,1.001934 0.34024,1.366274 0.322195,0.370797 0.831331,0.567242 1.319383,0.508105 0.421098,-0.04385 0.816015,-0.277016 1.0631,-0.619943 0.237229,-0.322535 0.337119,-0.741245 0.273224,-1.136172 -0.06356,-0.422118 -0.315719,-0.80992 -0.67326,-1.0423902 C 25.020907,9.7731204 24.727339,9.6886211 24.433709,9.6879522 Z m -11.255779,6.86e-5 c -0.09587,1.699e-4 -0.191696,0.00928 -0.285756,0.027453 -0.5703,0.1029851 -1.055633,0.5590631 -1.19294,1.1218871 -0.126092,0.480914 0.0023,1.019257 0.334771,1.389374 0.322195,0.370458 0.83098,0.566583 1.318693,0.507786 0.421776,-0.0435 0.817715,-0.277322 1.064799,-0.62127 0.255921,-0.348366 0.350086,-0.807881 0.254583,-1.229318 -0.0853,-0.393243 -0.335472,-0.746718 -0.67602,-0.9608357 C 13.753646,9.7673545 13.465555,9.6875123 13.17793,9.688006 Z m 5.65192,1.024e-4 c -0.09957,-0.00158 -0.19926,0.00644 -0.297227,0.024583 -0.576419,0.097541 -1.069229,0.5560577 -1.208235,1.1236397 -0.124731,0.476836 -0.0014,1.01009 0.325265,1.379868 0.31098,0.363661 0.800063,0.564184 1.2769,0.523399 0.395608,-0.02855 0.775591,-0.221955 1.033892,-0.523079 0.285151,-0.325596 0.419378,-0.776581 0.358881,-1.205156 C 20.265286,10.588923 20.02227,10.196692 19.671185,9.9564057 19.425969,9.7848559 19.128546,9.6928688 18.82985,9.688121 Z" />
        </g>
    </svg>
</vi-icon>`; }
    _optionsChanged(options) {
        super._optionsChanged(options);
        const strings = [];
        this._defaultLanguage = this.attribute.options[1];
        const data = JSON.parse(this.attribute.options[0]);
        const labels = JSON.parse(this.attribute.options[2]);
        for (const key in labels) {
            strings.push({
                key: key,
                value: data[key] || "",
                label: labels[key]
            });
        }
        this._setStrings(strings);
    }
    _valueChanged(newValue, oldValue) {
        if (newValue === this.attribute.value)
            return;
        super._valueChanged(newValue, oldValue);
        this.strings.find(s => s.key === this._defaultLanguage).value = newValue;
        const newOption = {};
        this.strings.forEach(val => {
            newOption[val.key] = val.value;
        });
        this.set("attribute.options.0", JSON.stringify(newOption));
    }
    _editInputBlur() {
        if (this.attribute && this.attribute.isValueChanged && this.attribute.triggersRefresh)
            this.attribute.setValue(this.value = this.attribute.value, true).catch(noop$1);
    }
    _computeMultiline(attribute) {
        return attribute && attribute.getTypeHint("MultiLine") === "True";
    }
    _computeCanShowDialog(strings, multiline) {
        return strings.length > 1 || multiline;
    }
    async _showLanguagesDialog() {
        const result = await this.app.showDialog(new PersistentObjectAttributeTranslatedStringDialog(this.attribute.label, this.strings.slice(), this.multiline, this.readOnly));
        if (this.readOnly || !result)
            return;
        const newData = {};
        result.forEach(s => {
            newData[s.key] = this.strings[s.key] = s.value;
            if (s.key === this._defaultLanguage)
                this.attribute.value = s.value;
        });
        this.attribute.options[0] = JSON.stringify(newData);
        this.attribute.isValueChanged = true;
        this.attribute.parent.triggerDirty();
        await this.attribute.setValue(this.value = this.attribute.value, true);
    }
};
PersistentObjectAttributeTranslatedString = __decorate([
    WebComponent.register({
        properties: {
            strings: {
                type: Array,
                readOnly: true
            },
            multiline: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeMultiline(attribute)"
            },
            canShowDialog: {
                type: Boolean,
                computed: "_computeCanShowDialog(strings, multiline)"
            }
        }
    })
], PersistentObjectAttributeTranslatedString);
PersistentObjectAttribute.registerAttributeType("TranslatedString", PersistentObjectAttributeTranslatedString);

let PersistentObjectAttributeUser = class PersistentObjectAttributeUser extends PersistentObjectAttribute {
    static get template() { return html$3 `<style include="vi-persistent-object-attribute-style-module"></style>
<style>:host {
  display: flex;
  flex-direction: row;
}
:host span {
  flex: 1;
  min-height: 0;
  min-width: 0;
  overflow: hidden;
  white-space: nowrap;
}
:host span, :host input {
  color: var(--vi-persistent-object-attribute-foreground, var(--theme-foreground));
}</style>

<dom-if if="[[!editing]]">
    <template>
        <vi-sensitive disabled="[[!sensitive]]">
            <span>[[friendlyName]]</span>
        </vi-sensitive>
    </template>
</dom-if>
<dom-if if="[[editing]]">
    <template>
        <vi-persistent-object-attribute-edit attribute="[[attribute]]">
            <vi-sensitive disabled="[[!sensitive]]">
                <input value="[[friendlyName]]" readonly>
            </vi-sensitive>
            <dom-if if="[[!readOnly]]" restamp>
                <template>
                    <vi-button slot="right" on-tap="_browseReference" tabindex="-1">
                        <vi-icon source="Ellipsis"></vi-icon>
                    </vi-button>
                </template>
            </dom-if>
            <dom-if if="[[canClear]]" restamp>
                <template>
                    <vi-button slot="right" on-tap="_clearReference" tabindex="-1">
                        <vi-icon source="Remove"></vi-icon>
                    </vi-button>
                </template>
            </dom-if>
        </vi-persistent-object-attribute-edit>
    </template>
</dom-if>`; }
    async _browseReference() {
        const query = await this.attribute.parent.queueWork(() => this.attribute.service.getQuery(this.attribute.getTypeHint("IncludeGroups") === "True" ? "98b12f32-3f2d-4f54-b963-cb9206f74355" : "273a8302-ddc8-43db-a7f6-c3c28fc8f593", undefined, this.attribute.parent));
        query.maxSelectedItems = 1;
        const result = await this.app.showDialog(new SelectReferenceDialog(query));
        if (!result)
            return;
        this._setNewUser(result[0].id, result[0].getValue("FriendlyName") || result[0].getValue("Name"));
    }
    _clearReference() {
        this._setNewUser(null, null);
    }
    _setNewUser(id, name) {
        this.notifyPath("attribute.options", this.attribute.options = [name]);
        this.attribute.setValue(id, true);
    }
    _computeFriendlyName(options) {
        return options && options.length > 0 ? options[0] || "\u2014" : "\u2014";
    }
    _computeCanClear(readOnly, isRequired, value) {
        return !readOnly && !isRequired && !String.isNullOrEmpty(value);
    }
    _computeCanBrowseReference(readOnly) {
        return !readOnly;
    }
};
PersistentObjectAttributeUser = __decorate([
    WebComponent.register({
        properties: {
            friendlyName: {
                type: String,
                computed: "_computeFriendlyName(attribute.options)"
            },
            canClear: {
                type: Boolean,
                computed: "_computeCanClear(readOnly, attribute.isRequired, value)"
            },
            canBrowseReference: {
                type: Boolean,
                computed: "_computeCanBrowseReference(readOnly)",
            }
        }
    })
], PersistentObjectAttributeUser);
PersistentObjectAttribute.registerAttributeType("User", PersistentObjectAttributeUser);

let PersistentObjectAttributeLabel = class PersistentObjectAttributeLabel extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  align-items: flex-end;
  height: var(--theme-h2);
  box-sizing: border-box;
  overflow: hidden;
}
:host > div {
  gap: var(--theme-h5);
  align-items: center;
}

label {
  font-size: 0.9em;
  font-weight: 400;
  color: var(--vi-persistent-object-attribute-label-color, #888);
  letter-spacing: 0.2px;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 2em;
}

.required {
  display: none;
  position: relative;
  font-size: 0.8em;
  color: white;
  line-height: 1.5em;
  height: 14px;
  padding: 0 var(--theme-h5) 2px calc(var(--theme-h5) / 2);
  background-color: var(--color);
  margin-left: var(--theme-h5);
}
.required::before {
  content: "";
  position: absolute;
  right: 100%;
  width: 0;
  height: 0;
  border-top: 8px solid transparent;
  border-bottom: 8px solid transparent;
  border-right-color: var(--color);
  border-right-width: 7px;
  border-right-style: solid;
}

.locked {
  fill: #666;
  display: none;
}
.locked > vi-icon {
  height: var(--theme-h3);
  --vi-icon-width: 10px;
  --vi-icon-height: 10px;
  fill: var(--vi-persistent-object-attribute-label-color, #888);
}

.info {
  width: var(--theme-h3);
  height: var(--theme-h3);
}
.info::part(icon) {
  --vi-icon-width: 12px;
  --vi-icon-height: 12px;
  fill: var(--color);
}

:host([has-error]) .label .required {
  background-color: var(--theme-color-error) !important;
}
:host([has-error]) .label .required::before {
  border-right-color: var(--theme-color-error) !important;
}

:host([editing][required]:not([bulk-edit]):not([read-only])) .required {
  display: inline-block;
}

:host([editing][read-only]) .locked {
  display: inline-block;
}</style>

<div class="layout horizontal">
    <label>[[attribute.label]]</label>
    <span class="required">[[translateMessage('Required', isConnected)]]</span>
    <div class="locked">
        <vi-icon source="Lock"></vi-icon>
    </div>
    <vi-button inverse class="info" icon="Info" on-tap="_showTooltip" hidden$="[[!hasToolTip]]" tabindex="-1"></vi-button>
</div>`; }
    _computeRequired(attribute, required, value) {
        return required && (value == null || (attribute && attribute.rules && attribute.rules.contains("NotEmpty") && value === ""));
    }
    _computeReadOnly(isReadOnly, disabled) {
        return isReadOnly || disabled;
    }
    _computeEditing(isEditing, nonEdit) {
        return !nonEdit && isEditing;
    }
    _computeHasError(validationError) {
        return !String.isNullOrEmpty(validationError);
    }
    _computeHasToolTip(toolTip) {
        return !!toolTip;
    }
    _showTooltip(e) {
        this.app.showMessageDialog({
            title: this.attribute.label,
            titleIcon: "Info",
            rich: true,
            message: this.attribute.toolTip,
            actions: [this.translateMessage("OK")]
        });
    }
};
PersistentObjectAttributeLabel = __decorate([
    WebComponent.register({
        properties: {
            attribute: Object,
            editing: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeEditing(attribute.parent.isEditing, nonEdit)"
            },
            nonEdit: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            hasToolTip: {
                type: Boolean,
                computed: "_computeHasToolTip(attribute.toolTip)"
            },
            required: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeRequired(attribute, attribute.isRequired, attribute.value)"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            readOnly: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeReadOnly(attribute.isReadOnly, disabled)"
            },
            bulkEdit: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "attribute.parent.isBulkEdit"
            },
            hasError: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasError(attribute.validationError)"
            }
        },
        forwardObservers: [
            "attribute.parent.isEditing",
            "attribute.isRequired",
            "attribute.isReadOnly",
            "attribute.value",
            "attribute.validationError",
            "attribute.parent.isBulkEdit",
            "attribute.label"
        ]
    })
], PersistentObjectAttributeLabel);

class DeveloperShortcut extends Observable {
    constructor() {
        super(...arguments);
        this._state = false;
    }
    get state() {
        return this._state;
    }
    set state(state) {
        if (state === this._state)
            return;
        const oldState = this._state;
        this.notifyPropertyChanged("state", this._state = state, oldState);
    }
}
const developerShortcut = new DeveloperShortcut();
document.addEventListener("keydown", e => {
    developerShortcut.state = e.ctrlKey && e.altKey;
});
document.addEventListener("keyup", e => {
    developerShortcut.state = e.ctrlKey && e.altKey;
});
let PersistentObjectAttributePresenter = class PersistentObjectAttributePresenter extends ConfigurableWebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  white-space: nowrap;
  color: #222;
  position: relative;
  --vi-persistent-object-attribute-presenter--attribute-height: calc(var(--vi-persistent-object-attribute-presenter--row-height, var(--theme-h2)) * 2 * (var(--vi-persistent-object-attribute-presenter--row-span) - .5));
}
:host #content {
  height: var(--vi-persistent-object-attribute-presenter--attribute-height);
}
:host ::slotted(*) {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host vi-checkbox {
  margin-right: var(--theme-h5);
}
:host vi-checkbox[disabled]::part(icon) {
  background-color: #eee;
}
:host(:focus) {
  outline: 0;
}
:host([developer]) #content, :host([developer]) vi-persistent-object-attribute-label {
  opacity: 0.2;
}
:host([developer]) #developer {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  background-color: rgba(255, 255, 255, 0.3);
  border: 1px dashed var(--color-faint);
  cursor: pointer;
}
:host([developer]) #developer:hover {
  background-color: var(--color-faint);
}
:host([developer]) #developer label {
  font-weight: bold;
  color: var(--color-darker);
  pointer-events: none;
}</style>

<dom-if if="[[!noLabel]]">
    <template>
        <vi-persistent-object-attribute-label non-edit="[[nonEdit]]" attribute="[[attribute]]" part="label"></vi-persistent-object-attribute-label>
    </template>
</dom-if>
<div id="content" class="layout horizontal">
    <dom-if if="[[attribute.parent.isBulkEdit]]">
        <template>
            <vi-checkbox checked="{{attribute.isValueChanged}}" disabled="[[readOnly]]"></vi-checkbox>
        </template>
    </dom-if>
    <slot></slot>
</div>
<dom-if if="[[developer]]">
    <template>
        <div id="developer" on-tap="_openAttributeManagement">
            <label>[[attribute.name]]</label>
        </div>
    </template>
</dom-if>`; }
    async connectedCallback() {
        super.connectedCallback();
        const customTemplate = this.querySelector("template");
        if (customTemplate) {
            this._customTemplate = templatize(customTemplate);
        }
        if (this.service && this.service.application && this.service.application.hasManagement)
            this._developerToggleDisposer = developerShortcut.propertyChanged.attach(this._devToggle.bind(this));
    }
    disconnectedCallback() {
        if (this._developerToggleDisposer) {
            this._developerToggleDisposer();
            this._developerToggleDisposer = null;
        }
        super.disconnectedCallback();
    }
    _onTap(e) {
        if (this.editing && typeof this._renderedAttributeElement?.focus === "function") {
            const currentActiveElement = this.app.activeElement;
            this._renderedAttributeElement.focus();
            if (currentActiveElement !== this.app.activeElement) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    }
    _devToggle() {
        this.set("developer", !this.attribute.parent.isSystem && developerShortcut.state);
    }
    queueFocus() {
        const activeElement = document.activeElement;
        this._focusElement(this);
        if (activeElement !== document.activeElement)
            this._focusQueued = true;
    }
    _attributeChanged(attribute, isConnected) {
        if (this._renderedAttribute === attribute)
            return;
        if (this._renderedAttribute) {
            Array.from(this.children).forEach(c => this.removeChild(c));
            this._renderedAttributeElement = this._renderedAttribute = null;
        }
        if (!attribute || !isConnected)
            return;
        this._setLoading(true);
        const nolabel = attribute.getTypeHint("nolabel", undefined, undefined, true);
        if (nolabel !== undefined)
            this.noLabel = nolabel === "true";
        let attributeType;
        if (DataType.isNumericType(attribute.type))
            attributeType = "Numeric";
        else if (DataType.isDateTimeType(attribute.type))
            attributeType = "DateTime";
        else if (attribute.parent.isBulkEdit && (attribute.type === "YesNo" || attribute.type === "Boolean"))
            attributeType = "NullableBoolean";
        else {
            switch (attribute.type) {
                case "YesNo":
                    attributeType = "Boolean";
                    break;
                case "Enum":
                    attributeType = "DropDown";
                    break;
                case "Guid":
                case "NullableGuid":
                    attributeType = "String";
                    break;
                case "NullableUser":
                    attributeType = "User";
                    break;
                default:
                    attributeType = attribute.type;
            }
        }
        this._renderAttribute(attribute, attributeType);
    }
    async _renderAttribute(attribute, attributeType) {
        if (!this.isConnected || attribute !== this.attribute || this._renderedAttribute === attribute)
            return;
        let focusTarget;
        try {
            if (this._customTemplate) {
                const templateInstance = new this._customTemplate({ attribute: attribute });
                (focusTarget = this.$.content).appendChild(templateInstance.root);
            }
            else {
                const config = this.app.configuration.getAttributeConfig(attribute);
                this.noLabel = this.noLabel || (config && !!config.noLabel);
                if (!!config && config.hasTemplate)
                    this.appendChild(config.stamp(attribute, config.as || "attribute"));
                else {
                    this._renderedAttributeElement = new (PersistentObjectAttribute.getAttributeConstructor(attributeType) ?? PersistentObjectAttributeString)();
                    this._renderedAttributeElement.classList.add("attribute");
                    this._renderedAttributeElement.attribute = attribute;
                    this._renderedAttributeElement.nonEdit = this.nonEdit;
                    this._renderedAttributeElement.disabled = this.disabled;
                    this.appendChild(focusTarget = this._renderedAttributeElement);
                }
            }
            this._renderedAttribute = attribute;
        }
        finally {
            this._setLoading(false);
            if (this._focusQueued) {
                flush$1();
                this._focusElement(focusTarget);
                this._focusQueued = false;
            }
        }
    }
    _updateRowSpan(attribute, height, isConnected) {
        if (!isConnected)
            return;
        height = height || this.app.configuration.getAttributeConfig(attribute).calculateHeight(attribute);
        if (height > 0)
            this.style.setProperty("--vi-persistent-object-attribute-presenter--row-span", `${height}`);
        else
            this.style.removeProperty("--vi-persistent-object-attribute-presenter--row-span");
    }
    _computeEditing(isEditing, nonEdit) {
        return !nonEdit && isEditing;
    }
    _computeNonEdit(attribute) {
        return attribute?.getTypeHint("nonedit", "false", undefined, true) === "true";
    }
    _nonEditChanged(nonEdit) {
        if (this._renderedAttributeElement)
            this._renderedAttributeElement.nonEdit = nonEdit;
    }
    _disabledChanged(disabled) {
        if (!this._renderedAttributeElement)
            return;
        this._renderedAttributeElement.disabled = disabled;
    }
    _computeRequired(attribute, required, value) {
        return required && (value == null || (attribute && attribute.rules && attribute.rules.contains("NotEmpty") && value === ""));
    }
    _computeReadOnly(isReadOnly, isFrozen, disabled) {
        return isReadOnly || disabled || isFrozen;
    }
    _computeHasError(validationError) {
        return !String.isNullOrEmpty(validationError);
    }
    _computeHasValue(value) {
        return value != null && value !== "";
    }
    _loadingChanged(loading) {
        this.fire(loading ? "attribute-loading" : "attribute-loaded", { attribute: this.attribute }, { bubbles: true });
    }
    _openAttributeManagement() {
        this.app.changePath(`Management/PersistentObject.1456569d-e02b-44b3-9d1a-a1e417061c77/${this.attribute.id}`);
    }
    _configure(e) {
        if (this.attribute.parent.isSystem)
            return;
        e.detail.push({
            label: `Attribute: ${this.attribute.name}`,
            icon: "viConfigure",
            action: this._openAttributeManagement.bind(this)
        });
    }
    _gridAreaChanged(gridArea) {
        this.style.gridArea = gridArea;
    }
};
PersistentObjectAttributePresenter = __decorate([
    ConfigurableWebComponent.register({
        properties: {
            attribute: Object,
            name: {
                type: String,
                computed: "attribute.name",
                reflectToAttribute: true
            },
            type: {
                type: String,
                computed: "attribute.type",
                reflectToAttribute: true
            },
            noLabel: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            editing: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeEditing(attribute.parent.isEditing, nonEdit)"
            },
            nonEdit: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeNonEdit(attribute)",
                observer: "_nonEditChanged"
            },
            required: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeRequired(attribute, attribute.isRequired, attribute.value)"
            },
            disabled: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
                observer: "_disabledChanged"
            },
            readOnly: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeReadOnly(attribute.isReadOnly, attribute.parent.isFrozen, disabled)"
            },
            bulkEdit: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "attribute.parent.isBulkEdit"
            },
            loading: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                value: true,
                observer: "_loadingChanged"
            },
            height: {
                type: Number,
                reflectToAttribute: true,
                value: null
            },
            hidden: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "!attribute.isVisible"
            },
            hasError: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasError(attribute.validationError)"
            },
            hasValue: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasValue(attribute.value)"
            },
            developer: {
                type: Boolean,
                reflectToAttribute: true
            },
            gridArea: {
                type: String,
                reflectToAttribute: true,
                observer: "_gridAreaChanged"
            }
        },
        listeners: {
            "tap": "_onTap",
            "vi:configure": "_configure"
        },
        observers: [
            "_attributeChanged(attribute, isConnected)",
            "_updateRowSpan(attribute, height, isConnected)"
        ],
        forwardObservers: [
            "attribute.parent.isEditing",
            "attribute.parent.isFrozen",
            "attribute.isRequired",
            "attribute.isReadOnly",
            "attribute.isVisible",
            "attribute.value",
            "attribute.isValueChanged",
            "attribute.validationError",
            "attribute.parent.isBulkEdit"
        ]
    })
], PersistentObjectAttributePresenter);

let PersistentObjectGroup = class PersistentObjectGroup extends WebComponent {
    constructor() {
        super(...arguments);
        this._asyncHandles = [];
        this._presentersLoading = 0;
    }
    static get template() { return html$3 `<style>:host {
  display: block;
  padding: var(--vi-persistent-object-group--attribute-padding, 0 var(--theme-h4));
}
:host([loading]) {
  visibility: hidden;
}
:host label {
  flex: 1;
  min-height: 0;
  min-width: 0;
  display: block;
  font-size: 15px;
  font-weight: 600;
  text-transform: uppercase;
  padding: var(--theme-h4) var(--theme-h5) 0 0;
  color: var(--color);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
:host([no-label]) label, :host label:empty {
  display: none;
}
:host #grid {
  display: grid;
  grid-template-areas: var(--vi-persistent-object-group--grid-areas, none);
  grid-auto-columns: 1fr;
  gap: var(--vi-persistent-object-group--attribute-gap, 0 var(--theme-h4));
}
:host #grid ::slotted(*) {
  grid-area: var(--vi-persistent-object-group--attribute-area);
  overflow: hidden;
}</style>

<label>[[label]]</label>
<div id="grid">
    <slot></slot>
</div>`; }
    _computeLabel(group, groupIndex, translations) {
        if (group.label && groupIndex === 0) {
            const firstAttribute = group.attributes[0];
            if (firstAttribute && firstAttribute.tab.label === group.label)
                return "";
        }
        else if (!group.label && groupIndex > 0)
            return this.translations["DefaultAttributesGroup"];
        return group.label;
    }
    _arrange(attributes, columns, isConnected) {
        attributes = attributes.filter(a => a.isVisible);
        if (!isConnected || !columns || !attributes?.length)
            return;
        let oldItems = [];
        if (!this._items)
            this._items = attributes.map(attr => this._itemFromAttribute(attr));
        else {
            oldItems = this._items.slice();
            this._items = attributes.map(attr => {
                let item = oldItems.find(i => i.attribute === attr);
                if (item) {
                    item.x = item.attribute.column;
                    item.width = Math.min(columns, item.config.calculateWidth(item.attribute));
                    oldItems.splice(oldItems.indexOf(item), 1);
                }
                else
                    item = this._itemFromAttribute(attr);
                return item;
            });
        }
        let itemsChecksum = `${this.group.parent.type};${this.group.parent.objectId};${columns}`;
        const items = this._items.slice().orderBy(item => item.attribute.offset);
        items.forEach(item => itemsChecksum = `${itemsChecksum}${item.attribute.offset};${item.attribute.name};${item.height};${item.width};`);
        if (this._itemsChecksum === itemsChecksum)
            return;
        oldItems.filter(item => item.presenter.isConnected).forEach(item => this.removeChild(item.presenter));
        const areas = [];
        let item = items.shift();
        let column = 0, row = 0;
        let infiniteColumns = {};
        while (!!item) {
            const itemHeight = Math.max(item.height, 1);
            let itemX = item.x < columns ? item.x : null;
            const itemWidth = itemX == null ? Math.min(item.width, columns) : Math.min(item.width, columns - itemX);
            if (Object.keys(infiniteColumns).length > 0) {
                do {
                    if (infiniteColumns[itemX]) {
                        if (itemX != null) {
                            infiniteColumns = {};
                            row++;
                            break;
                        }
                        else
                            itemX++;
                    }
                    else {
                        for (let x = 1; x < itemWidth; x++) {
                            if (infiniteColumns[itemX + x]) {
                                infiniteColumns = {};
                                row++;
                                break;
                            }
                        }
                        break;
                    }
                } while (itemX < columns - itemWidth);
            }
            do {
                if (areas.length < row + itemHeight) {
                    const newRow = Array.range(1, columns).map(_ => "");
                    areas.push(newRow);
                    column = 0;
                    let added = 0;
                    for (let x in infiniteColumns) {
                        newRow[x] = infiniteColumns[x];
                        added++;
                    }
                    if (added + itemWidth > columns)
                        infiniteColumns = {};
                    continue;
                }
                if (itemX != null) {
                    if (itemX < column) {
                        column = itemX;
                        row++;
                        continue;
                    }
                    else
                        column = itemX;
                }
                if (!Array.range(column, column + itemWidth - 1).some(c => !!areas[row][c]))
                    break;
                column++;
                if (column >= columns || column + itemWidth - 1 >= columns) {
                    row++;
                    column = itemX || 0;
                }
            } while (true);
            if (item.height === 0 && itemWidth !== columns) {
                for (let x = 0; x < itemWidth; x++)
                    infiniteColumns[column + x] = item.area;
            }
            for (let x = 0; x < itemWidth; x++) {
                for (let y = 0; y < (item.height !== 0 ? itemHeight : areas.length - row); y++)
                    areas[row + y][column + x] = item.area;
            }
            if (!item.presenter)
                item.presenter = this.onCreatePersistentObjectAttributePresenter(item.attribute);
            const renderItem = item;
            const renderHandle = animationFrame.run(() => {
                if (this._itemsChecksum !== itemsChecksum)
                    return;
                if (!renderItem.presenter.isConnected || renderItem.presenter.parentElement !== this)
                    this.appendChild(renderItem.presenter);
                renderItem.presenter.updateStyles({
                    "--vi-persistent-object-group--attribute-area": renderItem.area
                });
            });
            this._asyncHandles.push(renderHandle);
            item = items.shift();
        }
        let newRow;
        for (let x in infiniteColumns) {
            if (!newRow) {
                newRow = Array.range(1, columns).map(_ => "");
                areas.push(newRow);
            }
            newRow[x] = infiniteColumns[x];
        }
        this.updateStyles({
            "--vi-persistent-object-group--grid-areas": areas.map(r => `"${r.map(a => a || ".").join(" ")}"`).join(" ")
        });
        this._itemsChecksum = itemsChecksum;
    }
    _itemFromAttribute(attribute) {
        const config = this.app.configuration.getAttributeConfig(attribute);
        const item = {
            attribute: attribute,
            config: config,
            area: attribute.name,
            x: attribute.column,
            width: Math.min(this.columns, config.calculateWidth(attribute)),
            height: config.calculateHeight(attribute)
        };
        item.area = item.area.split("").map(c => c.charCodeAt(0) > 255 || (c >= "0" && c <= "9") || (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") ? c : "_").join("");
        if (/[0-9]/.test(item.area[0]))
            item.area = `_${item.area}`;
        if (item.height > 10)
            item.height = 1;
        return item;
    }
    _onAttributeLoading(e) {
        if (!this.loading) {
            this._presentersLoading = 0;
            this._setLoading(true);
        }
        else
            this._presentersLoading++;
    }
    _onAttributeLoaded(e) {
        if (--this._presentersLoading <= 0)
            this._setLoading(false);
    }
    _onAttributeVisibilityChanged(info) {
        if (!info)
            return;
        this._arrange(this.group.attributes, this.columns, this.isConnected);
    }
    onCreatePersistentObjectAttributePresenter(attribute) {
        const presenter = new PersistentObjectAttributePresenter();
        presenter.attribute = attribute;
        return presenter;
    }
};
PersistentObjectGroup = __decorate([
    WebComponent.register({
        properties: {
            group: Object,
            groupIndex: {
                type: Number,
                value: 0
            },
            columns: {
                type: Number,
                value: 1
            },
            label: {
                type: String,
                computed: "_computeLabel(group, groupIndex, translations)"
            },
            noLabel: {
                type: Boolean,
                reflectToAttribute: true
            },
            loading: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                value: true
            }
        },
        observers: [
            "_arrange(group.attributes, columns, isConnected)"
        ],
        listeners: {
            "attribute-loading": "_onAttributeLoading",
            "attribute-loaded": "_onAttributeLoaded"
        },
        forwardObservers: [
            "group.attributes",
            "_onAttributeVisibilityChanged(group.attributes.*.isVisible)"
        ]
    })
], PersistentObjectGroup);

let PersistentObjectTab = class PersistentObjectTab extends ConfigurableWebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
}
:host > vi-scroller {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host .groups {
  display: block;
  padding-bottom: var(--theme-h4);
}</style>

<vi-size-tracker size="{{size}}"></vi-size-tracker>
<dom-if if="[[!noScroll]]" restamp>
    <template>
        <vi-scroller no-horizontal>
            <div class="relative">
                <vi-size-tracker size="{{innerSize}}"></vi-size-tracker>
                <div class="groups">
                    <dom-repeat items="[[groups]]" as="group">
                        <template>
                            <vi-persistent-object-group group="[[group]]" group-index="[[index]]" columns="[[columns]]"></vi-persistent-object-group>
                        </template>
                    </dom-repeat>
                </div>
            </div>
        </vi-scroller>
    </template>
</dom-if>
<dom-if if="[[noScroll]]" restamp>
    <template>
        <div class="groups relative">
            <dom-repeat items="[[groups]]" as="group">
                <template>
                    <vi-persistent-object-group group="[[group]]" group-index="[[index]]" columns="[[columns]]"></vi-persistent-object-group>
                </template>
            </dom-repeat>
        </div>
    </template>
</dom-if>`; }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._attributePresenters = this._autofocusTarget = null;
    }
    _computeColumns(size, defaultColumnCount) {
        if (defaultColumnCount)
            return defaultColumnCount;
        if (size.width >= 1500)
            return 4;
        else if (size.width > 1000)
            return 3;
        else if (size.width > 500)
            return 2;
        return 1;
    }
    _updateGroups() {
        this._setGroups(this.tab?.groups.filter(g => g.attributes.some(a => a.isVisible)));
    }
    _autofocus(noAutofocus, isEditing) {
        if (!noAutofocus && isEditing && this._autofocusTarget)
            this._focusElement(this._autofocusTarget);
    }
    _attributeLoaded(e) {
        if (this.noAutofocus)
            return;
        if (!this._attributePresenters)
            this._attributePresenters = [];
        const presenter = e.composedPath()[0];
        this._attributePresenters.push(presenter);
        if (this._attributePresenters.length < this.tab.attributes.length)
            return;
        this._attributePresenters = this._attributePresenters.sort((attr1, attr2) => attr1.attribute.offset - attr2.attribute.offset);
        for (const presenter of this._attributePresenters) {
            const focusTarget = IronFocusablesHelper.getTabbableNodes(presenter)[0];
            if (!focusTarget)
                continue;
            this._focusElement(focusTarget);
            break;
        }
    }
    _innerSizeChanged(size) {
        this.fire("vi-persistent-object-tab-inner-size-changed", size, { bubbles: true });
    }
    _configure(e) {
        if (this.tab.target instanceof PersistentObject$1) {
            if (this.tab.target.isSystem)
                return;
        }
        const tab = this.tab;
        e.detail.push({
            label: `Attribute tab: ${tab.label}`,
            icon: "viConfigure",
            action: () => this.app.changePath(`management/persistent-object.9b7a3b94-cf71-4284-bac3-de4d2790c868/${tab.id}`)
        });
    }
};
PersistentObjectTab = __decorate([
    ConfigurableWebComponent.register({
        properties: {
            tab: Object,
            columns: {
                type: Number,
                computed: "_computeColumns(size, tab.columnCount)"
            },
            groups: {
                type: Array,
                readOnly: true
            },
            size: Object,
            innerSize: {
                type: Object,
                observer: "_innerSizeChanged"
            },
            noAutofocus: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            noScroll: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            }
        },
        observers: [
            "_autofocus(noAutofocus, tab.parent.isEditing)"
        ],
        listeners: {
            "attribute-loaded": "_attributeLoaded",
            "vi:configure": "_configure"
        },
        forwardObservers: [
            "_updateGroups(tab.attributes.*.isVisible)",
            "tab.parent.isEditing",
            "tab.groups"
        ]
    })
], PersistentObjectTab);

let PersistentObjectTabPresenter = class PersistentObjectTabPresenter extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
}
:host ::slotted(*) {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}</style>

<slot></slot>
<vi-spinner hidden="[[!loading]]"></vi-spinner>`; }
    async _renderTab(tab, isConnected) {
        if (!isConnected || this._renderedTab === tab)
            return;
        this.empty();
        if (!tab) {
            this._setLoading(false);
            return;
        }
        this._setLoading(true);
        const config = this.app.configuration.getTabConfig(tab);
        this._setTemplated(!!config && config.hasTemplate);
        if (this.templated) {
            this.appendChild(config.stamp(tab, config.as || "tab"));
            this._setLoading(false);
        }
        else {
            if (tab instanceof PersistentObjectQueryTab) {
                const itemPresenter = new QueryItemsPresenter();
                itemPresenter.query = tab.query;
                if (itemPresenter.query.autoQuery && !itemPresenter.query.hasSearched)
                    itemPresenter.query.search();
                this.appendChild(itemPresenter);
                this._setLoading(false);
            }
            else if (tab instanceof PersistentObjectAttributeTab) {
                if (tab !== this.tab)
                    return;
                this._tabAttributes = tab.attributes.slice(0).filter(a => a.isVisible);
                const attributeTab = new PersistentObjectTab();
                attributeTab.tab = tab;
                this.appendChild(attributeTab);
                if (this._tabAttributes.length === 0)
                    this._setLoading(false);
            }
        }
    }
    _attributeLoaded(e) {
        const { attribute } = e.detail;
        if (!this._tabAttributes)
            return;
        if (this._tabAttributes.length > 0)
            this._tabAttributes.remove(attribute);
        if (this._tabAttributes.length === 0)
            this._setLoading(false);
    }
};
PersistentObjectTabPresenter = __decorate([
    WebComponent.register({
        properties: {
            tab: Object,
            loading: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true,
                value: true
            },
            templated: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            }
        },
        observers: [
            "_renderTab(tab, isConnected)"
        ],
        listeners: {
            "attribute-loaded": "_attributeLoaded"
        }
    })
], PersistentObjectTabPresenter);

let PersistentObjectDialog = class PersistentObjectDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host {
  --vi-persistent-object-dialog-base-width-base: 400px;
}
:host main {
  display: flex;
  flex-direction: column;
  padding: 0;
  max-height: calc(80vh - (var(--theme-h1) + var(--theme-h5) * 2) - (var(--theme-h2) + var(--theme-h4) * 2));
  min-height: calc(var(--theme-h2) * 3);
}
:host main > vi-persistent-object-tab-presenter {
  flex: 1;
  min-height: 0;
  min-width: 0;
  min-height: calc(var(--theme-h2) * 3);
}
:host main > vi-persistent-object-tab-presenter > vi-persistent-object-tab {
  position: static;
  width: var(--vi-persistent-object-dialog-computed-width, var(--vi-persistent-object-dialog-base-width-base));
  max-width: 90vw;
}
:host footer .extra-actions {
  padding-right: var(--theme-h5);
}
:host([is-phone]) main {
  width: 85vw;
}
:host([is-tablet]) main, :host([is-tablet]) vi-notification, :host([is-desktop]) main, :host([is-desktop]) vi-notification {
  min-width: 400px;
  max-width: var(--vi-persistent-object-dialog-computed-width);
}

header nav {
  display: flex;
  gap: var(--theme-h5);
  margin: calc(var(--theme-h5) * -1) calc(var(--theme-h4) * -1) calc(var(--theme-h5) * -1) var(--theme-h4);
}
header nav span {
  align-self: center;
}
header nav vi-button {
  width: var(--theme-h1);
}

footer vi-button.cancel {
  display: grid;
  grid-template-areas: "stack";
  justify-items: center;
}
footer vi-button.cancel span {
  grid-area: stack;
}
footer vi-button.cancel span[hide] {
  visibility: hidden;
}</style>

<header class="horizontal layout">
    <h4 class="flex">[[persistentObject.breadcrumb]]</h4>
    <dom-if if="[[showNavigation]]">
        <template>
            <nav class="layout horizontal">
                <span>[[_getNavigationIndex(persistentObject)]]</span>
                <vi-button icon="ChevronLeft" inverse data-direction="previous" on-tap="_navigate" busy$="[[isBusy]]" disabled$="[[isBusy]]"></vi-button>
                <vi-button icon="ChevronRight" inverse data-direction="next" on-tap="_navigate" busy$="[[isBusy]]" disabled$="[[isBusy]]"></vi-button>
            </nav>
        </template>
    </dom-if>
</header>
<vi-notification service-object="[[persistentObject]]"></vi-notification>
<main id="main">
    <vi-persistent-object-tab-presenter tab="[[tab]]"></vi-persistent-object-tab-presenter>
</main>
<footer class="horizontal layout">
    <div class="layout horizontal flex extra-actions">
        <dom-repeat items="[[dialogActions]]" as="action">
            <template>
                <vi-button label="[[action.definition.displayName]]" on-tap="_executeExtraAction" disabled$="[[persistentObject.isBusy]]"></vi-button>
            </template>
        </dom-repeat>
    </div>
    <div class="layout horizontal default-actions">
        <dom-if if="[[!readOnly]]">
            <template>
                <vi-button on-tap="_save" action-type="Default" label="[[saveLabel]]" disabled$="[[!canSave]]"></vi-button>
                <vi-button class="cancel" inverse on-tap="_cancel" disabled$="[[persistentObject.isBusy]]" hidden$="[[options.noCancel]]">
                    <dom-if if="[[!showNavigation]]">
                        <template>
                            <span>[[translateMessage('Cancel', isConnected)]]</span>
                        </template>
                    </dom-if>
                    <dom-if if="[[showNavigation]]">
                        <template>
                            <span hide$="[[persistentObject.isDirty]]">Close</span>
                            <span hide$="[[!persistentObject.isDirty]]">[[translateMessage('Cancel', isConnected)]]</span>
                        </template>
                    </dom-if>
                </vi-button>
            </template>
        </dom-if>
        <dom-if if="[[readOnly]]">
            <template>
                <vi-button on-tap="_cancel" action-type="Default" label="[[translateMessage('Close', isConnected)]]" disabled$="[[persistentObject.isBusy]]"></vi-button>
            </template>
        </dom-if>
    </div>
</footer>`); }
    constructor(persistentObject, _options = {}) {
        super();
        this.persistentObject = persistentObject;
        this._setOptions(_options || null);
        persistentObject.beginEdit();
    }
    _keyboardSave(e) {
        if (document.activeElement && document.activeElement instanceof HTMLInputElement)
            document.activeElement.blur();
        e.stopPropagation();
        this._save();
    }
    async _save() {
        if (this.options.save)
            this.options.save(this.persistentObject, () => this._close(this.persistentObject));
        else {
            const wasNew = this.persistentObject.isNew;
            await this.persistentObject.dialogSaveAction.execute();
            if (String.isNullOrWhiteSpace(this.persistentObject.notification) || this.persistentObject.notificationType !== "Error") {
                if (wasNew && this.persistentObject.ownerAttributeWithReference == null && this.persistentObject.stateBehavior.indexOf("OpenAfterNew") !== -1) {
                    try {
                        const po2 = await this.persistentObject.queueWork(() => this.persistentObject.service.getPersistentObject(this.persistentObject.parent, this.persistentObject.id, this.persistentObject.objectId));
                        this.persistentObject.service.hooks.onOpen(po2, true);
                        this._close(this.persistentObject);
                    }
                    catch (e) {
                        this._close(this.persistentObject);
                        const owner = this.persistentObject.ownerQuery || this.persistentObject.parent;
                        if (!!owner)
                            owner.setNotification(e);
                    }
                }
                else
                    this._close(this.persistentObject);
            }
        }
    }
    _close(persistentObject) {
        if (!this.showNavigation) {
            this.close(persistentObject);
            return;
        }
        this.persistentObject.beginEdit();
    }
    _cancel() {
        if (this.showNavigation && this.persistentObject.isDirty) {
            this.persistentObject.cancelEdit();
            this.persistentObject.beginEdit();
            return;
        }
        if (this.options.cancel)
            this.options.cancel(() => this.cancel());
        else if (this.persistentObject) {
            this.persistentObject.cancelEdit();
            this.cancel();
        }
    }
    _computeCanSave(isBusy, canExecute) {
        return !isBusy && canExecute;
    }
    _computeCancelLabel(app, isDirty) {
        if (!app)
            return null;
        return isDirty ? this.translateMessage("Cancel") : this.translateMessage("Close");
    }
    _computeSaveLabel(app) {
        if (!app)
            return null;
        let label = this.options.saveLabel;
        if (!label) {
            const endEdit = this.persistentObject.dialogSaveAction;
            if (endEdit)
                label = endEdit.displayName;
        }
        return label || this.translateMessage("Save");
    }
    _computeTab(persistentObject, isConnected) {
        if (!persistentObject || !isConnected)
            return null;
        const tab = persistentObject.tabs.find(tab => tab instanceof PersistentObjectAttributeTab);
        tab.columnCount = tab.columnCount > 1 ? tab.columnCount : 1;
        const width = parseInt(getComputedStyle(this).getPropertyValue("--vi-persistent-object-dialog-base-width-base")) * tab.columnCount;
        this.style.setProperty("--vi-persistent-object-dialog-computed-width", `${width}px`);
        return tab;
    }
    _computeReadOnly(tab) {
        return !!tab && !tab.parent.isNew && !tab.attributes.some(attribute => !attribute.isReadOnly && attribute.isVisible);
    }
    _computeDialogActions(persistentObject) {
        return persistentObject.actions.filter(a => a.definition.showedOn.some(s => s === "Dialog"));
    }
    _computeHideCancel(readOnly, noCancel) {
        return readOnly || noCancel;
    }
    _computeShowNavigation(persistentObject, app) {
        if (!persistentObject.ownerQuery || persistentObject.isNew || persistentObject.isBulkEdit)
            return false;
        const config = app.configuration.getPersistentObjectConfig(persistentObject);
        if (!config)
            return false;
        return Boolean.parse(config.configs["show-dialog-navigation"]);
    }
    _getNavigationIndex(persistentObject) {
        if (!persistentObject.ownerQuery)
            return;
        const index = persistentObject.ownerQuery.items.findIndex(i => i.id === persistentObject.objectId);
        return `${index + 1} / ${persistentObject.ownerQuery.totalItems}${persistentObject.ownerQuery.hasMore ? "+" : ""}`;
    }
    async _navigate(e) {
        if (this.persistentObject.isDirty) {
            const result = await this.app.showMessageDialog({
                title: this.service.getTranslatedMessage("PageWithUnsavedChanges"),
                noClose: true,
                message: this.service.getTranslatedMessage("ConfirmLeavePage"),
                actions: [
                    this.service.getTranslatedMessage("StayOnThisPage"),
                    this.service.getTranslatedMessage("LeaveThisPage")
                ]
            });
            if (result !== 1)
                return;
        }
        let index = this.persistentObject.ownerQuery.items.findIndex(i => i.id === this.persistentObject.objectId);
        index += (e.target.getAttribute("data-direction") === "previous" ? -1 : 1);
        if (!this.persistentObject.ownerQuery.hasMore)
            index = (index + this.persistentObject.ownerQuery.totalItems) % this.persistentObject.ownerQuery.totalItems;
        if (index < 0)
            return;
        const currentPath = this.app.path;
        try {
            let targetItem = this.persistentObject.ownerQuery.items[index] || await (this.persistentObject.ownerQuery.getItemsByIndex(index))[0];
            if (targetItem == null) {
                targetItem = await this.persistentObject.ownerQuery.queueWork(async () => {
                    return this.persistentObject.ownerQuery.items[index];
                });
                if (targetItem == null)
                    return;
            }
            if (currentPath !== this.app.path)
                return;
            this.persistentObject = await targetItem.getPersistentObject(true);
        }
        catch (e) {
            this.app.showAlert(e, "Error");
        }
    }
    _executeExtraAction(e) {
        const action = e.model.action;
        if (!action.canExecute)
            return;
        action.execute();
    }
    _onCaptureTab() {
    }
    _tabInnerSizeChanged(e) {
        e.stopPropagation();
        if (!e.detail.height)
            return;
        this.fire("sizechanged", e.detail, {
            bubbles: true,
            composed: true
        });
    }
};
PersistentObjectDialog = __decorate([
    WebComponent.register({
        properties: {
            persistentObject: Object,
            tab: {
                type: Object,
                computed: "_computeTab(persistentObject, isConnected)"
            },
            readOnly: {
                type: Boolean,
                computed: "_computeReadOnly(tab)"
            },
            canSave: {
                type: Boolean,
                computed: "_computeCanSave(persistentObject.isBusy, persistentObject.dialogSaveAction.canExecute)"
            },
            cancelLabel: {
                type: String,
                computed: "_computeCancelLabel(app, persistentObject.isDirty)"
            },
            saveLabel: {
                type: String,
                computed: "_computeSaveLabel(app)"
            },
            dialogActions: {
                type: Array,
                computed: "_computeDialogActions(persistentObject, app)"
            },
            options: {
                type: Object,
                readOnly: true
            },
            showNavigation: {
                type: Boolean,
                computed: "_computeShowNavigation(persistentObject, app)"
            },
        },
        forwardObservers: [
            "persistentObject.isBusy",
            "persistentObject.isDirty",
            "persistentObject.dialogSaveAction.canExecute"
        ],
        listeners: {
            "vi-persistent-object-tab-inner-size-changed": "_tabInnerSizeChanged"
        },
        keybindings: {
            "ctrl+s": "_keyboardSave"
        },
        mediaQueryAttributes: true
    })
], PersistentObjectDialog);

let PersistentObjectWizardDialog = class PersistentObjectWizardDialog extends Dialog {
    static get template() { return Dialog.dialogTemplate(html$3 `<style>:host {
  --vi-persistent-object-dialog-base-width-base: 400px;
}
:host header {
  padding-right: var(--theme-h5) !important;
}
:host header h4 {
  color: var(--vi-persistent-object-dialog-header-color, #333);
}
:host header h4 + vi-button {
  margin-left: var(--theme-h5);
}
:host header h4 + vi-button::part(icon) {
  fill: var(--vi-persistent-object-dialog-header-color, #333);
}
:host main {
  display: flex;
  flex-direction: column;
  padding: 0;
  max-height: calc(80vh - (var(--theme-h1) + var(--theme-h5) * 2) - (var(--theme-h2) + var(--theme-h4) * 2));
  min-height: calc(var(--theme-h2) * 3);
}
:host main > vi-persistent-object-tab-presenter {
  flex: 1;
  min-height: 0;
  min-width: 0;
  min-height: calc(var(--theme-h2) * 3);
}
:host main > vi-persistent-object-tab-presenter > vi-persistent-object-tab {
  position: static;
  width: 100%;
}
:host([is-phone]) main {
  width: 85vw;
}
:host([is-tablet]) main, :host([is-desktop]) main {
  min-width: 400px;
  max-width: var(--vi-persistent-object-dialog-computed-width);
}</style>

<header class="horizontal layout">
    <h4 class="flex">[[currentTab.label]]</h4>
    <vi-button inverse on-tap="cancel" icon="Remove"></vi-button>
</header>
<vi-notification service-object="[[persistentObject]]"></vi-notification>
<main id="main">
    <vi-persistent-object-tab-presenter tab="[[currentTab]]"></vi-persistent-object-tab-presenter>
</main>
<footer class="horizontal layout justified">
    <div>
        <vi-button inverse on-tap="_previous" label="[[translateMessage('Previous', isConnected)]]" disabled$="[[persistentObject.isBusy]]" hidden$="[[!canPrevious]]"></vi-button>
    </div>
    <div>
        <vi-button on-tap="_next" action-type="Default" label="[[translateMessage('Next', isConnected)]]" disabled$="[[!canNext]]" hidden$="[[canFinish]]"></vi-button>
        <vi-button on-tap="_finish" action-type="Default" label="[[translateMessage('Finish', isConnected)]]" disabled$="[[persistentObject.isBusy]]" hidden$="[[!canFinish]]"></vi-button>
    </div>
</footer>`); }
    constructor(persistentObject) {
        super();
        this.persistentObject = persistentObject;
    }
    ready() {
        super.ready();
        this.persistentObject.beginEdit();
        this._setCurrentTab(this.visibleTabs.find(tab => tab.isVisible));
    }
    connectedCallback() {
        super.connectedCallback();
        const width = parseInt(getComputedStyle(this).getPropertyValue("--vi-persistent-object-dialog-base-width-base")) * (this.currentTab.columnCount || 1);
        this.updateStyles({
            "--vi-persistent-object-dialog-computed-width": `${width}px`
        });
    }
    _tabInnerSizeChanged(e) {
        e.stopPropagation();
        if (!e.detail.height)
            return;
        this.$.main.style.height = `${e.detail.height}px`;
        this.fire("sizechanged", e.detail, {
            bubbles: true,
            composed: true
        });
    }
    _computeVisibleTabs(tabs) {
        return tabs.filter(tab => tab.isVisible);
    }
    _computeCanPrevious(currentTab) {
        return !!currentTab && this.visibleTabs.indexOf(currentTab) > 0;
    }
    _previous(e) {
        this._setCurrentTab(this.visibleTabs[Math.max(this.visibleTabs.indexOf(this.currentTab) - 1, 0)]);
    }
    _computeCanNext(currentTab, hasPendingAttributes, isBusy) {
        if (isBusy || hasPendingAttributes)
            return false;
        return !!currentTab && this.visibleTabs.indexOf(currentTab) < this.visibleTabs.length - 1;
    }
    _next(e) {
        this.persistentObject.queueWork(async () => {
            const result = await this.persistentObject.service.executeAction("Wizard.NextStep", this.persistentObject, undefined, undefined, { CurrentTab: this.currentTab.key, Attributes: this.currentTab.attributes.map(a => a.name).join("\n") });
            this.persistentObject.refreshFromResult(result);
            if (this.currentTab.attributes.some(attr => !!attr.validationError))
                return;
            this._setCurrentTab(this.visibleTabs[Math.min(this.visibleTabs.indexOf(this.currentTab) + 1, this.visibleTabs.length - 1)]);
        });
    }
    _computeCanFinish(currentTab, canNext) {
        if (canNext)
            return false;
        return !!currentTab && this.visibleTabs.indexOf(currentTab) === this.visibleTabs.length - 1;
    }
    _computeHasPendingAttributes(attributes) {
        return attributes && attributes.some(attr => attr.isRequired && (attr.value == null || (attr.rules && attr.rules.contains("NotEmpty") && attr.value === "")));
    }
    async _finish() {
        if (await this.persistentObject.save())
            this.close(this.persistentObject);
    }
    _onCaptureTab() {
    }
};
PersistentObjectWizardDialog = __decorate([
    WebComponent.register({
        properties: {
            persistentObject: Object,
            currentTab: {
                type: Object,
                readOnly: true
            },
            canPrevious: {
                type: Boolean,
                value: false,
                computed: "_computeCanPrevious(currentTab, persistentObject.tabs.*)"
            },
            canNext: {
                type: Boolean,
                value: true,
                computed: "_computeCanNext(currentTab, hasPendingAttributes, persistentObject.isBusy, persistentObject.tabs.*)"
            },
            canFinish: {
                type: Boolean,
                value: false,
                computed: "_computeCanFinish(currentTab, canNext)"
            },
            hasPendingAttributes: {
                type: Boolean,
                computed: "_computeHasPendingAttributes(currentTab.attributes, currentTab.attributes.*, persistentObject.lastUpdated)"
            },
            visibleTabs: {
                type: Array,
                computed: "_computeVisibleTabs(persistentObject.tabs, persistentObject.tabs.*)"
            }
        },
        forwardObservers: [
            "persistentObject.isBusy",
            "currentTab.attributes.*.value",
            "persistentObject.lastUpdated",
            "persistentObject.tabs.*.isVisible"
        ],
        listeners: {
            "vi-persistent-object-tab-inner-size-changed": "_tabInnerSizeChanged"
        },
        mediaQueryAttributes: true
    })
], PersistentObjectWizardDialog);

class AppServiceHooks extends AppServiceHooksBase {
    onSessionExpired() {
        this.app.redirectToSignIn();
        return Promise.resolve(false);
    }
    async onAction(args) {
        if (args.action === "ShowHelp") {
            if (!args.query) {
                let cacheEntry = new AppCacheEntryPersistentObject(args.persistentObject);
                cacheEntry = this.app.cacheEntries.find(ce => ce.isMatch(cacheEntry));
                if (cacheEntry && cacheEntry.selectedMasterTab) {
                    if (!args.parameters)
                        args.parameters = {};
                    args.parameters["selectedMasterTab"] = cacheEntry.selectedMasterTab.name;
                }
                else if (args.parameters && args.parameters["selectedMasterTab"])
                    args.parameters["selectedMasterTab"] = undefined;
            }
            return super.onAction(args);
        }
        else if (args.action === "viAudit")
            Promise.resolve().then(function () { return audit; });
        return super.onAction(args);
    }
    async onOpen(obj, replaceCurrent = false, forceFromAction) {
        if (obj instanceof PersistentObject$1) {
            const po = obj;
            if (po.stateBehavior.indexOf("AsWizard") >= 0) {
                await this.app.showDialog(new PersistentObjectWizardDialog(po));
                return;
            }
            else if (po.stateBehavior.indexOf("OpenAsDialog") >= 0) {
                await this.app.showDialog(new PersistentObjectDialog(po));
                return;
            }
            else if (!(this.app instanceof App))
                return;
            let path;
            if (!obj.forceFromAction && !forceFromAction) {
                path = this.app.getUrlForPersistentObject(po.id, po.objectId);
                const cacheEntry = new AppCacheEntryPersistentObject(po);
                const existing = this.app.cachePing(cacheEntry);
                if (existing)
                    this.app.cacheRemove(existing);
                this.app.cache(cacheEntry);
            }
            else {
                const fromActionId = guid();
                path = this.app.getUrlForFromAction(fromActionId);
                if (!po.isNew && po.objectId) {
                    const existingPoCacheEntry = this.app.cachePing(new AppCacheEntryPersistentObject(po));
                    if (existingPoCacheEntry)
                        this.app.cacheRemove(existingPoCacheEntry);
                }
                else if (po.isBulkEdit) {
                    po.bulkObjectIds.forEach(poId => {
                        const existingPoCacheEntry = this.app.cachePing(new AppCacheEntryPersistentObject(po.id, poId));
                        if (existingPoCacheEntry)
                            this.app.cacheRemove(existingPoCacheEntry);
                    });
                }
                this.app.cache(new AppCacheEntryPersistentObjectFromAction(po, fromActionId, this.app.path));
            }
            this.app.changePath(path, replaceCurrent);
        }
    }
    onClose(parent) {
        if (parent instanceof PersistentObject$1) {
            const cacheEntry = this.app.cachePing(new AppCacheEntryPersistentObjectFromAction(parent));
            if (cacheEntry instanceof AppCacheEntryPersistentObjectFromAction && cacheEntry.fromActionIdReturnPath) {
                if (App.removeRootPath(this.app.getUrlForFromAction(cacheEntry.fromActionId)) === App.removeRootPath(this.app.path))
                    history.back();
            }
        }
    }
    onClientOperation(operation) {
        switch (operation.type) {
            case "Refresh":
                const refresh = operation;
                if (refresh.queryId) {
                    const cacheEntry = this.app.cachePing(new AppCacheEntryQuery(refresh.queryId));
                    if (cacheEntry && cacheEntry.query && cacheEntry.query.hasSearched)
                        cacheEntry.query.search({ delay: refresh.delay });
                    const poCacheEntriesWithQueries = this.app.cacheEntries.filter(e => e instanceof AppCacheEntryPersistentObject && !!e.persistentObject && e.persistentObject.queries.length > 0);
                    poCacheEntriesWithQueries.forEach(poEntry => poEntry.persistentObject.queries.filter(q => q.id === refresh.queryId && q.hasSearched).forEach(q => q.search({ delay: refresh.delay })));
                }
                else {
                    const refreshPersistentObject = async () => {
                        const cacheEntry = this.app.cachePing(new AppCacheEntryPersistentObject(refresh.fullTypeName, refresh.objectId));
                        if (!cacheEntry || !cacheEntry.persistentObject)
                            return;
                        try {
                            const po = await this.app.service.getPersistentObject(cacheEntry.persistentObject.parent, cacheEntry.persistentObject.id, cacheEntry.persistentObject.objectId);
                            cacheEntry.persistentObject.refreshFromResult(po, true);
                        }
                        catch (e) {
                            cacheEntry.persistentObject.setNotification(e);
                        }
                    };
                    if (refresh.delay)
                        setTimeout(refreshPersistentObject, refresh.delay);
                    else
                        refreshPersistentObject();
                }
                break;
            default:
                super.onClientOperation(operation);
                break;
        }
    }
    async onQueryFileDrop(query, name, contents) {
        const config = this.app.configuration.getQueryConfig(query);
        const fileDropAction = query.actions[config.fileDropAction];
        const po = await fileDropAction.execute({ skipOpen: true });
        return query.queueWork(async () => {
            const fileDropAttribute = po.getAttribute(config.fileDropAttribute);
            if (!fileDropAttribute)
                return false;
            try {
                await fileDropAttribute.setValue(`${name}|${contents}`);
                return await po.save();
            }
            catch (e) {
                query.setNotification(e);
                return false;
            }
        }, true);
    }
    onRedirectToSignIn(keepUrl) {
        if (keepUrl && this.app.path.startsWith("sign-in/")) {
            this.app.changePath(this.app.path);
            return;
        }
        this.app.changePath("sign-in" + (keepUrl && this.app.path ? "/" + encodeURIComponent(App.removeRootPath(this.app.path).replace(/sign-in\/?/, "")).replace(/\./g, "%2E") : ""), true);
    }
    onRedirectToSignOut(keepUrl) {
        this.app.changePath("sign-out" + (keepUrl && this.app.path ? "/" + encodeURIComponent(App.removeRootPath(decodeURIComponent(this.app.path)).replace(/sign-in\/?/, "")).replace(/\./g, "%2E") : ""), true);
    }
}

var App_1;
let App = App_1 = class App extends AppBase {
    static get template() {
        const baseTemplate = AppBase.template;
        baseTemplate.content.appendChild(html$3 `<style>:host {
  display: flex;
  width: 100vw;
  height: 100vh;
  box-sizing: border-box;
  font-family: "Open Sans", Arial, Helvetica, sans-serif;
}
:host vi-app-route-presenter {
  display: flex;
  flex: 1;
  min-width: 0;
}
:host vi-app-route-presenter > vi-app-route, :host vi-app-route-presenter > ::slotted(*) {
  flex: 1;
  min-width: 0;
}</style>

<dom-if if="[[isProfiling]]">
    <template>
        <vi-profiler service="[[service]]"></vi-profiler>
    </template>
</dom-if>
<dom-if if="[[showMenu]]" restamp>
    <template>
        <vi-menu menu label="[[label]]" program-units="[[service.application.programUnits]]" active-program-unit="[[programUnit]]">
            <slot name="menu-label" slot="label"></slot>
            <slot name="menu-footer" slot="footer"></slot>
        </vi-menu>
    </template>
</dom-if>
<vi-app-route-presenter path="{{pathExtended}}">
    <vi-app-route route="">
        <template></template>
    </vi-app-route>
    <vi-app-route route="query.:id" route-alt="Query.:id">
        <template>
            <vi-query-presenter></vi-query-presenter>
        </template>
    </vi-app-route>
    <vi-app-route route=":programUnitName/query.:id" route-alt=":programUnitName/Query.:id">
        <template>
            <vi-query-presenter></vi-query-presenter>
        </template>
    </vi-app-route>
    <vi-app-route route="persistent-object.:id(/:objectId*)" route-alt="PersistentObject.:id(/:objectId*)">
        <template>
            <vi-persistent-object-presenter></vi-persistent-object-presenter>
        </template>
    </vi-app-route>
    <vi-app-route route=":programUnitName/persistent-object.:id(/:objectId*)" route-alt=":programUnitName/PersistentObject.:id(/:objectId*)">
        <template>
            <vi-persistent-object-presenter></vi-persistent-object-presenter>
        </template>
    </vi-app-route>
    <vi-app-route route=":programUnitName/from-action/:fromActionId">
        <template>
            <vi-persistent-object-presenter></vi-persistent-object-presenter>
        </template>
    </vi-app-route>
    <vi-app-route route=":programUnitName(/)">
        <template>
            <vi-program-unit-presenter></vi-program-unit-presenter>
        </template>
    </vi-app-route>
    <vi-app-route class="fit" route="sign-in(/:stateOrReturnUrl*)(/:returnUrl*)" route-alt="SignIn(/:stateOrReturnUrl*)(/:returnUrl*)" allow-signed-out>
        <template>
            <vi-sign-in label="[[app.label]]" logo="[[app.signInLogo]]">
                <slot name="sign-in-background"></slot>
            </vi-sign-in>
            <slot name="sign-in-footer"></slot>
        </template>
    </vi-app-route>
    <vi-app-route route="sign-out(/)(:returnUrl*)" route-alt="SignOut(/)(:returnUrl*)" allow-signed-out>
        <template>
            <vi-sign-out></vi-sign-out>
        </template>
    </vi-app-route>
    <slot name="app-route"></slot>
</vi-app-route-presenter>
<dom-if if="[[service.application.hasManagement]]">
    <template>
        <vi-popup-menu id="viConfigure" ctrl-key context-menu-only></vi-popup-menu>
    </template>
</dom-if>`.content);
        return baseTemplate;
    }
    constructor(hooks = new AppServiceHooks()) {
        super(hooks);
        this._cache = [];
        if (!this.label)
            this.label = this.title;
    }
    _initPathRescue() {
        Path.rescue(() => {
            const path = App_1.removeRootPath(Path.routes.current);
            let mappedPath = this._convertPath(this.app.service.application, path);
            if (mappedPath !== path)
                Path["dispatch"](Path.routes.rootPath + mappedPath);
            else if (path.contains("/")) {
                const parts = path.split("/");
                const kebabPath = [parts[0].toKebabCase(), parts[1].toKebabCase(), ...parts.slice(2)].join("/");
                const mappedKebabPath = this._convertPath(this.app.service.application, kebabPath);
                if (kebabPath !== mappedKebabPath) {
                    microTask.run(() => this.changePath(kebabPath, true));
                    return;
                }
            }
            this.path = path;
        });
    }
    async _pathChanged(path) {
        await this.initialize;
        if (path !== this.path)
            return;
        path = App_1.removeRootPath(this._convertPath(this.service.application, path));
        if (this.service && this.service.isSignedIn && path === "") {
            let programUnit = this.programUnit;
            if (!programUnit && this.service.application.programUnits.length > 0)
                programUnit = this.service.application.programUnits[0];
            if (programUnit) {
                if (programUnit.openFirst && programUnit.path && path !== programUnit.path) {
                    microTask.run(() => this.changePath(programUnit.path));
                    return;
                }
                else {
                    const config = this.app.configuration.getProgramUnitConfig(programUnit.name);
                    if (!!config && config.hasTemplate) {
                        microTask.run(() => this.changePath(programUnit.path));
                        return;
                    }
                }
            }
        }
        ServiceBus.send(this, "path-changed", { path: path });
    }
    _pathExtendedChanged(pathExtended) {
        this.path = pathExtended;
    }
    _computeProgramUnit(application, path) {
        path = this._convertPath(application, path);
        const mappedPathRoute = Path.match(Path.routes.rootPath + App_1.removeRootPath(path), true);
        if (application) {
            if (mappedPathRoute && mappedPathRoute.params && mappedPathRoute.params.programUnitName)
                return application.programUnits.find(pu => pu.nameKebab === mappedPathRoute.params.programUnitName || pu.name === mappedPathRoute.params.programUnitName) || application.programUnits[0];
            else if (application.programUnits.length > 0)
                return application.programUnits[0];
        }
        return null;
    }
    _computeShowMenu(application, noMenu) {
        if (!application || noMenu)
            return false;
        return true;
    }
    _hookWindowBeforeUnload(isConnected) {
        if (this._beforeUnloadEventHandler) {
            window.removeEventListener("beforeunload", this._beforeUnloadEventHandler);
            this._beforeUnloadEventHandler = null;
        }
        if (isConnected)
            window.addEventListener("beforeunload", this._beforeUnloadEventHandler = this._beforeUnload.bind(this));
    }
    _beforeUnload(e) {
        if (this._cache.some(entry => entry instanceof AppCacheEntryPersistentObject && !!entry.persistentObject && entry.persistentObject.isDirty && entry.persistentObject.actions.some(a => a.name === "Save" || a.name === "EndEdit")) && this.service) {
            const confirmationMessage = this.service.getTranslatedMessage("PagesWithUnsavedChanges");
            (e || window.event).returnValue = confirmationMessage;
            return confirmationMessage;
        }
    }
    async _configureContextmenu(e) {
        if (!this.service || !this.service.application)
            return;
        const configureItems = e["vi:configure"];
        if (!this.service.application.hasManagement || !configureItems?.length || window.getSelection().toString()) {
            e.stopImmediatePropagation();
            return;
        }
        e.stopPropagation();
        e.preventDefault();
        const popupMenu = this.shadowRoot.querySelector("#viConfigure");
        Array.from(popupMenu.children).forEach(item => popupMenu.removeChild(item));
        configureItems.forEach(item => popupMenu.appendChild(item));
        popupMenu.$.popup.style.left = e.pageX + "px";
        popupMenu.$.popup.style.top = e.pageY + "px";
        await popupMenu.popup();
    }
    _cleanUpOnSignOut(isSignedIn) {
        if (isSignedIn === false) {
            this.cacheClear();
            super._cleanUpOnSignOut(isSignedIn);
        }
    }
    cache(entry) {
        if (this._cache.length >= this.cacheSize)
            this._cache.splice(0, this._cache.length - this.cacheSize);
        let cacheEntry = this.cachePing(entry);
        if (!cacheEntry)
            this._cache.push(cacheEntry = entry);
        return cacheEntry;
    }
    cachePing(entry) {
        const cacheEntry = this._cache.slice().reverse().find(e => entry.isMatch(e));
        if (cacheEntry) {
            this._cache.remove(cacheEntry);
            this._cache.push(cacheEntry);
        }
        return cacheEntry;
    }
    cacheRemove(key) {
        const entry = this._cache.find(e => key.isMatch(e));
        if (entry)
            this._cache.remove(entry);
    }
    get cacheEntries() {
        return this._cache;
    }
    cacheClear() {
        this._cache = [];
    }
    getUrlForPersistentObject(id, objectId, pu = this.programUnit) {
        const persistentObjects = this.service.application.routes.persistentObjects;
        for (const type in persistentObjects) {
            if (persistentObjects[type] === id)
                return (pu ? pu.nameKebab + "/" : "") + type + (objectId ? "/" + objectId : "");
        }
        return (pu ? pu.nameKebab + "/" : "") + `persistent-object.${id}${objectId ? "/" + objectId : ""}`;
    }
    getUrlForQuery(id, pu = this.programUnit) {
        const queries = this.service.application.routes.persistentObjects;
        for (const name in queries) {
            if (queries[name] === id)
                return (pu ? pu.nameKebab + "/" : "") + `${name}`;
        }
        return (pu ? pu.nameKebab + "/" : "") + `query.${id}`;
    }
    getUrlForFromAction(id, pu = this.programUnit) {
        return (pu ? pu.nameKebab + "/" : "") + `from-action/${id}`;
    }
    async _importConfigs(configs, isConnected) {
        if (!configs || !isConnected)
            return;
    }
    _convertPath(application, path) {
        if (application) {
            let match = application.poRe.exec(path);
            if (match)
                path = (match[1] || "") + "persistent-object." + application.routes.persistentObjects[match[3].toKebabCase()] + (match[4] || "");
            else {
                match = application.queryRe.exec(path);
                if (match)
                    path = (match[1] || "") + "query." + application.routes.queries[match[3].toKebabCase()];
            }
        }
        return path;
    }
};
App = App_1 = __decorate([
    WebComponent.register({
        properties: {
            cacheSize: {
                type: Number,
                value: 25,
                reflectToAttribute: true
            },
            pathExtended: {
                type: String,
                observer: "_pathExtendedChanged"
            },
            programUnit: {
                type: Object,
                computed: "_computeProgramUnit(service.application, path)"
            },
            noMenu: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            label: {
                type: String,
                reflectToAttribute: true
            },
            isProfiling: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "op_every(service.isSignedIn, service.profile)"
            },
            signInLogo: String,
            showMenu: {
                type: Boolean,
                computed: "_computeShowMenu(service.application, noMenu)"
            }
        },
        observers: [
            "_hookWindowBeforeUnload(isConnected)"
        ],
        listeners: {
            "contextmenu": "_configureContextmenu"
        },
        forwardObservers: [
            "service.profile"
        ]
    })
], App);

let Overflow = class Overflow extends WebComponent {
    static get template() { return html$3 `<style>:host {
  height: var(--theme-h1);
  line-height: var(--theme-h1);
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: row;
  position: relative;
}
:host .visibleContainer {
  overflow: hidden;
}
:host .visible {
  display: inline-flex;
  position: relative;
  gap: var(--vi-overflow-gap);
}
:host .visible > div#first {
  width: 0;
  opacity: 0;
  margin-left: calc(var(--vi-overflow-gap, 0) * -1);
}
:host #overflowPopup {
  position: relative;
}
:host #overflowPopup button[slot=header] {
  display: block;
  width: var(--theme-h1);
  font-weight: bold;
}
:host(:not([has-overflow])) #overflowPopup {
  display: none;
}
:host vi-popup[open] button[slot=header] {
  background-color: var(--color-faint);
}</style>

<div class="flex relative visibleContainer">
    <div class="visible horizontal layout wrap relative">
        <div id="first"></div>
        <slot id="visible"></slot>
        <vi-size-tracker on-sizechanged="_visibleSizeChanged"></vi-size-tracker>
    </div>
    <vi-size-tracker on-sizechanged="_visibleContainerSizeChanged"></vi-size-tracker>
</div>
<vi-popup id="overflowPopup" on-popup-opening="_popupOpening" on-popup-closed="_popupClosed">
    <vi-button slot="header" inverse label="[[_getLabel(label, type)]]" icon="[[_getIcon(icon, type)]]" part="button"></vi-button>
    <div id="overflowChildren" class="vertical layout">
        <slot id="overflow" name="overflow"></slot>
    </div>
</vi-popup>`; }
    _visibleContainerSizeChanged(e, detail) {
        if (this._previousHeight === detail.height)
            return;
        this.$.first.style.height = `${this._previousHeight = detail.height}px`;
    }
    _visibleSizeChanged(e, detail) {
        const popup = this.$.overflowPopup;
        if (!popup.open) {
            animationFrame.run(() => {
                const children = this._getChildren();
                children.forEach(child => child.removeAttribute("slot"));
                this._setHasOverflow(children.reverse().some(child => child.offsetTop > 0));
            });
        }
        else
            this._popupOpening();
    }
    _getChildren() {
        const visibleSlot = this.$.visible;
        const overflowSlot = this.$.overflow;
        return visibleSlot.assignedNodes().concat(overflowSlot.assignedNodes()).filter(child => child instanceof HTMLElement);
    }
    _popupOpening() {
        this._overflownChildren = this._getChildren().filter(child => child.offsetTop > 0);
        this._overflownChildren.forEach(child => {
            child.setAttribute("slot", "overflow");
            child.setAttribute("overflow", "");
        });
        flush$1();
    }
    _popupClosed() {
        this._overflownChildren.forEach(child => {
            child.removeAttribute("slot");
            child.removeAttribute("overflow");
        });
        flush$1();
        this._setHasOverflow(this._overflownChildren.some(child => child.offsetTop > 0));
    }
    _getIcon(icon, type) {
        return type === "icon" || type === "icon-label" ? icon : null;
    }
    _getLabel(label, type) {
        return type === "label" || type === "icon-label" ? label : null;
    }
};
Overflow = __decorate([
    WebComponent.register({
        properties: {
            hasOverflow: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            icon: {
                type: String,
            },
            label: {
                type: String,
                value: "…"
            },
            type: {
                type: String,
                value: "label"
            }
        }
    })
], Overflow);

let ActionBar = class ActionBar extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  height: var(--theme-h1);
  background-color: var(--vi-action-bar-background-color, #F9F9F9);
}
:host([isEmpty]) {
  display: none !important;
}
:host .actions {
  overflow: hidden;
}
:host .action vi-icon[hasResource] {
  padding-right: 2px;
}
:host vi-action-button {
  text-align: left;
}
:host vi-overflow {
  --vi-overflow-gap: var(--vi-action-bar-gap, 0);
}
:host vi-overflow::part(button) {
  width: var(--theme-h1);
}
:host .search {
  border-left: 1px solid #EAEAEA;
  padding: 0 var(--theme-h5);
}
:host .search vi-input-search {
  min-width: 16em;
  height: var(--theme-h2);
  box-sizing: border-box;
}
:host .search vi-input-search::part(input) {
  box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: calc(var(--theme-h1) - var(--theme-h2));
  color: #333;
}
:host .search vi-input-search::part(input):focus {
  background-color: white;
  border-color: #EAEAEA;
}
:host .search vi-input-search::part(input)::placeholder {
  color: #B3B3B3;
}
:host .search vi-input-search::part(search), :host .search vi-input-search::part(reset) {
  fill: #B3B3B3;
}
:host([accent]) {
  --color: var(--theme-accent-color);
  --color-light: var(--theme-accent-color-light);
  --color-lighter: var(--theme-accent-color-lighter);
  --color-dark: var(--theme-accent-color-dark);
  --color-darker: var(--theme-accent-color-darker);
  --color-faint: var(--theme-accent-color-faint);
  --color-semi-faint: var(--theme-accent-color-semi-faint);
  --color-rgb: var(--theme-accent-color-rgb);
}</style>

<vi-overflow class="flex">
    <dom-repeat items="[[unpinnedActions]]" as="action">
        <template>
            <vi-action-button action="[[action]]" inverse></vi-action-button>
        </template>
    </dom-repeat>
</vi-overflow>
<dom-repeat items="[[pinnedActions]]" as="action">
    <template>
        <vi-action-button action="[[action]]" no-label inverse></vi-action-button>
    </template>
</dom-repeat>
<dom-if if="[[hasCharts]]">
    <template>
        <vi-query-chart-selector query="[[serviceObject]]"></vi-query-chart-selector>
    </template>
</dom-if>
<dom-if if="[[canSearch]]">
    <template>
        <div class="search layout horizontal center-center">
            <vi-input-search value="{{serviceObject.textSearch}}" on-search="_search"></vi-input-search>
        </div>
    </template>
</dom-if>`; }
    filterActions(actions, pinned) {
        return actions.filter(a => a.isPinned === pinned);
    }
    _computeHasCharts(charts, app) {
        return !!charts && !!charts.find(c => !!this.app.configuration.getQueryChartConfig(c.type));
    }
    _search() {
        if (!this.canSearch)
            return;
        const query = this.serviceObject;
        query.search();
    }
    _computePinnedActions() {
        return this.serviceObject && this.serviceObject.actions ? Array.from(this._transformActionsWithGroups(this.serviceObject.actions.filter(action => action.isPinned))) : [];
    }
    _computeUnpinnedActions() {
        return this.serviceObject && this.serviceObject.actions ? Array.from(this._transformActionsWithGroups(this.serviceObject.actions.filter(action => !action.isPinned))) : [];
    }
    *_transformActionsWithGroups(actions) {
        const actionGroups = {};
        for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            if (!action.group) {
                yield action;
                continue;
            }
            if (!actionGroups[action.group.name])
                yield (actionGroups[action.group.name] = action.group);
        }
    }
    _computeCanSearch(serviceObject) {
        return serviceObject instanceof Query$1 && serviceObject.actions["Filter"] != null;
    }
    _computeNoActions(pinnedActions, unpinnedActions) {
        const actions = (pinnedActions || []).concat(unpinnedActions || []);
        if (actions.length === 0)
            return true;
        return !actions.filter(a => a.isVisible).length;
    }
};
ActionBar = __decorate([
    WebComponent.register({
        properties: {
            serviceObject: Object,
            pinnedActions: {
                type: Array,
                computed: "_computePinnedActions(serviceObject)"
            },
            unpinnedActions: {
                type: Array,
                computed: "_computeUnpinnedActions(serviceObject)"
            },
            hasCharts: {
                type: Boolean,
                computed: "_computeHasCharts(serviceObject.charts, app)",
                value: false
            },
            canSearch: {
                type: Boolean,
                computed: "_computeCanSearch(serviceObject)"
            },
            noActions: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeNoActions(pinnedActions, unpinnedActions)"
            },
            accent: {
                type: Boolean,
                reflectToAttribute: true
            },
        },
        forwardObservers: [
            "serviceObject.charts"
        ]
    })
], ActionBar);

let Audit = class Audit extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: column;
  --vi-audit-spacing: var(--theme-h2);
}
:host header {
  background-color: var(--color);
  color: white;
  line-height: var(--theme-h1);
  height: var(--theme-h1);
  font-size: calc(var(--theme-h5) + var(--theme-h4));
  white-space: nowrap;
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  padding-left: var(--theme-h4);
  z-index: 2;
  padding-right: 4px;
}
:host nav {
  display: flex;
  flex-direction: column-reverse;
  background-color: var(--vi-action-bar-background-color, #F9F9F9);
  box-shadow: var(--theme-box-shadow);
  margin-bottom: 3px;
  height: var(--theme-h1);
}
:host nav .search {
  border-left: 1px solid #EAEAEA;
  padding: 0 var(--theme-h5);
}
:host nav vi-input-search {
  min-width: 16em;
  height: var(--theme-h2);
  box-sizing: border-box;
}
:host nav vi-input-search::part(input) {
  box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: calc(var(--theme-h1) - var(--theme-h2));
  color: #333;
}
:host nav vi-input-search::part(input)::placeholder {
  color: #B3B3B3;
}
:host nav vi-input-search::part(input):focus {
  background-color: white;
  border-color: #EAEAEA;
}
:host nav vi-input-search::part(search) {
  fill: #B3B3B3;
}
:host main {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  padding: var(--theme-h5) var(--theme-h3) var(--theme-h3) var(--theme-h3);
  color: #333;
  fill: #333;
}
:host main a.today > h1 {
  padding: 0;
  font-size: 26px;
  margin: var(--theme-h4) 0;
  font-weight: 600;
}
:host main .date {
  padding: var(--theme-h4) 0;
}
:host main .date .day {
  font-size: 28px;
  line-height: var(--theme-h1);
  font-weight: bold;
  margin-right: 3px;
}
:host main .date .dayOfWeek {
  font-weight: bold;
  font-size: 10px;
  line-height: calc(var(--theme-h1) / 2);
  transform: translateY(4px);
}
:host main .date .monthYear {
  color: #777;
  font-size: 11px;
  line-height: calc(var(--theme-h1) / 2);
  transform: translateY(-4px);
}
:host main .date:last-of-type {
  display: none !important;
}
:host main vi-spinner {
  margin-left: var(--theme-h4);
}
:host main .entry {
  color: #333 !important;
}
:host main .entry:hover {
  background-color: var(--color-faint);
  cursor: pointer;
}
:host main .entry:hover label {
  cursor: pointer;
}
:host main .entry:hover .expand {
  display: flex;
}
:host main .entry:not(:last-of-type) .line {
  bottom: -16px !important;
}
:host main .entry a {
  padding: var(--theme-h4) var(--theme-h4) var(--theme-h4) 0;
  text-decoration: none;
  color: #333 !important;
}
:host main .entry .timeline {
  margin: var(--theme-h4) 0 0 var(--theme-h4);
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: var(--theme-h4);
}
:host main .entry .timeline .dot {
  position: relative;
  background-color: white;
  border: 2px solid var(--color);
  border-radius: 50%;
  width: var(--theme-h4);
  height: var(--theme-h4);
  box-sizing: border-box;
  margin-top: calc(var(--theme-h5) / 2);
  margin-right: var(--theme-h4);
  z-index: 2;
}
:host main .entry .timeline .line {
  position: absolute;
  top: var(--theme-h4);
  left: var(--theme-h5);
  bottom: 0;
  content: "";
  border-left: 2px solid #eee;
  width: 1px;
  z-index: 1;
}
:host main .entry .time {
  padding-left: var(--theme-h2);
  width: 100px;
  box-sizing: border-box;
}
:host main .entry .time span {
  font-weight: 600;
}
:host main .entry .time + div {
  flex: 1;
}
:host main .entry .content vi-icon.icon {
  align-self: flex-start;
  width: var(--theme-h2);
}
:host main .entry .content .action {
  transform: translateY(-2px);
  font-weight: 600;
}
:host main .entry .content .grid {
  display: grid;
  grid-template-columns: var(--theme-h2) max-content auto;
  line-height: var(--theme-h3);
  transform: translateY(-2px);
}
:host main .entry .content .grid > * {
  align-self: center;
}
:host main .entry .content .grid > vi-icon {
  min-width: var(--theme-h2);
}
:host main .entry .content .grid > label {
  font-weight: 600;
  padding-right: var(--theme-h5);
  white-space: nowrap;
}
:host main .entry .content .grid > label.user {
  grid-column: 2/-1;
}
:host main .entry .content .grid > label.change {
  grid-column: 2;
}
:host main .entry .content .grid > pre {
  overflow: hidden;
  text-overflow: ellipsis;
}
:host main .entry .content .grid:not(:first-of-type) {
  line-height: var(--theme-h2);
}
:host main .entry .content .notification {
  font-weight: bold;
  padding-left: var(--theme-h2);
}
:host main .entry .content .notification[type="0"] {
  fill: var(--theme-color-error);
  color: var(--theme-color-error);
}
:host main .entry .content .notification[type="1"] {
  fill: var(--theme-color-notice);
  color: var(--theme-color-notice);
}
:host main .entry .content .notification[type="2"] {
  fill: var(--theme-color-ok);
  color: var(--theme-color-ok);
}
:host main .entry .content .notification[type="3"] {
  fill: var(--theme-color-warning);
  color: var(--theme-color-warning);
}
:host main .entry .expand {
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  display: none;
  align-items: center;
  justify-content: center;
  width: var(--theme-h1);
  background: var(--color-lighter);
}
:host main .entry .expand vi-icon {
  --vi-icon-width: 24px;
  --vi-icon-height: 24px;
  fill: var(--color);
  transform: none;
  transition: transform 0.3s ease-out;
}
:host main .entry .expand vi-icon[expanded] {
  transform: rotate(180deg);
}
:host main .entry .info {
  padding: var(--theme-h4) var(--theme-h4) var(--theme-h4) 0;
  margin: var(--theme-h4) 0 0 var(--theme-h2);
  border-top: 1px solid #f0f0f0;
}
:host main .entry .info .infoItem {
  padding: var(--theme-h5) var(--theme-h5) 0 0;
}
:host main .entry .info label {
  display: block;
  color: #aaa;
  font-size: 12px;
}
:host main .entry .info label + span {
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
:host main .entry .info:not([expanded]) {
  display: none !important;
}</style>

<header>
    <span>[[persistentObject.breadcrumb]]</span>
</header>
<nav>
    <div class="search layout horizontal center-center">
        <vi-input-search value="{{search}}" on-search="_filter"></vi-input-search>
    </div>
</nav>
<vi-scroller class="flex" no-horizontal vertical-scroll-offset="{{verticalScrollOffset}}">
    <main>
        <dom-repeat items="[[groups]]" as="group">
            <template>
                <div class="group">
                    <dom-if if="[[group.today]]">
                        <template>
                            <div class="today"><h1>[[translations.Today]]</h1></div>
                        </template>
                    </dom-if>
                    <dom-if if="[[!group.today]]">
                        <template>
                            <div class="date layout horizontal" hidden$="[[group.today]]">
                                <div class="day">[[group.day]]</div>
                                <div>
                                    <div class="dayOfWeek">[[group.dayOfWeek]]</div>
                                    <div class="monthYear">[[group.monthYear]]</div>
                                </div>
                            </div>
                        </template>
                    </dom-if>
                    <dom-repeat items="[[group.entries]]" as="entry" filter="[[_filterEntries(filter)]]">
                        <template>
                            <div class="entry layout horizontal relative">
                                <div class="timeline">
                                    <div class="dot"></div>
                                    <div class="line"></div>
                                </div>
                                <a href$="[[entry.href]]" class="layout horizontal flex" on-tap="_open">
                                    <div class="time">
                                        <div class="title layout horizontal">
                                            <span>[[entry.time]]</span>
                                        </div>
                                    </div>
                                    <dom-if if="[[!entry.busy]]">
                                        <template>
                                            <div class="content layout vertical relative">
                                                <div class="grid">
                                                    <vi-icon source="Action_viImpersonate"></vi-icon>
                                                    <label class="user">[[entry.user]]&nbsp;[[entry.originalUser]]</label>
                                                    <dom-repeat items="[[entry.changes]]" as="change">
                                                        <template>
                                                            <label class="change">[[change.name]]:</label>
                                                            <pre>[[change.value]]</pre>
                                                        </template>
                                                    </dom-repeat>
                                                </div>
                                                <dom-if if="[[entry.outData.notification]]">
                                                    <template>
                                                        <div class="notification" type$="[[entry.outData.notificationType]]">
                                                            <span>[[entry.outData.notification]]</span>
                                                        </div>
                                                    </template>
                                                </dom-if>
                                                <div class="info" expanded$="[[entry.expanded]]">
                                                    <vi-grid no-spacing>
                                                        <dom-repeat items="[[_moreInfo(entry)]]">
                                                            <template>
                                                                <div class="infoItem" desktop-4 tablet-4 phone-4>
                                                                    <label>[[item.label]]</label>
                                                                    <span>[[item.displayValue]]</span>
                                                                </div>
                                                            </template>
                                                        </dom-repeat>
                                                    </vi-grid>
                                                </div>
                                            </div>
                                        </template>
                                    </dom-if>
                                    <div class="busy layout horizontal center-center" hidden$="[[!entry.busy]]">
                                        <vi-spinner block></vi-spinner>
                                    </div>
                                </a>
                                <div class="expand" on-tap="_expand">
                                    <vi-icon source="CaretDown" expanded$="[[entry.expanded]]"></vi-icon>
                                </div>
                            </div>
                        </template>
                    </dom-repeat>
                </div>
            </template>
        </dom-repeat>
    </main>
</vi-scroller>`; }
    _computeQuery(persistentObject) {
        const logsVerbose = persistentObject.getQuery("LogsVerbose");
        logsVerbose.actions.forEach(a => {
            a.isVisible = false;
        });
        return logsVerbose;
    }
    _syncVerticalScrollOffset(verticalScrollOffset, persistentObject, isConnected) {
        if (persistentObject && !isConnected && !isNaN(verticalScrollOffset))
            persistentObject.__audit_verticalScrollOffset__ = verticalScrollOffset;
        else if (!isNaN(persistentObject.__audit_verticalScrollOffset__)) {
            flush$1();
            const newVerticalScrollOffset = persistentObject.__audit_verticalScrollOffset__;
            persistentObject.__audit_verticalScrollOffset__ = Number.NaN;
            this.verticalScrollOffset = newVerticalScrollOffset;
        }
    }
    _syncFilter(filter, persistentObject, isConnected) {
        if (persistentObject && !isConnected)
            persistentObject.__audit_filter__ = filter;
        else if (persistentObject.__audit_filter__) {
            flush$1();
            const filter = persistentObject.__audit_filter__;
            persistentObject.__audit_filter__ = null;
            this._setFilter(this.search = filter);
        }
    }
    async _itemsChanged(items, persistentObject) {
        if (!items)
            return;
        if (this._updating)
            await this._updating;
        let done;
        this._updating = new Promise((resolve) => done = resolve);
        this._setGroups(persistentObject.__audit_groups__ || (persistentObject.__audit_groups__ = []));
        const newItems = items.slice(this.groups.reduce((prev, curr) => prev + curr.entries.length, 0));
        for (let item of newItems) {
            const createdOn = item.values.CreatedOn;
            if (!this._lastGroup || this._lastGroup.date.getDate() !== createdOn.getDate() || this._lastGroup.date.getMonth() !== createdOn.getMonth() || this._lastGroup.date.getFullYear() !== createdOn.getFullYear()) {
                const today = new Date();
                this._lastGroup = {
                    today: today.getDate() === createdOn.getDate() && today.getMonth() === createdOn.getMonth() && today.getFullYear() === createdOn.getFullYear(),
                    date: createdOn,
                    day: createdOn.getDate(),
                    dayOfWeek: String.format("{0:dddd}", createdOn),
                    monthYear: String.format("{0:MMMM yyyy}", createdOn),
                    entries: []
                };
                this.push("groups", this._lastGroup);
            }
            const actionName = item.getValue("Action").replace("PersistentObject.", "");
            const action = this.service.actionDefinitions[actionName];
            const logEntry = {
                item: item,
                obj: null,
                actionName: actionName,
                action: action ? action.displayName : actionName,
                time: String.format("{0:T}", createdOn),
                user: item.values.User,
                originalUser: item.values.OriginalUser ? ` (${item.values.OriginalUser})` : "",
                busy: true,
                changes: [],
                inData: null,
                outData: null,
                href: this.computePath(`${this.app.programUnit.name}/PersistentObject.${item.query.persistentObject.id}/${item.id}`),
                groupIndex: this.groups.length - 1,
                entryIndex: this.groups[this.groups.length - 1].entries.length
            };
            this.push(`groups.${logEntry.groupIndex}.entries`, logEntry);
            item.query.parent = null;
            logEntry.obj = await item.getPersistentObject();
            const [poIn, poOut] = await Promise.all([
                logEntry.obj.getAttribute("IncomingDataReference").getPersistentObject(),
                logEntry.obj.getAttribute("OutgoingDataReference").getPersistentObject()
            ]);
            logEntry.inData = this.service.hooks.onConstructPersistentObject(this.service, this._getInData(poIn).parent);
            logEntry.changes = logEntry.inData.attributes.filter(a => a.isValueChanged).map(a => {
                return {
                    name: a.label,
                    value: a.displayValue
                };
            });
            logEntry.outData = this.service.hooks.onConstructPersistentObject(this.service, this._getOutData(poOut).result);
            this.set(`groups.${this.groups.length - 1}.entries.${logEntry.entryIndex}.busy`, false);
        }
        done(undefined);
    }
    _getInData(poIn) {
        const data = poIn.getAttributeValue("Data");
        if (data[0] === "{")
            return JSON.parse(data);
        const dataLines = data.split("\r\n");
        const boundary = dataLines[0];
        const blocks = [];
        for (let line of dataLines) {
            if (line.startsWith(boundary)) {
                blocks.push([]);
                continue;
            }
            blocks[blocks.length - 1].push(line);
        }
        const dataBlockIndex = blocks.findIndex(block => block[0].contains(`name="data"`));
        const dataBlock = blocks[dataBlockIndex];
        const dataLineIndex = dataBlock.findIndex(line => line[0] === "{");
        return JSON.parse(dataBlock.slice(dataLineIndex).join("\r\n"));
    }
    _getOutData(poOut) {
        const data = poOut.getAttributeValue("Data");
        if (data[0] === "{")
            return JSON.parse(data);
        const div = document.createElement("div");
        div.innerHTML = data;
        let value = div.querySelector("textarea").value;
        if (value.startsWith("<![CDATA["))
            value = value.substring("<![CDATA[".length, value.length - "]]>".length);
        return JSON.parse(value);
    }
    _filterEntries(filter) {
        if (!this.filter)
            return () => true;
        filter = this.filter.toLowerCase();
        return entry => {
            if (entry.changes.some(c => c.name.toLowerCase().contains(filter) || c.value.toLowerCase().contains(filter)))
                return true;
            if (entry.outData && entry.outData.notification && entry.outData.notification.toLowerCase().contains(filter))
                return true;
            return false;
        };
    }
    _entryActionIcon(item) {
        const icon = `Action_${item.actionName}`;
        return !exists(icon) ? "Action_Default$" : icon;
    }
    _open(e) {
        const item = e.model.entry;
        const sourceEvent = e.detail.sourceEvent;
        if (sourceEvent && (sourceEvent.ctrlKey || sourceEvent.shiftKey))
            window.open(item.href);
        else
            this.service.hooks.onOpen(item.obj);
        e.stopPropagation();
        e.preventDefault();
        sourceEvent.stopPropagation();
        sourceEvent.preventDefault();
    }
    _filter() {
        this._setFilter(this.search);
    }
    _expand(e) {
        const entry = e.model.entry;
        this.set(`groups.${entry.groupIndex}.entries.${entry.entryIndex}.expanded`, !entry.expanded);
        e.stopPropagation();
        e.detail.sourceEvent.stopPropagation();
    }
    _expandIcon(entry, expanded) {
        return expanded ? "CaretDown" : "CaretUp";
    }
    _moreInfo(entry) {
        return entry.obj.attributes.orderBy(attr => attr.offset).filter(attr => {
            return attr.name !== "CreatedOn" &&
                attr.name !== "User" &&
                attr.name !== "OriginalUser" &&
                attr.name !== "IncomingDataLength" &&
                attr.name !== "IncomingDataReference" &&
                attr.name !== "OutgoingDataLength" &&
                attr.name !== "OutgoingDataReference" &&
                !!attr.value;
        });
    }
};
Audit = __decorate([
    WebComponent.register({
        properties: {
            persistentObject: Object,
            query: {
                type: Object,
                computed: "_computeQuery(persistentObject)"
            },
            groups: {
                type: Array,
                readOnly: true
            },
            search: String,
            filter: {
                type: String,
                readOnly: true,
                value: null
            },
            verticalScrollOffset: Number
        },
        forwardObservers: [
            "query.items"
        ],
        observers: [
            "_itemsChanged(query.items, persistentObject, app)",
            "_syncVerticalScrollOffset(verticalScrollOffset, persistentObject, isConnected)",
            "_syncFilter(filter, persistentObject, isConnected)"
        ]
    })
], Audit);

var audit = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get Audit () { return Audit; }
});

let FileDrop = class FileDrop extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  position: relative;
}
:host(:not([drag-over])) #dragOver {
  display: none;
}
:host([drag-over]) ::content > *:first-child {
  z-index: 0;
  pointer-events: none;
}
:host #dragOver {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1;
}
:host #dragOver #overlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: rgba(255, 255, 255, 0.6);
  transform: translate3d(0, 0, 0);
}
:host #dragOver vi-icon {
  --vi-icon-width: calc(var(--theme-h1) * 2);
  --vi-icon-height: calc(var(--theme-h1) * 2);
  z-index: 2;
  fill: var(--color);
  pointer-events: none;
}</style>

<slot id="default"></slot>
<div id="dragOver">
    <div id="overlay"></div>
    <vi-icon source="FileDrop"></vi-icon>
</div>

<!-- Copy Document by Andreas Bjurenborg from the Noun Project -->
<vi-icon name="FileDrop">
    <svg viewBox="0 0 32 32">
        <g>
            <path d="M 12.300781 0 L 2.3925781 9.90625 L 2.3925781 28.445312 L 26.052734 28.445312 L 26.052734 0 L 12.300781 0 z M 13.78125 2.09375 L 23.957031 2.09375 L 23.957031 26.351562 L 4.4882812 26.351562 L 4.4882812 11.388672 L 13.78125 11.388672 L 13.78125 2.09375 z M 11.6875 3.5742188 L 11.6875 9.2929688 L 5.96875 9.2929688 L 11.6875 3.5742188 z M 27.511719 4.0097656 L 27.511719 29.90625 L 6.4023438 29.90625 L 6.4023438 32 L 29.607422 32 L 29.607422 4.0097656 L 27.511719 4.0097656 z " />
        </g>
    </svg>
</vi-icon>

<script src="file-drop.js"></script>`; }
    _dragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        this._setDragOver(true);
    }
    _dragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        this._setDragOver(true);
    }
    _dragLeave(e) {
        const element = e.target;
        if (element?.assignedSlot?.parentElement === this)
            return;
        this._setDragOver(false);
    }
    async _drop(e) {
        e.preventDefault();
        e.stopPropagation();
        this._setDragOver(false);
        if (!e.dataTransfer.files[0])
            return;
        const readers = Array.from(e.dataTransfer.files).map(file => {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = loadEvent => {
                    resolve({
                        name: file.name,
                        contents: loadEvent.target.result.match(/,(.*)$/)[1]
                    });
                };
                reader.readAsDataURL(file);
            });
        });
        this.fire("file-dropped", await Promise.all(readers));
    }
};
FileDrop = __decorate([
    WebComponent.register({
        properties: {
            "dragOver": {
                type: Boolean,
                readOnly: true,
                reflectToAttribute: true,
                value: false
            }
        },
        listeners: {
            "dragenter": "_dragEnter",
            "dragover": "_dragOver",
            "dragleave": "_dragLeave",
            "drop": "_drop"
        }
    })
], FileDrop);

const IronScrollTargetBehavior = {
  properties: {
    scrollTarget: {
      type: HTMLElement,
      value: function() {
        return this._defaultScrollTarget;
      }
    }
  },
  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],
  _shouldHaveListener: true,
  _scrollTargetChanged: function(scrollTarget, isAttached) {
    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    if (scrollTarget === 'document') {
      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {
      var domHost = this.domHost;
      this.scrollTarget = domHost && domHost.$ ?
          domHost.$[scrollTarget] :
          dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {
      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },
  _scrollHandler: function scrollHandler() {},
  get _defaultScrollTarget() {
    return this._doc;
  },
  get _doc() {
    return this.ownerDocument.documentElement;
  },
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset :
                                               this.scrollTarget.scrollTop;
    }
    return 0;
  },
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset :
                                               this.scrollTarget.scrollLeft;
    }
    return 0;
  },
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },
  scroll: function(leftOrOptions, top) {
    var left;
    if (typeof leftOrOptions === 'object') {
      left = leftOrOptions.left;
      top = leftOrOptions.top;
    } else {
      left = leftOrOptions;
    }
    left = left || 0;
    top = top || 0;
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth :
                                               this.scrollTarget.offsetWidth;
    }
    return 0;
  },
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight :
                                               this.scrollTarget.offsetHeight;
    }
    return 0;
  },
  _isValidScrollTarget: function() {
    return this.scrollTarget instanceof HTMLElement;
  },
  _toggleScrollListener: function(yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },
  toggleScrollListener: function(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }
};

var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
var DEFAULT_PHYSICAL_COUNT = 3;
var HIDDEN_Y = '-10000px';
var SECRET_TABINDEX = -100;
Polymer({
  _template: html$3`
    <style>
      :host {
        display: block;
      }

      @media only screen and (-webkit-max-device-pixel-ratio: 1) {
        :host {
          will-change: transform;
        }
      }

      #items {
        @apply --iron-list-items-container;
        position: relative;
      }

      :host(:not([grid])) #items > ::slotted(*) {
        width: 100%;
      }

      #items > ::slotted(*) {
        box-sizing: border-box;
        margin: 0;
        position: absolute;
        top: 0;
        will-change: transform;
      }
    </style>

    <array-selector id="selector" items="{{items}}" selected="{{selectedItems}}" selected-item="{{selectedItem}}"></array-selector>

    <div id="items">
      <slot></slot>
    </div>
`,
  is: 'iron-list',
  properties: {
    items: {type: Array},
    as: {type: String, value: 'item'},
    indexAs: {type: String, value: 'index'},
    selectedAs: {type: String, value: 'selected'},
    grid: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      observer: '_gridChanged'
    },
    selectionEnabled: {type: Boolean, value: false},
    selectedItem: {type: Object, notify: true},
    selectedItems: {type: Object, notify: true},
    multiSelection: {type: Boolean, value: false},
    scrollOffset: {type: Number, value: 0}
  },
  observers: [
    '_itemsChanged(items.*)',
    '_selectionEnabledChanged(selectionEnabled)',
    '_multiSelectionChanged(multiSelection)',
    '_setOverflow(scrollTarget, scrollOffset)'
  ],
  behaviors: [
    Templatizer,
    IronResizableBehavior,
    IronScrollTargetBehavior,
    OptionalMutableDataBehavior
  ],
  _ratio: 0.5,
  _scrollerPaddingTop: 0,
  _scrollPosition: 0,
  _physicalSize: 0,
  _physicalAverage: 0,
  _physicalAverageCount: 0,
  _physicalTop: 0,
  _virtualCount: 0,
  _estScrollHeight: 0,
  _scrollHeight: 0,
  _viewportHeight: 0,
  _viewportWidth: 0,
  _physicalItems: null,
  _physicalSizes: null,
  _firstVisibleIndexVal: null,
  _lastVisibleIndexVal: null,
  _maxPages: 2,
  _focusedItem: null,
  _focusedVirtualIndex: -1,
  _focusedPhysicalIndex: -1,
  _offscreenFocusedItem: null,
  _focusBackfillItem: null,
  _itemsPerRow: 1,
  _itemWidth: 0,
  _rowHeight: 0,
  _templateCost: 0,
  _parentModel: true,
  get _physicalBottom() {
    return this._physicalTop + this._physicalSize;
  },
  get _scrollBottom() {
    return this._scrollPosition + this._viewportHeight;
  },
  get _virtualEnd() {
    return this._virtualStart + this._physicalCount - 1;
  },
  get _hiddenContentSize() {
    var size =
        this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;
    return size - this._viewportHeight;
  },
  get _itemsParent() {
    return dom(dom(this._userTemplate).parentNode);
  },
  get _maxScrollTop() {
    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
  },
  get _maxVirtualStart() {
    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);
    return Math.max(0, virtualCount - this._physicalCount);
  },
  set _virtualStart(val) {
    val = this._clamp(val, 0, this._maxVirtualStart);
    if (this.grid) {
      val = val - (val % this._itemsPerRow);
    }
    this._virtualStartVal = val;
  },
  get _virtualStart() {
    return this._virtualStartVal || 0;
  },
  set _physicalStart(val) {
    val = val % this._physicalCount;
    if (val < 0) {
      val = this._physicalCount + val;
    }
    if (this.grid) {
      val = val - (val % this._itemsPerRow);
    }
    this._physicalStartVal = val;
  },
  get _physicalStart() {
    return this._physicalStartVal || 0;
  },
  get _physicalEnd() {
    return (this._physicalStart + this._physicalCount - 1) %
        this._physicalCount;
  },
  set _physicalCount(val) {
    this._physicalCountVal = val;
  },
  get _physicalCount() {
    return this._physicalCountVal || 0;
  },
  get _optPhysicalSize() {
    return this._viewportHeight === 0 ? Infinity :
                                        this._viewportHeight * this._maxPages;
  },
  get _isVisible() {
    return Boolean(this.offsetWidth || this.offsetHeight);
  },
  get firstVisibleIndex() {
    var idx = this._firstVisibleIndexVal;
    if (idx == null) {
      var physicalOffset = this._physicalTop + this._scrollOffset;
      idx = this._iterateItems(function(pidx, vidx) {
        physicalOffset += this._getPhysicalSizeIncrement(pidx);
        if (physicalOffset > this._scrollPosition) {
          return this.grid ? vidx - (vidx % this._itemsPerRow) : vidx;
        }
        if (this.grid && this._virtualCount - 1 === vidx) {
          return vidx - (vidx % this._itemsPerRow);
        }
      }) ||
          0;
      this._firstVisibleIndexVal = idx;
    }
    return idx;
  },
  get lastVisibleIndex() {
    var idx = this._lastVisibleIndexVal;
    if (idx == null) {
      if (this.grid) {
        idx = Math.min(
            this._virtualCount,
            this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow -
                1);
      } else {
        var physicalOffset = this._physicalTop + this._scrollOffset;
        this._iterateItems(function(pidx, vidx) {
          if (physicalOffset < this._scrollBottom) {
            idx = vidx;
          }
          physicalOffset += this._getPhysicalSizeIncrement(pidx);
        });
      }
      this._lastVisibleIndexVal = idx;
    }
    return idx;
  },
  get _defaultScrollTarget() {
    return this;
  },
  get _virtualRowCount() {
    return Math.ceil(this._virtualCount / this._itemsPerRow);
  },
  get _estRowsInView() {
    return Math.ceil(this._viewportHeight / this._rowHeight);
  },
  get _physicalRows() {
    return Math.ceil(this._physicalCount / this._itemsPerRow);
  },
  get _scrollOffset() {
    return this._scrollerPaddingTop + this.scrollOffset;
  },
  ready: function() {
    this.addEventListener('focus', this._didFocus.bind(this), true);
  },
  attached: function() {
    this._debounce('_render', this._render, animationFrame);
    this.listen(this, 'iron-resize', '_resizeHandler');
    this.listen(this, 'keydown', '_keydownHandler');
  },
  detached: function() {
    this.unlisten(this, 'iron-resize', '_resizeHandler');
    this.unlisten(this, 'keydown', '_keydownHandler');
  },
  _setOverflow: function(scrollTarget) {
    this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';
    this.style.overflowY = scrollTarget === this ? 'auto' : '';
    this._lastVisibleIndexVal = null;
    this._firstVisibleIndexVal = null;
    this._debounce('_render', this._render, animationFrame);
  },
  updateViewportBoundaries: function() {
    var styles = window.getComputedStyle(this);
    this._scrollerPaddingTop =
        this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);
    this._isRTL = Boolean(styles.direction === 'rtl');
    this._viewportWidth = this.$.items.offsetWidth;
    this._viewportHeight = this._scrollTargetHeight;
    this.grid && this._updateGridMetrics();
  },
  _scrollHandler: function() {
    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    var delta = scrollTop - this._scrollPosition;
    var isScrollingDown = delta >= 0;
    this._scrollPosition = scrollTop;
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;
    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {
      delta = delta - this._scrollOffset;
      var idxAdjustment =
          Math.round(delta / this._physicalAverage) * this._itemsPerRow;
      this._virtualStart = this._virtualStart + idxAdjustment;
      this._physicalStart = this._physicalStart + idxAdjustment;
      this._physicalTop = Math.min(
          Math.floor(this._virtualStart / this._itemsPerRow) *
              this._physicalAverage,
          this._scrollPosition);
      this._update();
    } else if (this._physicalCount > 0) {
      var reusables = this._getReusables(isScrollingDown);
      if (isScrollingDown) {
        this._physicalTop = reusables.physicalTop;
        this._virtualStart = this._virtualStart + reusables.indexes.length;
        this._physicalStart = this._physicalStart + reusables.indexes.length;
      } else {
        this._virtualStart = this._virtualStart - reusables.indexes.length;
        this._physicalStart = this._physicalStart - reusables.indexes.length;
      }
      this._update(
          reusables.indexes, isScrollingDown ? null : reusables.indexes);
      this._debounce(
          '_increasePoolIfNeeded',
          this._increasePoolIfNeeded.bind(this, 0),
          microTask);
    }
  },
  _getReusables: function(fromTop) {
    var ith, offsetContent, physicalItemHeight;
    var idxs = [];
    var protectedOffsetContent = this._hiddenContentSize * this._ratio;
    var virtualStart = this._virtualStart;
    var virtualEnd = this._virtualEnd;
    var physicalCount = this._physicalCount;
    var top = this._physicalTop + this._scrollOffset;
    var bottom = this._physicalBottom + this._scrollOffset;
    var scrollTop = this._scrollPosition;
    var scrollBottom = this._scrollBottom;
    if (fromTop) {
      ith = this._physicalStart;
      this._physicalEnd;
      offsetContent = scrollTop - top;
    } else {
      ith = this._physicalEnd;
      this._physicalStart;
      offsetContent = bottom - scrollBottom;
    }
    while (true) {
      physicalItemHeight = this._getPhysicalSizeIncrement(ith);
      offsetContent = offsetContent - physicalItemHeight;
      if (idxs.length >= physicalCount ||
          offsetContent <= protectedOffsetContent) {
        break;
      }
      if (fromTop) {
        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {
          break;
        }
        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {
          break;
        }
        idxs.push(ith);
        top = top + physicalItemHeight;
        ith = (ith + 1) % physicalCount;
      } else {
        if (virtualStart - idxs.length <= 0) {
          break;
        }
        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {
          break;
        }
        idxs.push(ith);
        top = top - physicalItemHeight;
        ith = (ith === 0) ? physicalCount - 1 : ith - 1;
      }
    }
    return {indexes: idxs, physicalTop: top - this._scrollOffset};
  },
  _update: function(itemSet, movingUp) {
    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {
      return;
    }
    this._manageFocus();
    this._assignModels(itemSet);
    this._updateMetrics(itemSet);
    if (movingUp) {
      while (movingUp.length) {
        var idx = movingUp.pop();
        this._physicalTop -= this._getPhysicalSizeIncrement(idx);
      }
    }
    this._positionItems();
    this._updateScrollerSize();
  },
  _createPool: function(size) {
    this._ensureTemplatized();
    var i, inst;
    var physicalItems = new Array(size);
    for (i = 0; i < size; i++) {
      inst = this.stamp(null);
      physicalItems[i] = inst.root.querySelector('*');
      this._itemsParent.appendChild(inst.root);
    }
    return physicalItems;
  },
  _isClientFull: function() {
    return this._scrollBottom != 0 &&
        this._physicalBottom - 1 >= this._scrollBottom &&
        this._physicalTop <= this._scrollPosition;
  },
  _increasePoolIfNeeded: function(count) {
    var nextPhysicalCount = this._clamp(
        this._physicalCount + count,
        DEFAULT_PHYSICAL_COUNT,
        this._virtualCount - this._virtualStart);
    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);
    if (this.grid) {
      var correction = nextPhysicalCount % this._itemsPerRow;
      if (correction && nextPhysicalCount - correction <= this._physicalCount) {
        nextPhysicalCount += this._itemsPerRow;
      }
      nextPhysicalCount -= correction;
    }
    var delta = nextPhysicalCount - this._physicalCount;
    var nextIncrease = Math.round(this._physicalCount * 0.5);
    if (delta < 0) {
      return;
    }
    if (delta > 0) {
      var ts = window.performance.now();
      [].push.apply(this._physicalItems, this._createPool(delta));
      for (var i = 0; i < delta; i++) {
        this._physicalSizes.push(0);
      }
      this._physicalCount = this._physicalCount + delta;
      if (this._physicalStart > this._physicalEnd &&
          this._isIndexRendered(this._focusedVirtualIndex) &&
          this._getPhysicalIndex(this._focusedVirtualIndex) <
              this._physicalEnd) {
        this._physicalStart = this._physicalStart + delta;
      }
      this._update();
      this._templateCost = (window.performance.now() - ts) / delta;
      nextIncrease = Math.round(this._physicalCount * 0.5);
    }
    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) ; else if (!this._isClientFull()) {
      this._debounce(
          '_increasePoolIfNeeded',
          this._increasePoolIfNeeded.bind(this, nextIncrease),
          microTask);
    } else if (this._physicalSize < this._optPhysicalSize) {
      this._debounce(
          '_increasePoolIfNeeded',
          this._increasePoolIfNeeded.bind(
              this,
              this._clamp(
                  Math.round(50 / this._templateCost), 1, nextIncrease)),
          idlePeriod);
    }
  },
  _render: function() {
    if (!this.isAttached || !this._isVisible) {
      return;
    }
    if (this._physicalCount !== 0) {
      var reusables = this._getReusables(true);
      this._physicalTop = reusables.physicalTop;
      this._virtualStart = this._virtualStart + reusables.indexes.length;
      this._physicalStart = this._physicalStart + reusables.indexes.length;
      this._update(reusables.indexes);
      this._update();
      this._increasePoolIfNeeded(0);
    } else if (this._virtualCount > 0) {
      this.updateViewportBoundaries();
      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);
    }
  },
  _ensureTemplatized: function() {
    if (this.ctor) {
      return;
    }
    this._userTemplate =  (
        this.queryEffectiveChildren('template'));
    if (!this._userTemplate) {
      console.warn('iron-list requires a template to be provided in light-dom');
    }
    var instanceProps = {};
    instanceProps.__key__ = true;
    instanceProps[this.as] = true;
    instanceProps[this.indexAs] = true;
    instanceProps[this.selectedAs] = true;
    instanceProps.tabIndex = true;
    this._instanceProps = instanceProps;
    this.templatize(this._userTemplate, this.mutableData);
  },
  _gridChanged: function(newGrid, oldGrid) {
    if (typeof oldGrid === 'undefined')
      return;
    this.notifyResize();
    flush$1();
    newGrid && this._updateGridMetrics();
  },
  _itemsChanged: function(change) {
    if (change.path === 'items') {
      this._virtualStart = 0;
      this._physicalTop = 0;
      this._virtualCount = this.items ? this.items.length : 0;
      this._physicalIndexForKey = {};
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
      this._physicalCount = this._physicalCount || 0;
      this._physicalItems = this._physicalItems || [];
      this._physicalSizes = this._physicalSizes || [];
      this._physicalStart = 0;
      if (this._scrollTop > this._scrollOffset) {
        this._resetScrollPosition(0);
      }
      this._removeFocusedItem();
      this._debounce('_render', this._render, animationFrame);
    } else if (change.path === 'items.splices') {
      this._adjustVirtualIndex(change.value.indexSplices);
      this._virtualCount = this.items ? this.items.length : 0;
      var itemAddedOrRemoved = change.value.indexSplices.some(function(splice) {
        return splice.addedCount > 0 || splice.removed.length > 0;
      });
      if (itemAddedOrRemoved) {
        var activeElement = this._getActiveElement();
        if (this.contains(activeElement)) {
          activeElement.blur();
        }
      }
      var affectedIndexRendered =
          change.value.indexSplices.some(function(splice) {
            return splice.index + splice.addedCount >= this._virtualStart &&
                splice.index <= this._virtualEnd;
          }, this);
      if (!this._isClientFull() || affectedIndexRendered) {
        this._debounce('_render', this._render, animationFrame);
      }
    } else if (change.path !== 'items.length') {
      this._forwardItemPath(change.path, change.value);
    }
  },
  _forwardItemPath: function(path, value) {
    path = path.slice(6);
    var dot = path.indexOf('.');
    if (dot === -1) {
      dot = path.length;
    }
    var isIndexRendered;
    var pidx;
    var inst;
    var offscreenInstance = this.modelForElement(this._offscreenFocusedItem);
    var vidx = parseInt(path.substring(0, dot), 10);
    isIndexRendered = this._isIndexRendered(vidx);
    if (isIndexRendered) {
      pidx = this._getPhysicalIndex(vidx);
      inst = this.modelForElement(this._physicalItems[pidx]);
    } else if (offscreenInstance) {
      inst = offscreenInstance;
    }
    if (!inst || inst[this.indexAs] !== vidx) {
      return;
    }
    path = path.substring(dot + 1);
    path = this.as + (path ? '.' + path : '');
    inst._setPendingPropertyOrPath(path, value, false, true);
    inst._flushProperties && inst._flushProperties();
    if (isIndexRendered) {
      this._updateMetrics([pidx]);
      this._positionItems();
      this._updateScrollerSize();
    }
  },
  _adjustVirtualIndex: function(splices) {
    splices.forEach(function(splice) {
      splice.removed.forEach(this._removeItem, this);
      if (splice.index < this._virtualStart) {
        var delta = Math.max(
            splice.addedCount - splice.removed.length,
            splice.index - this._virtualStart);
        this._virtualStart = this._virtualStart + delta;
        if (this._focusedVirtualIndex >= 0) {
          this._focusedVirtualIndex = this._focusedVirtualIndex + delta;
        }
      }
    }, this);
  },
  _removeItem: function(item) {
    this.$.selector.deselect(item);
    if (this._focusedItem &&
        this.modelForElement(this._focusedItem)[this.as] === item) {
      this._removeFocusedItem();
    }
  },
  _iterateItems: function(fn, itemSet) {
    var pidx, vidx, rtn, i;
    if (arguments.length === 2 && itemSet) {
      for (i = 0; i < itemSet.length; i++) {
        pidx = itemSet[i];
        vidx = this._computeVidx(pidx);
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    } else {
      pidx = this._physicalStart;
      vidx = this._virtualStart;
      for (; pidx < this._physicalCount; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    }
  },
  _computeVidx: function(pidx) {
    if (pidx >= this._physicalStart) {
      return this._virtualStart + (pidx - this._physicalStart);
    }
    return this._virtualStart + (this._physicalCount - this._physicalStart) +
        pidx;
  },
  _assignModels: function(itemSet) {
    this._iterateItems(function(pidx, vidx) {
      var el = this._physicalItems[pidx];
      var item = this.items && this.items[vidx];
      if (item != null) {
        var inst = this.modelForElement(el);
        inst.__key__ = null;
        this._forwardProperty(inst, this.as, item);
        this._forwardProperty(
            inst, this.selectedAs, this.$.selector.isSelected(item));
        this._forwardProperty(inst, this.indexAs, vidx);
        this._forwardProperty(
            inst, 'tabIndex', this._focusedVirtualIndex === vidx ? 0 : -1);
        this._physicalIndexForKey[inst.__key__] = pidx;
        inst._flushProperties && inst._flushProperties(true);
        el.removeAttribute('hidden');
      } else {
        el.setAttribute('hidden', '');
      }
    }, itemSet);
  },
  _updateMetrics: function(itemSet) {
    flush$1();
    var newPhysicalSize = 0;
    var oldPhysicalSize = 0;
    var prevAvgCount = this._physicalAverageCount;
    var prevPhysicalAvg = this._physicalAverage;
    this._iterateItems(function(pidx, vidx) {
      oldPhysicalSize += this._physicalSizes[pidx];
      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
      newPhysicalSize += this._physicalSizes[pidx];
      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
    }, itemSet);
    if (this.grid) {
      this._updateGridMetrics();
      this._physicalSize =
          Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;
    } else {
      oldPhysicalSize = (this._itemsPerRow === 1) ?
          oldPhysicalSize :
          Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;
      this._physicalSize =
          this._physicalSize + newPhysicalSize - oldPhysicalSize;
      this._itemsPerRow = 1;
    }
    if (this._physicalAverageCount !== prevAvgCount) {
      this._physicalAverage = Math.round(
          ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /
          this._physicalAverageCount);
    }
  },
  _updateGridMetrics: function() {
    this._itemWidth = this._physicalCount > 0 ?
        this._physicalItems[0].getBoundingClientRect().width :
        200;
    this._rowHeight =
        this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;
    this._itemsPerRow = this._itemWidth ?
        Math.floor(this._viewportWidth / this._itemWidth) :
        this._itemsPerRow;
  },
  _positionItems: function() {
    this._adjustScrollPosition();
    var y = this._physicalTop;
    if (this.grid) {
      var totalItemWidth = this._itemsPerRow * this._itemWidth;
      var rowOffset = (this._viewportWidth - totalItemWidth) / 2;
      this._iterateItems(function(pidx, vidx) {
        var modulus = vidx % this._itemsPerRow;
        var x = Math.floor((modulus * this._itemWidth) + rowOffset);
        if (this._isRTL) {
          x = x * -1;
        }
        this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);
        if (this._shouldRenderNextRow(vidx)) {
          y += this._rowHeight;
        }
      });
    } else {
      const order = [];
      this._iterateItems(function(pidx, vidx) {
        const item = this._physicalItems[pidx];
        this.translate3d(0, y + 'px', 0, item);
        y += this._physicalSizes[pidx];
        const itemId = item.id;
        if (itemId) {
          order.push(itemId);
        }
      });
      if (order.length) {
        this.setAttribute('aria-owns', order.join(' '));
      }
    }
  },
  _getPhysicalSizeIncrement: function(pidx) {
    if (!this.grid) {
      return this._physicalSizes[pidx];
    }
    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {
      return 0;
    }
    return this._rowHeight;
  },
  _shouldRenderNextRow: function(vidx) {
    return vidx % this._itemsPerRow === this._itemsPerRow - 1;
  },
  _adjustScrollPosition: function() {
    var deltaHeight = this._virtualStart === 0 ?
        this._physicalTop :
        Math.min(this._scrollPosition + this._physicalTop, 0);
    if (deltaHeight !== 0) {
      this._physicalTop = this._physicalTop - deltaHeight;
      var scrollTop = this._scrollPosition;
      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {
        this._resetScrollPosition(scrollTop - deltaHeight);
      }
    }
  },
  _resetScrollPosition: function(pos) {
    if (this.scrollTarget && pos >= 0) {
      this._scrollTop = pos;
      this._scrollPosition = this._scrollTop;
    }
  },
  _updateScrollerSize: function(forceUpdate) {
    if (this.grid) {
      this._estScrollHeight = this._virtualRowCount * this._rowHeight;
    } else {
      this._estScrollHeight =
          (this._physicalBottom +
           Math.max(
               this._virtualCount - this._physicalCount - this._virtualStart,
               0) *
               this._physicalAverage);
    }
    forceUpdate = forceUpdate || this._scrollHeight === 0;
    forceUpdate = forceUpdate ||
        this._scrollPosition >= this._estScrollHeight - this._physicalSize;
    forceUpdate = forceUpdate ||
        this.grid && this.$.items.style.height < this._estScrollHeight;
    if (forceUpdate ||
        Math.abs(this._estScrollHeight - this._scrollHeight) >=
            this._viewportHeight) {
      this.$.items.style.height = this._estScrollHeight + 'px';
      this._scrollHeight = this._estScrollHeight;
    }
  },
  scrollToItem: function(item) {
    return this.scrollToIndex(this.items.indexOf(item));
  },
  scrollToIndex: function(idx) {
    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {
      return;
    }
    flush$1();
    if (this._physicalCount === 0) {
      return;
    }
    idx = this._clamp(idx, 0, this._virtualCount - 1);
    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
      this._virtualStart =
          this.grid ? (idx - this._itemsPerRow * 2) : (idx - 1);
    }
    this._manageFocus();
    this._assignModels();
    this._updateMetrics();
    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) *
        this._physicalAverage;
    var currentTopItem = this._physicalStart;
    var currentVirtualItem = this._virtualStart;
    var targetOffsetTop = 0;
    var hiddenContentSize = this._hiddenContentSize;
    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
      targetOffsetTop =
          targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);
      currentTopItem = (currentTopItem + 1) % this._physicalCount;
      currentVirtualItem++;
    }
    this._updateScrollerSize(true);
    this._positionItems();
    this._resetScrollPosition(
        this._physicalTop + this._scrollOffset + targetOffsetTop);
    this._increasePoolIfNeeded(0);
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;
  },
  _resetAverage: function() {
    this._physicalAverage = 0;
    this._physicalAverageCount = 0;
  },
  _resizeHandler: function() {
    this._debounce('_render', function() {
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
      if (this._isVisible) {
        this.updateViewportBoundaries();
        this.toggleScrollListener(true);
        this._resetAverage();
        this._render();
      } else {
        this.toggleScrollListener(false);
      }
    }, animationFrame);
  },
  selectItem: function(item) {
    return this.selectIndex(this.items.indexOf(item));
  },
  selectIndex: function(index) {
    if (index < 0 || index >= this._virtualCount) {
      return;
    }
    if (!this.multiSelection && this.selectedItem) {
      this.clearSelection();
    }
    if (this._isIndexRendered(index)) {
      var model = this.modelForElement(
          this._physicalItems[this._getPhysicalIndex(index)]);
      if (model) {
        model[this.selectedAs] = true;
      }
      this.updateSizeForIndex(index);
    }
    this.$.selector.selectIndex(index);
  },
  deselectItem: function(item) {
    return this.deselectIndex(this.items.indexOf(item));
  },
  deselectIndex: function(index) {
    if (index < 0 || index >= this._virtualCount) {
      return;
    }
    if (this._isIndexRendered(index)) {
      var model = this.modelForElement(
          this._physicalItems[this._getPhysicalIndex(index)]);
      model[this.selectedAs] = false;
      this.updateSizeForIndex(index);
    }
    this.$.selector.deselectIndex(index);
  },
  toggleSelectionForItem: function(item) {
    return this.toggleSelectionForIndex(this.items.indexOf(item));
  },
  toggleSelectionForIndex: function(index) {
    var isSelected = this.$.selector.isIndexSelected ?
        this.$.selector.isIndexSelected(index) :
        this.$.selector.isSelected(this.items[index]);
    isSelected ? this.deselectIndex(index) : this.selectIndex(index);
  },
  clearSelection: function() {
    this._iterateItems(function(pidx, vidx) {
      this.modelForElement(this._physicalItems[pidx])[this.selectedAs] = false;
    });
    this.$.selector.clearSelection();
  },
  _selectionEnabledChanged: function(selectionEnabled) {
    var handler = selectionEnabled ? this.listen : this.unlisten;
    handler.call(this, this, 'tap', '_selectionHandler');
  },
  _selectionHandler: function(e) {
    var model = this.modelForElement(e.target);
    if (!model) {
      return;
    }
    var modelTabIndex, activeElTabIndex;
    var target = dom(e).path[0];
    var activeEl = this._getActiveElement();
    var physicalItem =
        this._physicalItems[this._getPhysicalIndex(model[this.indexAs])];
    if (target.localName === 'input' || target.localName === 'button' ||
        target.localName === 'select') {
      return;
    }
    modelTabIndex = model.tabIndex;
    model.tabIndex = SECRET_TABINDEX;
    activeElTabIndex = activeEl ? activeEl.tabIndex : -1;
    model.tabIndex = modelTabIndex;
    if (activeEl && physicalItem !== activeEl &&
        physicalItem.contains(activeEl) &&
        activeElTabIndex !== SECRET_TABINDEX) {
      return;
    }
    this.toggleSelectionForItem(model[this.as]);
  },
  _multiSelectionChanged: function(multiSelection) {
    this.clearSelection();
    this.$.selector.multi = multiSelection;
  },
  updateSizeForItem: function(item) {
    return this.updateSizeForIndex(this.items.indexOf(item));
  },
  updateSizeForIndex: function(index) {
    if (!this._isIndexRendered(index)) {
      return null;
    }
    this._updateMetrics([this._getPhysicalIndex(index)]);
    this._positionItems();
    return null;
  },
  _manageFocus: function() {
    var fidx = this._focusedVirtualIndex;
    if (fidx >= 0 && fidx < this._virtualCount) {
      if (this._isIndexRendered(fidx)) {
        this._restoreFocusedItem();
      } else {
        this._createFocusBackfillItem();
      }
    } else if (this._virtualCount > 0 && this._physicalCount > 0) {
      this._focusedPhysicalIndex = this._physicalStart;
      this._focusedVirtualIndex = this._virtualStart;
      this._focusedItem = this._physicalItems[this._physicalStart];
    }
  },
  _convertIndexToCompleteRow: function(idx) {
    this._itemsPerRow = this._itemsPerRow || 1;
    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow :
                       idx;
  },
  _isIndexRendered: function(idx) {
    return idx >= this._virtualStart && idx <= this._virtualEnd;
  },
  _isIndexVisible: function(idx) {
    return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
  },
  _getPhysicalIndex: function(vidx) {
    return (this._physicalStart + (vidx - this._virtualStart)) %
        this._physicalCount;
  },
  focusItem: function(idx) {
    this._focusPhysicalItem(idx);
  },
  _focusPhysicalItem: function(idx) {
    if (idx < 0 || idx >= this._virtualCount) {
      return;
    }
    this._restoreFocusedItem();
    if (!this._isIndexRendered(idx)) {
      this.scrollToIndex(idx);
    }
    var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];
    var model = this.modelForElement(physicalItem);
    var focusable;
    model.tabIndex = SECRET_TABINDEX;
    if (physicalItem.tabIndex === SECRET_TABINDEX) {
      focusable = physicalItem;
    }
    if (!focusable) {
      focusable = dom(physicalItem)
                      .querySelector('[tabindex="' + SECRET_TABINDEX + '"]');
    }
    model.tabIndex = 0;
    this._focusedVirtualIndex = idx;
    focusable && focusable.focus();
  },
  _removeFocusedItem: function() {
    if (this._offscreenFocusedItem) {
      this._itemsParent.removeChild(this._offscreenFocusedItem);
    }
    this._offscreenFocusedItem = null;
    this._focusBackfillItem = null;
    this._focusedItem = null;
    this._focusedVirtualIndex = -1;
    this._focusedPhysicalIndex = -1;
  },
  _createFocusBackfillItem: function() {
    var fpidx = this._focusedPhysicalIndex;
    if (this._offscreenFocusedItem || this._focusedVirtualIndex < 0) {
      return;
    }
    if (!this._focusBackfillItem) {
      var inst = this.stamp(null);
      this._focusBackfillItem =
           (inst.root.querySelector('*'));
      this._itemsParent.appendChild(inst.root);
    }
    this._offscreenFocusedItem = this._physicalItems[fpidx];
    this.modelForElement(this._offscreenFocusedItem).tabIndex = 0;
    this._physicalItems[fpidx] = this._focusBackfillItem;
    this._focusedPhysicalIndex = fpidx;
    this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);
  },
  _restoreFocusedItem: function() {
    if (!this._offscreenFocusedItem || this._focusedVirtualIndex < 0) {
      return;
    }
    this._assignModels();
    var fpidx = this._focusedPhysicalIndex =
        this._getPhysicalIndex(this._focusedVirtualIndex);
    var onScreenItem = this._physicalItems[fpidx];
    if (!onScreenItem) {
      return;
    }
    var onScreenInstance = this.modelForElement(onScreenItem);
    var offScreenInstance = this.modelForElement(this._offscreenFocusedItem);
    if (onScreenInstance[this.as] === offScreenInstance[this.as]) {
      this._focusBackfillItem = onScreenItem;
      onScreenInstance.tabIndex = -1;
      this._physicalItems[fpidx] = this._offscreenFocusedItem;
      this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);
    } else {
      this._removeFocusedItem();
      this._focusBackfillItem = null;
    }
    this._offscreenFocusedItem = null;
  },
  _didFocus: function(e) {
    var targetModel = this.modelForElement(e.target);
    var focusedModel = this.modelForElement(this._focusedItem);
    var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;
    var fidx = this._focusedVirtualIndex;
    if (!targetModel) {
      return;
    }
    if (focusedModel === targetModel) {
      if (!this._isIndexVisible(fidx)) {
        this.scrollToIndex(fidx);
      }
    } else {
      this._restoreFocusedItem();
      if (focusedModel) {
        focusedModel.tabIndex = -1;
      }
      targetModel.tabIndex = 0;
      fidx = targetModel[this.indexAs];
      this._focusedVirtualIndex = fidx;
      this._focusedPhysicalIndex = this._getPhysicalIndex(fidx);
      this._focusedItem = this._physicalItems[this._focusedPhysicalIndex];
      if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {
        this._update();
      }
    }
  },
  _keydownHandler: function(e) {
    switch (e.keyCode) {
      case  40:
        if (this._focusedVirtualIndex < this._virtualCount - 1)
          e.preventDefault();
        this._focusPhysicalItem(
            this._focusedVirtualIndex + (this.grid ? this._itemsPerRow : 1));
        break;
      case  39:
        if (this.grid)
          this._focusPhysicalItem(
              this._focusedVirtualIndex + (this._isRTL ? -1 : 1));
        break;
      case  38:
        if (this._focusedVirtualIndex > 0)
          e.preventDefault();
        this._focusPhysicalItem(
            this._focusedVirtualIndex - (this.grid ? this._itemsPerRow : 1));
        break;
      case  37:
        if (this.grid)
          this._focusPhysicalItem(
              this._focusedVirtualIndex + (this._isRTL ? 1 : -1));
        break;
      case  13:
        this._focusPhysicalItem(this._focusedVirtualIndex);
        if (this.selectionEnabled)
          this._selectionHandler(e);
        break;
    }
  },
  _clamp: function(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },
  _debounce: function(name, cb, asyncModule) {
    this._debouncers = this._debouncers || {};
    this._debouncers[name] =
        Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));
    enqueueDebouncer(this._debouncers[name]);
  },
  _forwardProperty: function(inst, name, value) {
    inst._setPendingProperty(name, value);
  },
  _forwardHostPropV2: function(prop, value) {
    (this._physicalItems || [])
        .concat([this._offscreenFocusedItem, this._focusBackfillItem])
        .forEach(function(item) {
          if (item) {
            this.modelForElement(item).forwardHostProp(prop, value);
          }
        }, this);
  },
  _notifyInstancePropV2: function(inst, prop, value) {
    if (matches$2(this.as, prop)) {
      var idx = inst[this.indexAs];
      if (prop == this.as) {
        this.items[idx] = value;
      }
      this.notifyPath(translate(this.as, 'items.' + idx, prop), value);
    }
  },
  _getStampedChildren: function() {
    return this._physicalItems;
  },
  _forwardInstancePath: function(inst, path, value) {
    if (path.indexOf(this.as + '.') === 0) {
      this.notifyPath(
          'items.' + inst.__key__ + '.' + path.slice(this.as.length + 1),
          value);
    }
  },
  _forwardParentPath: function(path, value) {
    (this._physicalItems || [])
        .concat([this._offscreenFocusedItem, this._focusBackfillItem])
        .forEach(function(item) {
          if (item) {
            this.modelForElement(item).notifyPath(path, value);
          }
        }, this);
  },
  _forwardParentProp: function(prop, value) {
    (this._physicalItems || [])
        .concat([this._offscreenFocusedItem, this._focusBackfillItem])
        .forEach(function(item) {
          if (item) {
            this.modelForElement(item)[prop] = value;
          }
        }, this);
  },
  _getActiveElement: function() {
    var itemsHost = this._itemsParent.node.domHost;
    return dom(itemsHost ? itemsHost.root : document).activeElement;
  }
});

let List = class List extends WebComponent {
    static get template() { return html$3 `<style>:host {
  position: relative;
  display: flex;
  flex-direction: row;
}</style>

<vi-size-tracker on-sizechanged="_sizeChanged"></vi-size-tracker>
<dom-if if="[[!parentScroller]]" restamp>
    <template>
        <vi-scroller class="flex" no-horizontal>
            <iron-list id="list" items="[[items]]" as="[[as]]"><slot></slot></iron-list>
            <vi-connected-notifier on-connected="_bindIronListDataHost"></vi-connected-notifier>
        </vi-scroller>
    </template>
</dom-if>
<dom-if if="[[parentScroller]]" restamp id="parentScrollerTemplate">
    <template>
        <iron-list id="list" items="[[items]]" as="[[as]]" class="flex"><slot></slot></iron-list>
        <vi-connected-notifier on-connected="_bindIronListDataHost"></vi-connected-notifier>
    </template>
</dom-if>`; }
    _hookIronListToScroller(parentScroller, isConnected) {
        if (!isConnected)
            return;
        flush$1();
        microTask.run(() => {
            if (parentScroller !== this.parentScroller || !this.isConnected)
                return;
            const list = this.shadowRoot.querySelector("#list");
            const scroller = this.findParent(e => e instanceof Scroller, list);
            list.scrollTarget = scroller.scroller;
            this._sizeChanged();
        });
    }
    _bindIronListDataHost() {
        const list = this.shadowRoot.querySelector("#list");
        if (list["dataHost"] && list["dataHost"]["_rootDataHost"] === this) {
            const dataHostParent = this.findParent(e => e["dataHost"]);
            if (dataHostParent)
                list["dataHost"] = dataHostParent["dataHost"];
        }
    }
    _sizeChanged() {
        this.shadowRoot.querySelector("#list").dispatchEvent(new CustomEvent("iron-resize"));
    }
};
List = __decorate([
    WebComponent.register({
        properties: {
            items: Array,
            as: String,
            parentScroller: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            }
        },
        observers: [
            "_hookIronListToScroller(parentScroller, isConnected)"
        ]
    })
], List);

let PersistentObjectTabBarItem = class PersistentObjectTabBarItem extends WebComponent {
    static get template() { return html$3 `<style>:host {
  line-height: var(--theme-h1);
  height: var(--theme-h1);
  align-items: flex-end;
  cursor: pointer !important;
  padding: 0 var(--theme-h4);
  border-bottom: 3px solid transparent;
  box-sizing: border-box;
  white-space: nowrap;
  overflow: hidden;
  color: var(--color);
  fill: var(--color);
}
:host(:hover) {
  background-color: var(--color-faint);
}
:host span {
  line-height: calc(var(--theme-h1) - 3px);
}
:host span.badge {
  background-color: var(--color-lighter);
  color: white;
  padding: calc(var(--theme-h5) / 2) calc(var(--theme-h5) + 1px) calc(var(--theme-h5) / 2) var(--theme-h5);
  margin-left: 2px;
  border-radius: 50%;
  font-size: 10px;
}
:host([is-selected]) {
  border-bottom-color: var(--color);
}
:host([is-selected]) span.badge {
  background-color: var(--color);
}
:host([is-selected]) span:not(.badge) {
  font-weight: 600;
}</style>

<span>[[label]]</span>
<dom-if if="[[hasBadge]]">
    <template>
        <span class="badge">[[badge]]</span>
    </template>
</dom-if>`; }
    _select() {
        this.fire("tab-selected", { tab: this.tab }, { bubbles: false });
    }
    _computeIsSelected(tab, selectedTab) {
        return tab === selectedTab;
    }
    _computeBadge(totalItems, hasMore) {
        if (totalItems != null && totalItems >= 0)
            return totalItems + (hasMore ? "+" : "");
        return "";
    }
    _computeHasBadge(badge) {
        return !!badge;
    }
    _computeLabel(tabLabel, query, queryLabel) {
        return query && queryLabel || tabLabel;
    }
    _computeQuery(tab) {
        return tab.query || null;
    }
    _computeQueryLabel(label, currentFilter) {
        return label + (currentFilter && currentFilter.name ? " — " + currentFilter.name : "");
    }
};
PersistentObjectTabBarItem = __decorate([
    WebComponent.register({
        properties: {
            tab: Object,
            selectedTab: Object,
            isSelected: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeIsSelected(tab, selectedTab)"
            },
            label: {
                type: String,
                computed: "_computeLabel(tab.label, query, queryLabel)"
            },
            query: {
                type: Object,
                computed: "_computeQuery(tab)"
            },
            queryLabel: {
                type: String,
                value: null,
                computed: "_computeQueryLabel(query.label, query.filters.currentFilter)"
            },
            badge: {
                type: String,
                computed: "_computeBadge(query.totalItems, query.hasMore)"
            },
            hasBadge: {
                type: Boolean,
                computed: "_computeHasBadge(badge)"
            }
        },
        listeners: {
            "tap": "_select"
        },
        forwardObservers: [
            "query.totalItems",
            "query.label",
            "query.filters.currentFilter.name"
        ]
    })
], PersistentObjectTabBarItem);

let PersistentObjectTabBar = class PersistentObjectTabBar extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  position: relative;
  line-height: var(--theme-h1);
  height: var(--theme-h1);
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
:host vi-overflow::part(button) {
  width: var(--theme-h1);
}
:host vi-overflow::part(button):hover {
  background-color: var(--color-faint);
}</style>

<vi-overflow class="fit">
    <dom-repeat items="[[tabs]]" filter="_isVisible" observe="isVisible" as="tab">
        <template>
            <vi-persistent-object-tab-bar-item tab="{{tab}}" selected-tab="{{selectedTab}}" on-tab-selected="_tabSelected"></vi-persistent-object-tab-bar-item>
        </template>
    </dom-repeat>
</vi-overflow>`; }
    _hookObservers() {
        if (this._observeDisposer) {
            this._observeDisposer();
            this._observeDisposer = undefined;
        }
        if (this.isConnected && this.tabs) {
            this._observeDisposer = this._forwardObservable(this.tabs, "isVisible", "tabs", () => {
                if (!this.selectedTab || !this.selectedTab.isVisible)
                    this.selectedTab = this.tabs.filter(t => t.isVisible)[0];
            });
        }
        if (!this.selectedTab || !this.selectedTab.isVisible)
            this.selectedTab = this.tabs.filter(t => t.isVisible)[0];
    }
    _tabSelected(e, detail) {
        this.selectedTab = detail.tab;
        Popup.closeAll(this);
    }
    isInline(mode) {
        return mode === "inline";
    }
    isDropDown(mode) {
        return mode === "dropdown";
    }
    _isVisible(tab) {
        return tab.isVisible;
    }
};
PersistentObjectTabBar = __decorate([
    WebComponent.register({
        properties: {
            tabs: Array,
            selectedTab: {
                type: Object,
                notify: true
            },
            mode: {
                type: String,
                value: "inline",
                reflectToAttribute: true
            }
        },
        observers: [
            "_hookObservers(isConnected, tabs)"
        ]
    })
], PersistentObjectTabBar);

let PersistentObject = class PersistentObject extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: column-reverse;
  --vi-persistent-object-master-width: 40%;
  --vi-persistent-object-master-min-width: 5%;
  --vi-persistent-object-master-max-width: 95%;
}
:host vi-action-bar {
  padding-top: 3px;
  border-bottom: 1px solid var(--theme-light-border);
}
:host header {
  background-color: var(--color);
  color: white;
  line-height: var(--theme-h1);
  height: var(--theme-h1);
  font-size: calc(var(--theme-h5) + var(--theme-h4));
  white-space: nowrap;
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  padding-left: var(--theme-h4);
  z-index: 2;
  gap: 4px;
}
:host header vi-spinner {
  align-self: center;
}
:host header nav {
  display: flex;
  gap: var(--theme-h5);
}
:host header nav vi-button {
  width: var(--theme-h1);
}
:host .tabs {
  background-color: #f1f1f1;
  box-shadow: var(--theme-box-shadow);
}
:host vi-persistent-object-tab-presenter > vi-query-items-presenter {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
:host .content .detail vi-persistent-object-tab-presenter {
  margin: 1px 1px 1px 0;
}
:host .tabs {
  height: var(--theme-h1);
}
:host([layout-master-detail]) .tabs > .detail {
  margin-left: 4px;
}
:host([layout-master-detail]) #splitter {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  position: relative;
  width: 4px;
  background-color: #f1f1f1;
  cursor: col-resize;
}
:host([layout-master-detail]) #splitter::after {
  position: absolute;
  content: " ";
  width: 7px;
  left: 0;
  top: 0;
  bottom: 0;
  opacity: 0.01;
  background-color: white;
  z-index: 3;
  transform: translateX(-3px);
}
:host([layout-master-detail]) .master {
  min-width: var(--vi-persistent-object-master-min-width);
  max-width: var(--vi-persistent-object-master-max-width);
  width: var(--vi-persistent-object-master-width);
}
:host([layout-details-only]) .master {
  display: none;
}
:host([layout-details-only]) .detail vi-persistent-object-tab-presenter {
  margin-left: 1px;
}
:host([layout-full-page]) .master {
  flex: 1;
  min-height: 0;
  min-width: 0;
}
:host([layout-full-page]) .detail {
  display: none;
}
:host(:not([layout-master-tabs]):not([layout-detail-tabs])) .tabs {
  display: none;
}
:host(:not([layout-master-tabs]):not([layout-detail-tabs])) .content vi-action-bar {
  padding-top: 0;
  z-index: 1;
  box-shadow: var(--theme-box-shadow);
  margin-bottom: 3px;
}
:host(:not([layout-master-tabs]):not([layout-detail-tabs])) .content vi-persistent-object-tab-presenter {
  z-index: 0;
  margin-left: 1px;
}
:host(:not([layout-master-actions]):not([layout-detail-actions])) .master vi-action-bar, :host(:not([layout-master-actions]):not([layout-detail-actions])) .detail vi-action-bar {
  display: none;
}
:host(:not([layout-master-detail]):not([layout-details-only]):not([layout-full-page])) header, :host(:not([layout-master-detail]):not([layout-details-only]):not([layout-full-page])) .tabs, :host(:not([layout-master-detail]):not([layout-details-only]):not([layout-full-page])) .content {
  display: none;
}
:host([loading]) > header, :host([loading]) > div {
  visibility: hidden;
}</style>

<div class="horizontal layout flex content">
    <div class="vertical layout master">
        <vi-action-bar service-object="[[selectedMasterTab.target]]" hidden$="[[_hideActionBar(selectedMasterTab)]]"></vi-action-bar>
        <vi-notification service-object="[[selectedMasterTab.target]]"></vi-notification>
        <vi-persistent-object-tab-presenter class="flex" tab="[[selectedMasterTab]]"></vi-persistent-object-tab-presenter>
    </div>
    <div id="splitter" on-track="_trackSplitter"></div>
    <vi-persistent-object-details-content class="vertical layout flex detail" tab="{{selectedDetailTab}}" hide-action-bar="[[_hideActionBar(selectedDetailTab)]]"></vi-persistent-object-details-content>
</div>
<div class="horizontal layout tabs">
    <div class="master">
        <vi-persistent-object-tab-bar tabs="[[masterTabs]]" selected-tab="{{selectedMasterTab}}"></vi-persistent-object-tab-bar>
    </div>
    <vi-persistent-object-details-header class="flex detail" tabs="[[detailTabs]]" tab="{{selectedDetailTab}}"></vi-persistent-object-details-header>
</div>
<header class="layout horizontal">
    <vi-sensitive disabled="[[!persistentObject.isBreadcrumbSensitive]]">
        <span class="flex">[[persistentObject.breadcrumb]]</span>
    </vi-sensitive>
    <vi-spinner block color="white" hidden$="[[!isBusy]]"></vi-spinner>
    <dom-if if="[[showNavigation]]">
        <template>
            <nav class="layout horizontal">
                <span>[[_getNavigationIndex(persistentObject)]]</span>
                <vi-button icon="ChevronLeft" data-direction="previous" on-tap="_navigate" busy$="[[isBusy]]" disabled$="[[isBusy]]"></vi-button>
                <vi-button icon="ChevronRight" data-direction="next" on-tap="_navigate" busy$="[[isBusy]]" disabled$="[[isBusy]]"></vi-button>
            </nav>
        </template>
    </dom-if>
</header>`; }
    _persistentObjectChanged(persistentObject, isConnected) {
        if (persistentObject && isConnected) {
            this._cacheEntry = (this.app).cache(new AppCacheEntryPersistentObject(this.persistentObject));
            this.selectedMasterTab = this._cacheEntry.selectedMasterTab || this._computeMasterTabs(this.persistentObject, this.persistentObject.tabs)[0] || null;
            this.selectedDetailTab = this._cacheEntry.selectedDetailTab || this._computeDetailTabs(this.persistentObject, this.persistentObject.tabs)[0] || null;
            if (persistentObject.service.application.userSettings["PersistentObjectSettings"] &&
                persistentObject.service.application.userSettings["PersistentObjectSettings"][this.persistentObject.id] &&
                persistentObject.service.application.userSettings["PersistentObjectSettings"][this.persistentObject.id]["master-detail"]) {
                let masterWidth = persistentObject.service.application.userSettings["PersistentObjectSettings"][this.persistentObject.id]["master-detail"];
                if (isNaN(parseInt(masterWidth)))
                    masterWidth = "40%";
                this.masterWidth = masterWidth;
            }
            else
                this.masterWidth = "40%";
        }
    }
    _masterWidthChanged() {
        this.updateStyles({
            "--vi-persistent-object-master-width": this.masterWidth
        });
    }
    _computeMasterTabs(persistentObject, tabs) {
        if (persistentObject.queryLayoutMode === PersistentObjectLayoutMode.FullPage)
            return tabs.filter(t => t.isVisible);
        return tabs ? tabs.filter(t => t.isVisible && t.tabGroupIndex === 0) : [];
    }
    _computeDetailTabs(persistentObject, tabs) {
        if (persistentObject.queryLayoutMode === PersistentObjectLayoutMode.FullPage)
            return [];
        return tabs ? tabs.filter(t => t.isVisible && t.tabGroupIndex === 1) : [];
    }
    _detailTabsChanged() {
        if (!this.detailTabs || this.detailTabs.length === 0) {
            this.selectedDetailTab = null;
            return;
        }
    }
    _masterTabsChanged() {
        if (!this.masterTabs || this.masterTabs.length === 0) {
            this.selectedMasterTab = null;
            return;
        }
    }
    _selectedMasterTabChanged() {
        if (!this._cacheEntry)
            return;
        this._cacheEntry.selectedMasterTab = this.selectedMasterTab;
    }
    _selectedDetailTabChanged() {
        if (!this._cacheEntry)
            return;
        this._cacheEntry.selectedDetailTab = this.selectedDetailTab;
    }
    _computeLayout(persistentObject, masterTabs = [], detailTabs = []) {
        if (!persistentObject)
            return undefined;
        const hasDetailTabs = detailTabs.length > 0;
        const hasMasterTabs = masterTabs.length > 0;
        const layoutFlags = [hasDetailTabs ? (hasMasterTabs ? "master-detail" : "details-only") : "full-page"];
        if (hasDetailTabs)
            layoutFlags.push("dt");
        if (hasMasterTabs && (hasDetailTabs || masterTabs.length > 1))
            layoutFlags.push("mt");
        if (hasMasterTabs && masterTabs.some(t => t.parent.actions.some(a => a.isVisible || a.name === "Filter")))
            layoutFlags.push("ma");
        if (hasDetailTabs && detailTabs.some(t => t.parent.actions.some(a => a.isVisible || a.name === "Filter")))
            layoutFlags.push("da");
        return layoutFlags.join(" ");
    }
    _computeLayoutMasterDetail(persistentObject, masterTabs = [], detailTabs = []) {
        return !!persistentObject && masterTabs.length > 0 && detailTabs.length > 0;
    }
    _computeLayoutDetailsOnly(persistentObject, masterTabs = [], detailTabs = []) {
        return !!persistentObject && masterTabs.length === 0 && detailTabs.length > 0;
    }
    _computeLayoutFullPage(persistentObject, detailTabs = []) {
        return !!persistentObject && detailTabs.length === 0;
    }
    _computeLayoutMasterActions(persistentObject, masterTabs = []) {
        return !!persistentObject && masterTabs.some(t => t.target.actions.some(a => a.isVisible || a.name === "Filter"));
    }
    _computeLayoutDetailActions(persistentObject, detailTabs = []) {
        return !!persistentObject && detailTabs.some(t => t.target.actions.some(a => a.isVisible || a.name === "Filter"));
    }
    _computeLayoutMasterTabs(persistentObject, masterTabs = [], detailTabs = []) {
        return !!persistentObject && masterTabs.length > 0 && (detailTabs.length > 0 || masterTabs.length > 1);
    }
    _computeLayoutDetailTabs(persistentObject, detailTabs = []) {
        return !!persistentObject && detailTabs.length > 0;
    }
    _computeHasMasterTabs(tabs) {
        return tabs && tabs.length > 1;
    }
    _computeHasDetailTabs(tabs) {
        return tabs && tabs.length > 0;
    }
    _computeShowNavigation(persistentObject) {
        return !persistentObject.isNew && persistentObject.ownerQuery?.totalItems > 0 && !persistentObject.isBulkEdit;
    }
    _tabselect(e) {
        let { name, tab } = e.detail;
        if (!tab) {
            tab = this.masterTabs.find(t => t.name === name) || this.detailTabs.find(t => t.name === name);
            if (!tab)
                return;
        }
        if (this.masterTabs.indexOf(tab) >= 0)
            this.selectedMasterTab = tab;
        if (this.detailTabs.indexOf(tab) >= 0)
            this.selectedDetailTab = tab;
        e.stopPropagation();
    }
    _persistentObjectNotificationChanged(notification) {
        if (!notification || !this.persistentObject || this.persistentObject.notificationType !== "Error")
            return;
        const firstAttributeWithValidationError = this.persistentObject.attributes.orderBy(attr => attr.offset).find(attr => !!attr.validationError);
        if (!firstAttributeWithValidationError)
            return;
        if (firstAttributeWithValidationError.tab !== this.selectedMasterTab && this.masterTabs.indexOf(firstAttributeWithValidationError.tab) >= 0)
            this.selectedMasterTab = firstAttributeWithValidationError.tab;
    }
    _trackSplitter(e) {
        if (e.detail.state === "track") {
            const px = parseInt(this.masterWidth);
            this.masterWidth = (px + e.detail.ddx) + "px";
        }
        else if (e.detail.state === "start") {
            this.app.isTracking = true;
            this.app.classList.add("dragging");
            if (this.masterWidth.endsWith("%"))
                this.masterWidth = (this.offsetWidth * (parseInt(this.masterWidth) / 100)).toString() + "px";
        }
        else if (e.detail.state === "end") {
            this.app.classList.remove("dragging");
            window.getSelection().removeAllRanges();
            if (this.masterWidth.endsWith("px")) {
                const px = parseInt(this.masterWidth);
                const newMasterWidth = 100 / this.offsetWidth * px;
                this.masterWidth = `${!isNaN(newMasterWidth) ? newMasterWidth.toString() : "40"}%`;
            }
            const persistentObjectSettings = this.persistentObject.service.application.userSettings["PersistentObjectSettings"] || (this.persistentObject.service.application.userSettings["PersistentObjectSettings"] = {});
            const thisPersistentObjectSettings = persistentObjectSettings[this.persistentObject.id] || (persistentObjectSettings[this.persistentObject.id] = {});
            thisPersistentObjectSettings["master-detail"] = this.masterWidth;
            this.persistentObject.service.application.saveUserSettings();
            this.app.isTracking = false;
        }
        e.stopPropagation();
    }
    _hideActionBar(tab) {
        if (!tab)
            return false;
        const config = this.app.configuration.getTabConfig(tab);
        if (!config)
            return false;
        return !!config.hideActionBar;
    }
    _getNavigationIndex(persistentObject) {
        if (!persistentObject.ownerQuery)
            return;
        const index = persistentObject.ownerQuery.items.findIndex(i => i.id === persistentObject.objectId);
        return `${index + 1} / ${persistentObject.ownerQuery.totalItems}${persistentObject.ownerQuery.hasMore ? "+" : ""}`;
    }
    async _navigate(e) {
        let index = this.persistentObject.ownerQuery.items.findIndex(i => i.id === this.persistentObject.objectId);
        index += (e.target.getAttribute("data-direction") === "previous" ? -1 : 1);
        if (!this.persistentObject.ownerQuery.hasMore)
            index = (index + this.persistentObject.ownerQuery.totalItems) % this.persistentObject.ownerQuery.totalItems;
        if (index < 0)
            return;
        const currentPath = this.app.path;
        try {
            let targetItem = this.persistentObject.ownerQuery.items[index] || await (this.persistentObject.ownerQuery.getItemsByIndex(index))[0];
            if (targetItem == null) {
                targetItem = await this.persistentObject.ownerQuery.queueWork(async () => {
                    return this.persistentObject.ownerQuery.items[index];
                });
                if (targetItem == null)
                    return;
            }
            if (currentPath !== this.app.path)
                return;
            const targetPersistentObject = await targetItem.getPersistentObject(true);
            if (currentPath !== this.app.path)
                return;
            this.service.hooks.onOpen(targetPersistentObject, true);
        }
        catch (e) {
            this.app.showAlert(e, "Error");
        }
    }
};
PersistentObject = __decorate([
    WebComponent.register({
        properties: {
            persistentObject: {
                type: Object,
            },
            tabs: {
                type: Array,
                computed: "persistentObject.tabs"
            },
            masterWidth: {
                type: Number,
                observer: "_masterWidthChanged"
            },
            masterTabs: {
                type: Array,
                computed: "_computeMasterTabs(persistentObject, tabs)",
                observer: "_masterTabsChanged"
            },
            hasMasterTabs: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasMasterTabs(masterTabs)"
            },
            selectedMasterTab: {
                type: Object,
                value: null,
                observer: "_selectedMasterTabChanged"
            },
            detailTabs: {
                type: Array,
                computed: "_computeDetailTabs(persistentObject, tabs)",
                observer: "_detailTabsChanged"
            },
            hasDetailTabs: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasDetailTabs(detailTabs)"
            },
            selectedDetailTab: {
                type: Object,
                value: null,
                observer: "_selectedDetailTabChanged"
            },
            layoutMasterDetail: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutMasterDetail(persistentObject, masterTabs, detailTabs)"
            },
            layoutDetailsOnly: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutDetailsOnly(persistentObject, masterTabs, detailTabs)"
            },
            layoutFullPage: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutFullPage(persistentObject, detailTabs)"
            },
            layoutMasterActions: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutMasterActions(persistentObject, masterTabs)"
            },
            layoutDetailActions: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutDetailActions(persistentObject, detailTabs)"
            },
            layoutMasterTabs: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutMasterTabs(persistentObject, masterTabs, detailTabs)"
            },
            layoutDetailTabs: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeLayoutDetailTabs(persistentObject, detailTabs)"
            },
            isBusy: {
                type: Boolean,
                computed: "persistentObject.isBusy"
            },
            showNavigation: {
                type: Boolean,
                computed: "_computeShowNavigation(persistentObject)"
            }
        },
        observers: [
            "_persistentObjectChanged(persistentObject, isConnected)",
            "_persistentObjectNotificationChanged(persistentObject.notification)"
        ],
        forwardObservers: [
            "persistentObject.tabs.*.isVisible",
            "persistentObject.breadcrumb",
            "persistentObject.notification",
            "persistentObject.isBusy"
        ],
        listeners: {
            "tabselect": "_tabselect"
        },
        sensitive: true
    })
], PersistentObject);
let PersistentObjectDetailsContent = class PersistentObjectDetailsContent extends WebComponent {
    static get template() { return html$3 `<style>
    :host {
        --color: var(--theme-accent-color);
        --color-light: var(--theme-accent-color-light);
        --color-lighter: var(--theme-accent-color-lighter);
        --color-dark: var(--theme-accent-color-dark);
        --color-darker: var(--theme-accent-color-darker);
        --color-faint: var(--theme-accent-color-faint);
        --color-semi-faint: var(--theme-accent-color-semi-faint);
        --color-rgb: var(--theme-accent-color-rgb);
    }

    :host vi-action-bar {
        padding-top: 3px;
        border-bottom: 1px solid var(--theme-light-border);
    }
</style>

<vi-action-bar service-object="[[tab.target]]" hidden$="[[hideActionBar]]"></vi-action-bar>
<vi-notification service-object="[[tab.target]]"></vi-notification>
<vi-persistent-object-tab-presenter class="flex" tab="[[tab]]"></vi-persistent-object-tab-presenter>`; }
};
PersistentObjectDetailsContent = __decorate([
    WebComponent.register({
        properties: {
            tab: Object,
            hideActionBar: Boolean
        }
    })
], PersistentObjectDetailsContent);
let PersistentObjectDetailsHeader = class PersistentObjectDetailsHeader extends WebComponent {
    static get template() { return html$3 `<style>
    :host {
        --color: var(--theme-accent-color);
        --color-light: var(--theme-accent-color-light);
        --color-lighter: var(--theme-accent-color-lighter);
        --color-dark: var(--theme-accent-color-dark);
        --color-darker: var(--theme-accent-color-darker);
        --color-faint: var(--theme-accent-color-faint);
        --color-semi-faint: var(--theme-accent-color-semi-faint);
        --color-rgb: var(--theme-accent-color-rgb);
    }
</style>

<vi-persistent-object-tab-bar tabs="[[tabs]]" selected-tab="{{tab}}"></vi-persistent-object-tab-bar>`; }
};
PersistentObjectDetailsHeader = __decorate([
    WebComponent.register({
        properties: {
            tabs: Object,
            tab: {
                type: Object,
                notify: true
            }
        }
    })
], PersistentObjectDetailsHeader);

let PersistentObjectPresenter = class PersistentObjectPresenter extends ConfigurableWebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
}
:host([has-error]) {
  align-items: center;
  justify-content: center;
  color: var(--theme-color-error);
  fill: var(--theme-color-error);
}
:host([has-error]) span {
  display: block;
  text-align: center;
  padding: var(--theme-h5) var(--theme-h3);
}
:host([has-error]) vi-icon {
  --vi-icon-width: var(--theme-h1);
  --vi-icon-height: var(--theme-h1);
}
:host ::slotted(*) {
  flex: 1;
  min-height: 0;
  min-width: 0;
}</style>

<dom-if if="[[error]]" restamp>
    <template>
        <vi-error class="flex" message="[[error]]"></vi-error>
    </template>
</dom-if>
<slot></slot>
<dom-if if="[[loading]]">
    <template>
        <vi-spinner></vi-spinner>
    </template>
</dom-if>`; }
    _activate(e) {
        const { parameters } = e.detail;
        if (parameters.fromActionId) {
            if (this._cacheEntry = this.app.cachePing(new AppCacheEntryPersistentObjectFromAction(undefined, parameters.fromActionId)))
                this.persistentObject = this._cacheEntry.persistentObject;
            if (!this._cacheEntry) {
                this.persistentObject = null;
                this._setLoading(false);
                this._setError(this.translateMessage("NotFound"));
                return;
            }
        }
        else {
            const cacheEntry = new AppCacheEntryPersistentObject(parameters.id, parameters.objectId);
            this._cacheEntry = this.app.cachePing(cacheEntry);
            if (!this._cacheEntry)
                this.app.cache(this._cacheEntry = cacheEntry);
            if (this._cacheEntry.persistentObject)
                this.persistentObject = this._cacheEntry.persistentObject;
            else {
                this.persistentObject = this.persistentObjectObjectId = this.persistentObjectId = undefined;
                this.persistentObjectObjectId = this._cacheEntry.objectId || "";
                this.persistentObjectId = this._cacheEntry.id;
            }
        }
    }
    async _deactivate(e) {
        const route = this.parentNode;
        const currentPath = AppBase.removeRootPath(route.path);
        const newPath = AppBase.removeRootPath(this.app.path);
        if (this.persistentObject && this.persistentObject.isDirty && this.persistentObject.actions.some(a => a.name === "Save" || a.name === "EndEdit") && currentPath !== newPath) {
            e.preventDefault();
            const result = await this.app.showMessageDialog({
                title: this.service.getTranslatedMessage("PagesWithUnsavedChanges"),
                noClose: true,
                message: this.service.getTranslatedMessage("ConfirmLeavePage"),
                actions: [
                    this.service.getTranslatedMessage("StayOnThisPage"),
                    this.service.getTranslatedMessage("LeaveThisPage")
                ]
            });
            if (result === 1) {
                this.app.cacheEntries.forEach(entry => {
                    if (entry instanceof AppCacheEntryPersistentObject && !!entry.persistentObject && entry.persistentObject.isDirty && entry.persistentObject.actions.some(a => a.name === "Save" || a.name === "EndEdit")) {
                        if (entry.persistentObject.isNew)
                            this.app.cacheRemove(entry);
                        else
                            entry.persistentObject.cancelEdit();
                    }
                });
                this.app.changePath(newPath);
                route.deactivator(true);
            }
            else {
                route.deactivator(false);
                this.app.changePath(currentPath);
            }
        }
    }
    async _updatePersistentObject(persistentObjectId, persistentObjectObjectId, isConnected) {
        this._setError(null);
        if (!this.isConnected || (this.persistentObject && this.persistentObject.id === persistentObjectId && this.persistentObject.objectId === persistentObjectObjectId))
            return;
        if (persistentObjectId != null) {
            this._setLoading(true);
            try {
                const po = await this.service.getPersistentObject(null, persistentObjectId, persistentObjectObjectId);
                const cacheEntry = this.app.cache(new AppCacheEntryPersistentObject(persistentObjectId, persistentObjectObjectId));
                cacheEntry.persistentObject = po;
                if (persistentObjectId === this.persistentObjectId && persistentObjectObjectId === this.persistentObjectObjectId) {
                    this.persistentObject = po;
                    this._cacheEntry = cacheEntry;
                }
            }
            catch (e) {
                this._setError(e);
                this._setLoading(false);
            }
        }
        else
            this.persistentObject = null;
    }
    async _persistentObjectChanged(persistentObject, oldPersistentObject) {
        this._setError(null);
        if (oldPersistentObject)
            this.empty();
        if (persistentObject) {
            const config = this.app.configuration.getPersistentObjectConfig(persistentObject);
            this._setTemplated(!!config && config.hasTemplate);
            if (this.templated) {
                this.appendChild(config.stamp(persistentObject, config.as || "persistentObject"));
                this._setLoading(false);
            }
            else
                this._renderPersistentObject(persistentObject);
        }
    }
    _updateTitle(breadcrumb) {
        if (!breadcrumb)
            return;
        this.fire("title-changed", { title: this.persistentObject.isBreadcrumbSensitive && this.isAppSensitive ? null : breadcrumb }, { bubbles: true });
    }
    async _renderPersistentObject(persistentObject) {
        if (persistentObject !== this.persistentObject)
            return;
        const persistentObjectComponent = renderCallback ? renderCallback(persistentObject) : new PersistentObject();
        persistentObjectComponent.persistentObject = persistentObject;
        this.appendChild(persistentObjectComponent);
        this._setLoading(false);
    }
    _edit() {
        if (!this.persistentObject)
            return;
        const action = this.persistentObject.actions["Edit"];
        if (action)
            action.execute();
    }
    _save() {
        if (!this.persistentObject)
            return;
        const action = (this.persistentObject.actions["Save"] || this.persistentObject.actions["EndEdit"]);
        if (action)
            action.execute();
    }
    _cancelSave() {
        if (!this.persistentObject)
            return;
        const action = (this.persistentObject.actions["CancelEdit"] || this.persistentObject.actions["CancelSave"]);
        if (action)
            action.execute();
    }
    _configure(e) {
        if (!this.persistentObject || this.persistentObject.isSystem)
            return;
        e.detail.push({
            label: `Persistent Object: ${this.persistentObject.type}`,
            icon: "viConfigure",
            action: () => {
                this.app.changePath(`management/persistent-object.316b2486-df38-43e3-bee2-2f7059334992/${this.persistentObject.id}`);
            }
        });
    }
    static registerRenderCallback(callback) {
        renderCallback = callback;
    }
};
PersistentObjectPresenter = __decorate([
    ConfigurableWebComponent.register({
        properties: {
            persistentObjectId: {
                type: String,
                reflectToAttribute: true
            },
            persistentObjectObjectId: {
                type: String,
                reflectToAttribute: true
            },
            persistentObject: {
                type: Object,
                observer: "_persistentObjectChanged"
            },
            loading: {
                type: Boolean,
                readOnly: true,
                value: true,
                reflectToAttribute: true
            },
            templated: {
                type: Boolean,
                reflectToAttribute: true,
                readOnly: true
            },
            error: {
                type: String,
                readOnly: true
            }
        },
        observers: [
            "_updatePersistentObject(persistentObjectId, persistentObjectObjectId, isConnected)",
            "_updateTitle(persistentObject.breadcrumb)"
        ],
        forwardObservers: [
            "persistentObject.breadcrumb"
        ],
        listeners: {
            "app-route-activate": "_activate",
            "app-route-deactivate": "_deactivate",
            "vi:configure": "_configure"
        },
        keybindings: {
            "f2": {
                listener: "_edit",
                priority: 10
            },
            "ctrl+s": "_save",
            "esc": "_cancelSave"
        },
        sensitive: true
    })
], PersistentObjectPresenter);
let renderCallback = null;

let ProgramUnitPresenter = class ProgramUnitPresenter extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: block;
  position: relative;
}</style>

<dom-if if="[[error]]" restamp>
    <template>
        <vi-error class="fit" message="[[error]]"></vi-error>
    </template>
</dom-if>
<slot></slot>`; }
    _activate(e) {
        const { parameters } = e.detail;
        if (!this.service || !this.service.application)
            return;
        this._setProgramUnit(this.service.application.programUnits.find(pu => pu.name === parameters.programUnitName || pu.nameKebab === parameters.programUnitName));
        if (!this.programUnit) {
            e.preventDefault();
            this._setError(this.translateMessage("NotFound"));
        }
    }
    _programUnitChanged(programUnit, oldProgramUnit) {
        if (oldProgramUnit)
            this.empty();
        this.fire("title-changed", { title: programUnit ? programUnit.title : null }, { bubbles: true });
        if (!programUnit)
            return;
        const config = this.app.configuration.getProgramUnitConfig(programUnit.name);
        if (!!config && config.hasTemplate)
            this.appendChild(config.stamp(programUnit, config.as || "programUnit"));
    }
};
ProgramUnitPresenter = __decorate([
    WebComponent.register({
        properties: {
            programUnit: {
                type: Object,
                readOnly: true,
                observer: "_programUnitChanged"
            },
            error: {
                type: String,
                readOnly: true
            }
        },
        listeners: {
            "app-route-activate": "_activate"
        }
    })
], ProgramUnitPresenter);

let QueryChartSelector = class QueryChartSelector extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  border-left: 1px solid #EAEAEA;
  margin-left: var(--theme-h5);
  padding-left: var(--theme-h5);
}
:host > button, :host button[slot=header] {
  height: var(--theme-h1);
}</style>

<vi-button on-tap="_showGrid" inverse icon="Grid"></vi-button>
<dom-repeat items="[[types]]" as="type">
    <template>
        <dom-if if="[[!type.single]]">
            <template>
                <vi-popup-menu>
                    <vi-button slot="header" inverse icon="[[type.icon]]"></vi-button>
                    <dom-repeat items="[[type.charts]]" as="chart">
                        <template>
                            <vi-popup-menu-item label="[[chart.label]]" on-tap="_showChart"></vi-popup-menu-item>
                        </template>
                    </dom-repeat>
                </vi-popup-menu>
            </template>
        </dom-if>
        <dom-if if="[[type.single]]">
            <template>
                <vi-button on-tap="_showChart" data-chart-type="[[type.type]]" inverse icon="[[type.icon]]"></vi-button>
            </template>
        </dom-if>
    </template>
</dom-repeat>`; }
    _computeTypes(charts) {
        if (!charts || !charts.length)
            return null;
        return charts.groupBy(c => c.type).filter(cg => !!this.app.configuration.getQueryChartConfig(cg.key)).map(ct => new ChartType(ct.key, ct.value));
    }
    _showGrid(e) {
        this.query.currentChart = null;
    }
    _showChart(e) {
        this.query.currentChart = e.model.chart || (e.model.type && e.model.type.single ? e.model.type.charts[0] : null);
    }
};
QueryChartSelector = __decorate([
    WebComponent.register({
        properties: {
            query: Object,
            types: {
                type: Array,
                computed: "_computeTypes(query.charts, app)"
            }
        },
        forwardObservers: [
            "query.charts",
            "query.currentChart"
        ]
    })
], QueryChartSelector);
class ChartType {
    constructor(_type, charts) {
        this._type = _type;
        this.charts = charts;
        if (!exists(this._icon = "Chart_" + _type))
            this._icon = "Chart_Unknown";
    }
    get icon() {
        return this._icon;
    }
    get type() {
        return this._type;
    }
    get single() {
        return this.charts.length === 1;
    }
}

let Query = class Query extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: grid;
  grid-template-columns: minmax(0, 1fr);
  grid-template-rows: auto auto auto minmax(0, 1fr);
}
:host vi-action-bar {
  box-shadow: var(--theme-box-shadow);
  z-index: 1;
}
:host header {
  background-color: var(--color);
  color: white;
  line-height: var(--theme-h1);
  height: var(--theme-h1);
  font-size: calc(var(--theme-h5) + var(--theme-h4));
  white-space: nowrap;
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  padding-left: var(--theme-h4);
  z-index: 2;
}
:host vi-query-items-presenter {
  margin: 3px 0 0 0;
  z-index: 0;
}
:host([no-actions]) > header {
  box-shadow: var(--theme-box-shadow);
}
:host([no-actions]) vi-action-bar {
  display: none !important;
}
:host([hide-header]) vi-query-items-presenter {
  margin: 0;
}
:host vi-query-items-presenter {
  grid-row: 4;
}</style>

<dom-if if="[[!hideHeader]]">
    <template>
        <header>[[label]]</header>
        <vi-action-bar class="horizontal layout center" service-object="[[query]]" hidden$="[[noActions]]"></vi-action-bar>
        <vi-notification service-object="[[query]]"></vi-notification>
    </template>
</dom-if>
<vi-query-items-presenter query="[[query]]"></vi-query-items-presenter>`; }
    connectedCallback() {
        super.connectedCallback();
        this._queryChanged();
    }
    _queryChanged() {
        if (this.query && this.isConnected) {
            this._cacheEntry = this.app.cache(new AppCacheEntryQuery(this.query.id));
            this._cacheEntry.query = this.query;
        }
        else
            this._cacheEntry = null;
    }
    _computeNoActions(actions) {
        return actions && actions.filter(a => a.isVisible).length === 0 && actions["Filter"] == null;
    }
    _computeSearchOnHeader(noActions, query) {
        return noActions && query && query.actions["Filter"] != null;
    }
    _computeLabel(labelWithTotalItems, currentFilter) {
        return labelWithTotalItems + (currentFilter && currentFilter.name ? " — " + currentFilter.name : "");
    }
    _computeHideHeader(query, app) {
        if (!query || !app)
            return false;
        const config = app.configuration.getQueryConfig(query);
        return !!config && !!config.hideHeader;
    }
};
Query = __decorate([
    WebComponent.register({
        properties: {
            query: {
                type: Object,
                observer: "_queryChanged"
            },
            noActions: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeNoActions(query.actions)"
            },
            label: {
                type: String,
                computed: "_computeLabel(query.labelWithTotalItems, currentFilter)"
            },
            currentFilter: {
                type: Object,
                computed: "query.filters.currentFilter",
                value: null
            },
            hideHeader: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHideHeader(query, app)"
            }
        },
        forwardObservers: [
            "query.labelWithTotalItems",
            "query.filters.currentFilter.name"
        ]
    })
], Query);

let QueryPresenter = class QueryPresenter extends WebComponent {
    static get template() { return html$3 `<style>:host {
  display: flex;
  flex-direction: row;
  position: relative;
}
:host([has-error]) {
  align-items: center;
  justify-content: center;
  color: var(--theme-color-error);
  fill: var(--theme-color-error);
}
:host([has-error]) span {
  display: block;
  text-align: center;
  padding: var(--theme-h5) var(--theme-h3);
}
:host([has-error]) vi-icon {
  --vi-icon-width: var(--theme-h1);
  --vi-icon-height: var(--theme-h1);
}
:host ::slotted(vi-query-items-presenter), :host ::slotted(vi-query) {
  flex: 1;
  min-height: 0;
  min-width: 0;
}</style>

<dom-if if="[[loading]]">
    <template>
        <vi-spinner></vi-spinner>
    </template>
</dom-if>
<dom-if if="[[hasError]]" restamp>
    <template>
        <div id="error">
            <vi-icon source="Notification_Error"></vi-icon>
            <span>[[error]]</span>
        </div>
    </template>
</dom-if>
<slot></slot>`; }
    _activate(e) {
        const { parameters } = e.detail;
        this._cacheEntry = this.app.cache(new AppCacheEntryQuery(parameters.id));
        if (this._cacheEntry && this._cacheEntry.query)
            this.query = this._cacheEntry.query;
        else {
            this.queryId = this.query = undefined;
            this.queryId = parameters.id;
        }
    }
    _computeHasError(error) {
        return !String.isNullOrEmpty(error);
    }
    async _updateQuery(queryId, app) {
        this._setError(null);
        if ((this.query && queryId && this.query.id.toUpperCase() === queryId.toUpperCase()))
            return;
        this.empty();
        if (this.queryId) {
            if (this.query)
                this.query = null;
            try {
                this._setLoading(true);
                const query = await app.service.getQuery(this.queryId);
                if (query.id.toUpperCase() === this.queryId.toUpperCase()) {
                    this._cacheEntry = this.app.cache(new AppCacheEntryQuery(query.id));
                    this.query = this._cacheEntry.query = query;
                }
            }
            catch (e) {
                this._setError(e);
            }
            finally {
                this._setLoading(false);
            }
        }
        else
            this.query = null;
    }
    async _queryChanged(query, oldQuery) {
        if (this.isConnected && oldQuery)
            this.empty();
        if (query) {
            if (this.queryId !== query.id)
                this.queryId = query.id;
            if (this.query !== query)
                return;
            this._renderQuery(query);
        }
    }
    _renderQuery(query) {
        if (query !== this.query)
            return;
        const queryComponent = new Query();
        queryComponent.query = query;
        this.appendChild(queryComponent);
        this._setLoading(false);
    }
    _updateTitle(title) {
        this.fire("title-changed", { title: title }, { bubbles: true });
    }
};
QueryPresenter = __decorate([
    WebComponent.register({
        properties: {
            queryId: {
                type: String,
                reflectToAttribute: true
            },
            query: {
                type: Object,
                observer: "_queryChanged"
            },
            loading: {
                type: Boolean,
                readOnly: true,
                value: true,
                reflectToAttribute: true
            },
            error: {
                type: String,
                readOnly: true
            },
            hasError: {
                type: Boolean,
                reflectToAttribute: true,
                computed: "_computeHasError(error)"
            }
        },
        observers: [
            "_updateQuery(queryId, app)",
            "_updateTitle(query.labelWithTotalItems)"
        ],
        listeners: {
            "app-route-activate": "_activate"
        },
        forwardObservers: [
            "query.labelWithTotalItems"
        ]
    })
], QueryPresenter);

export { ActionBar, ActionButton, Alert, App, AppBase, AppCacheEntry, AppCacheEntryPersistentObject, AppCacheEntryPersistentObjectFromAction, AppCacheEntryQuery, AppColor, AppConfig, AppRoute, AppRoutePresenter, AppServiceHooks, AppServiceHooksBase, AppSetting, Audit, BigNumber, Button, Checkbox, ConfigurableWebComponent, ConnectedNotifier, DatePicker, Dialog, Error$1 as Error, FileDrop, Icon, iconRegister as IconRegister, InputSearch, Keys, List, MaskedInput, Menu, MenuItem, MessageDialog, Notification, Overflow, Path, PersistentObject, PersistentObjectAttribute, PersistentObjectAttributeAsDetail, PersistentObjectAttributeAsDetailRow, PersistentObjectAttributeBinaryFile, PersistentObjectAttributeBoolean, PersistentObjectAttributeComboBox, PersistentObjectAttributeCommonMark, PersistentObjectAttributeConfig, PersistentObjectAttributeDateTime, PersistentObjectAttributeDropDown, PersistentObjectAttributeEdit, PersistentObjectAttributeFlagsEnum, PersistentObjectAttributeFlagsEnumFlag, PersistentObjectAttributeIcon, PersistentObjectAttributeImage, PersistentObjectAttributeImageDialog, PersistentObjectAttributeKeyValueList, PersistentObjectAttributeLabel, PersistentObjectAttributeMultiLineString, PersistentObjectAttributeMultiString, PersistentObjectAttributeMultiStringItem, PersistentObjectAttributeMultiStringItems, PersistentObjectAttributeNullableBoolean, PersistentObjectAttributeNumeric, PersistentObjectAttributePassword, PersistentObjectAttributePresenter, PersistentObjectAttributeReference, PersistentObjectAttributeString, PersistentObjectAttributeTranslatedString, PersistentObjectAttributeTranslatedStringDialog, PersistentObjectAttributeUser, PersistentObjectAttributeValidationError, PersistentObjectConfig, PersistentObjectDetailsContent, PersistentObjectDetailsHeader, PersistentObjectDialog, PersistentObjectGroup, PersistentObjectPresenter, PersistentObjectTab, PersistentObjectTabBar, PersistentObjectTabBarItem, PersistentObjectTabConfig, PersistentObjectTabPresenter, PersistentObjectWizardDialog, polymer as Polymer, Popup, PopupMenu, PopupMenuItem, PopupMenuItemSeparator, PopupMenuItemSplit, PopupMenuItemWithActions, Profiler, ProgramUnitConfig, ProgramUnitPresenter, Query, QueryChartConfig, QueryChartSelector, QueryConfig, QueryGrid, QueryGridCell, QueryGridCellBoolean, QueryGridCellDefault, QueryGridCellImage, QueryGridColumn, QueryGridColumnFilter, QueryGridColumnHeader, QueryGridColumnMeasure, QueryGridConfigureDialog, QueryGridConfigureDialogColumn, QueryGridConfigureDialogColumnList, QueryGridFilterDialog, QueryGridFilterDialogName, QueryGridFilters, QueryGridFooter, QueryGridGrouping, QueryGridRow, QueryGridRowGroup, QueryGridSelectAll, QueryGridUserSettings, QueryItemsPresenter, QueryPresenter, RetryActionDialog, Scroller, Select, SelectOptionItem, SelectReferenceDialog, Sensitive, SessionPresenter, SignIn, SignOut, SizeTracker, Sortable, Spinner, Tags, TemplateConfig, TimePicker, Toggle, User, Vidyano, WebComponent, moment };
